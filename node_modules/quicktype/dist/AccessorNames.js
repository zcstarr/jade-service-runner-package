"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var TypeAttributes_1 = require("./TypeAttributes");
var Support_1 = require("./Support");
var Messages_1 = require("./Messages");
exports.accessorNamesTypeAttributeKind = new TypeAttributes_1.TypeAttributeKind("accessorNames");
// Returns [name, isFixed].
function getFromEntry(entry, language) {
    if (typeof entry === "string")
        return [entry, false];
    var maybeForLanguage = entry.get(language);
    if (maybeForLanguage !== undefined)
        return [maybeForLanguage, true];
    var maybeWildcard = entry.get("*");
    if (maybeWildcard !== undefined)
        return [maybeWildcard, false];
    return undefined;
}
function lookupKey(accessors, key, language) {
    var entry = accessors.get(key);
    if (entry === undefined)
        return undefined;
    return getFromEntry(entry, language);
}
function objectPropertyNames(o, language) {
    var accessors = exports.accessorNamesTypeAttributeKind.tryGetInAttributes(o.getAttributes());
    var map = o.getProperties();
    if (accessors === undefined)
        return map.map(function (_) { return undefined; });
    return map.map(function (_cp, n) { return lookupKey(accessors, n, language); });
}
exports.objectPropertyNames = objectPropertyNames;
function enumCaseNames(e, language) {
    var accessors = exports.accessorNamesTypeAttributeKind.tryGetInAttributes(e.getAttributes());
    var map = e.cases.toMap();
    if (accessors === undefined)
        return map.map(function (_) { return undefined; });
    return map.map(function (c) { return lookupKey(accessors, c, language); });
}
exports.enumCaseNames = enumCaseNames;
function getAccessorName(names, original) {
    var maybeName = names.get(original);
    if (maybeName === undefined)
        return [undefined, false];
    return maybeName;
}
exports.getAccessorName = getAccessorName;
// Union members can be recombined and reordered, and unions are combined as well, so
// we can't just store an array of accessor entries in a union, one array entry for each
// union member.  Instead, we give each union in the origin type graph a union identifier,
// and each union member type gets a map from union identifiers to accessor entries.
// That way, no matter how the types are recombined, if we find a union member, we can look
// up its union's identifier(s), and then look up the member's accessor entries for that
// identifier.  Of course we might find more than one, potentially conflicting.
var UnionIdentifierTypeAttributeKind = /** @class */ (function (_super) {
    __extends(UnionIdentifierTypeAttributeKind, _super);
    function UnionIdentifierTypeAttributeKind() {
        return _super.call(this, "unionIdentifier") || this;
    }
    UnionIdentifierTypeAttributeKind.prototype.combine = function (a, b) {
        return a.union(b);
    };
    return UnionIdentifierTypeAttributeKind;
}(TypeAttributes_1.TypeAttributeKind));
exports.unionIdentifierTypeAttributeKind = new UnionIdentifierTypeAttributeKind();
var nextUnionIdentifier = 0;
function makeUnionIdentifierAttribute() {
    var attributes = exports.unionIdentifierTypeAttributeKind.makeAttributes(immutable_1.Set([nextUnionIdentifier]));
    nextUnionIdentifier += 1;
    return attributes;
}
exports.makeUnionIdentifierAttribute = makeUnionIdentifierAttribute;
var UnionMemberNamesTypeAttributeKind = /** @class */ (function (_super) {
    __extends(UnionMemberNamesTypeAttributeKind, _super);
    function UnionMemberNamesTypeAttributeKind() {
        return _super.call(this, "unionMemberNames") || this;
    }
    UnionMemberNamesTypeAttributeKind.prototype.combine = function (a, b) {
        return a.merge(b);
    };
    return UnionMemberNamesTypeAttributeKind;
}(TypeAttributes_1.TypeAttributeKind));
exports.unionMemberNamesTypeAttributeKind = new UnionMemberNamesTypeAttributeKind();
function makeUnionMemberNamesAttribute(unionAttributes, entry) {
    var identifiers = Support_1.defined(exports.unionIdentifierTypeAttributeKind.tryGetInAttributes(unionAttributes));
    var map = identifiers.toMap().map(function (_) { return entry; });
    return exports.unionMemberNamesTypeAttributeKind.makeAttributes(map);
}
exports.makeUnionMemberNamesAttribute = makeUnionMemberNamesAttribute;
function unionMemberName(u, member, language) {
    var identifiers = exports.unionIdentifierTypeAttributeKind.tryGetInAttributes(u.getAttributes());
    if (identifiers === undefined)
        return [undefined, false];
    var memberNames = exports.unionMemberNamesTypeAttributeKind.tryGetInAttributes(member.getAttributes());
    if (memberNames === undefined)
        return [undefined, false];
    var names = immutable_1.Set();
    var fixedNames = immutable_1.Set();
    identifiers.forEach(function (i) {
        var maybeEntry = memberNames.get(i);
        if (maybeEntry === undefined)
            return;
        var maybeName = getFromEntry(maybeEntry, language);
        if (maybeName === undefined)
            return;
        var name = maybeName[0], isNameFixed = maybeName[1];
        if (isNameFixed) {
            fixedNames = fixedNames.add(name);
        }
        else {
            names = names.add(name);
        }
    });
    var size;
    var isFixed;
    var first = fixedNames.first();
    if (first !== undefined) {
        size = fixedNames.size;
        isFixed = true;
    }
    else {
        first = names.first();
        if (first === undefined)
            return [undefined, false];
        size = names.size;
        isFixed = false;
    }
    Messages_1.messageAssert(size === 1, "SchemaMoreThanOneUnionMemberName", { names: names.toArray() });
    return [first, isFixed];
}
exports.unionMemberName = unionMemberName;
