"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Support_1 = require("./Support");
function countComponentGraphNodes(components) {
    if (components.length === 0)
        return 0;
    var largest = -1;
    var count = 0;
    for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
        var c = components_1[_i];
        Support_1.assert(c.length > 0, "Empty component not allowed");
        for (var _a = 0, c_1 = c; _a < c_1.length; _a++) {
            var v = c_1[_a];
            Support_1.assert(v >= 0, "Negative vertex index is invalid");
            largest = Math.max(largest, v);
            count += 1;
        }
    }
    Support_1.assert(largest + 1 === count, "Vertex indexes and count don't match up");
    return count;
}
// https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
function stronglyConnectedComponents(successors) {
    var index = 0;
    var stack = [];
    var numNodes = successors.length;
    var indexes = Support_1.repeated(numNodes, -1);
    var lowLinks = Support_1.repeated(numNodes, -1);
    var onStack = Support_1.repeated(numNodes, false);
    var sccs = [];
    function strongconnect(v) {
        // Set the depth index for v to the smallest unused index
        indexes[v] = index;
        lowLinks[v] = index;
        index += 1;
        stack.push(v);
        onStack[v] = true;
        // Consider successors of v
        for (var _i = 0, _a = successors[v]; _i < _a.length; _i++) {
            var w = _a[_i];
            if (indexes[w] < 0) {
                // Successor w has not yet been visited; recurse on it
                strongconnect(w);
                lowLinks[v] = Math.min(lowLinks[v], lowLinks[w]);
            }
            else if (onStack[w]) {
                // Successor w is in stack and hence in the current SCC
                // If w is not on stack, then (v, w) is a cross-edge in the DFS tree and must be ignored
                // Note: The next line may look odd - but is correct.
                // It says w.index not w.lowlink; that is deliberate and from the original paper
                lowLinks[v] = Math.min(lowLinks[v], indexes[w]);
            }
        }
        // If v is a root node, pop the stack and generate an SCC
        if (lowLinks[v] === indexes[v]) {
            var scc = [];
            var w = void 0;
            do {
                w = Support_1.defined(stack.pop());
                onStack[w] = false;
                scc.push(w);
            } while (w !== v);
            sccs.push(scc);
        }
    }
    for (var v = 0; v < numNodes; v++) {
        if (indexes[v] < 0) {
            strongconnect(v);
        }
    }
    Support_1.assert(countComponentGraphNodes(sccs) === numNodes, "We didn't put all the nodes into SCCs");
    return sccs;
}
function buildComponentOfNodeMap(successors, components) {
    var numComponents = components.length;
    var numNodes = successors.length;
    Support_1.assert(numNodes === countComponentGraphNodes(components), "Components don't match up with graph");
    var componentOfNode = Support_1.repeated(numNodes, -1);
    for (var c = 0; c < numComponents; c++) {
        for (var _i = 0, _a = components[c]; _i < _a.length; _i++) {
            var n = _a[_i];
            Support_1.assert(componentOfNode[n] < 0, "We have a node that's in two components");
            componentOfNode[n] = c;
        }
    }
    return componentOfNode;
}
function buildMetaSuccessors(successors, components) {
    var numComponents = components.length;
    var componentOfNode = buildComponentOfNodeMap(successors, components);
    var componentAdded = Support_1.repeated(numComponents, false);
    var metaSuccessors = [];
    for (var c = 0; c < numComponents; c++) {
        var succ = [];
        for (var _i = 0, _a = components[c]; _i < _a.length; _i++) {
            var n = _a[_i];
            for (var _b = 0, _c = successors[n]; _b < _c.length; _b++) {
                var s = _c[_b];
                var ms = componentOfNode[s];
                if (ms === c || componentAdded[ms])
                    continue;
                succ.push(ms);
                componentAdded[ms] = true;
            }
        }
        // reset bookkeeping
        for (var _d = 0, succ_1 = succ; _d < succ_1.length; _d++) {
            var ms = succ_1[_d];
            Support_1.assert(componentAdded[ms]);
            componentAdded[ms] = false;
        }
        metaSuccessors.push(succ);
    }
    return metaSuccessors;
}
function invertEdges(successors) {
    var numNodes = successors.length;
    var predecessors = Support_1.repeatedCall(numNodes, function () { return []; });
    for (var s = 0; s < numNodes; s++) {
        for (var _i = 0, _a = successors[s]; _i < _a.length; _i++) {
            var v = _a[_i];
            predecessors[v].push(s);
        }
    }
    return predecessors;
}
function calculateInDegrees(successors) {
    var numNodes = successors.length;
    var inDegrees = Support_1.repeated(numNodes, 0);
    for (var _i = 0, successors_1 = successors; _i < successors_1.length; _i++) {
        var s = successors_1[_i];
        for (var _a = 0, s_1 = s; _a < s_1.length; _a++) {
            var v = s_1[_a];
            inDegrees[v] += 1;
        }
    }
    return inDegrees;
}
function findRoots(successors) {
    var numNodes = successors.length;
    var inDegrees = calculateInDegrees(successors);
    var roots = [];
    for (var v = 0; v < numNodes; v++) {
        if (inDegrees[v] === 0) {
            roots.push(v);
        }
    }
    return roots;
}
var Graph = /** @class */ (function () {
    function Graph(_nodes, invertDirection, edges) {
        var _this = this;
        this._nodes = _nodes;
        this._indexByNode = immutable_1.Map(_nodes.map(function (n, i) { return [n, i]; }));
        var edgesArray;
        if (Array.isArray(edges)) {
            edgesArray = edges;
        }
        else {
            edgesArray = _nodes.map(function (n) {
                return edges(n)
                    .toArray()
                    .map(function (s) { return Support_1.defined(_this._indexByNode.get(s)); });
            });
        }
        if (invertDirection) {
            edgesArray = invertEdges(edgesArray);
        }
        this._successors = edgesArray;
    }
    Object.defineProperty(Graph.prototype, "size", {
        get: function () {
            return this._nodes.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graph.prototype, "nodes", {
        get: function () {
            return immutable_1.List(this._nodes);
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.findRoots = function () {
        var _this = this;
        var roots = findRoots(this._successors);
        return immutable_1.OrderedSet(roots.map(function (n) { return _this._nodes[n]; }));
    };
    // The subgraph starting at `root` must be acyclic.
    Graph.prototype.dfsTraversal = function (root, preOrder, process) {
        var _this = this;
        var visited = Support_1.repeated(this.size, false);
        var visit = function (v) {
            if (visited[v])
                return;
            visited[v] = true;
            if (preOrder) {
                process(_this._nodes[v]);
            }
            for (var _i = 0, _a = _this._successors[v]; _i < _a.length; _i++) {
                var w = _a[_i];
                visit(w);
            }
            if (!preOrder) {
                process(_this._nodes[v]);
            }
        };
        visit(Support_1.defined(this._indexByNode.get(root)));
    };
    Graph.prototype.stronglyConnectedComponents = function () {
        var _this = this;
        var components = stronglyConnectedComponents(this._successors);
        var componentSuccessors = buildMetaSuccessors(this._successors, components);
        return new Graph(components.map(function (ns) { return immutable_1.OrderedSet(ns.map(function (n) { return _this._nodes[n]; })); }), false, componentSuccessors);
    };
    Graph.prototype.makeDot = function (includeNode, nodeLabel) {
        var lines = [];
        lines.push("digraph G {");
        lines.push("    ordering = out;");
        lines.push("");
        for (var i = 0; i < this.size; i++) {
            var n = this._nodes[i];
            if (!includeNode(n))
                continue;
            lines.push("    node" + i + " [label=\"" + nodeLabel(n) + "\"];");
        }
        for (var i = 0; i < this.size; i++) {
            if (!includeNode(this._nodes[i]))
                continue;
            for (var _i = 0, _a = this._successors[i]; _i < _a.length; _i++) {
                var j = _a[_i];
                if (!includeNode(this._nodes[j]))
                    continue;
                lines.push("    node" + i + " -> node" + j + ";");
            }
        }
        lines.push("}");
        lines.push("");
        return lines.join("\n");
    };
    return Graph;
}());
exports.Graph = Graph;
