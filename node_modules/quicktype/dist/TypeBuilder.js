"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("./Type");
var TypeUtils_1 = require("./TypeUtils");
var TypeGraph_1 = require("./TypeGraph");
var TypeAttributes_1 = require("./TypeAttributes");
var Support_1 = require("./Support");
var StringTypes_1 = require("./StringTypes");
var TypeRef = /** @class */ (function () {
    function TypeRef(graph, index) {
        this.graph = graph;
        this.index = index;
    }
    TypeRef.prototype.deref = function () {
        return this.graph.atIndex(this.index);
    };
    TypeRef.prototype.equals = function (other) {
        if (!(other instanceof TypeRef)) {
            return false;
        }
        Support_1.assert(this.graph === other.graph, "Comparing type refs of different graphs");
        return this.index === other.index;
    };
    TypeRef.prototype.hashCode = function () {
        return this.index | 0;
    };
    return TypeRef;
}());
exports.TypeRef = TypeRef;
// FIXME: Don't infer provenance.  All original types should be present in
// non-inferred form in the final graph.
var ProvenanceTypeAttributeKind = /** @class */ (function (_super) {
    __extends(ProvenanceTypeAttributeKind, _super);
    function ProvenanceTypeAttributeKind() {
        return _super.call(this, "provenance") || this;
    }
    ProvenanceTypeAttributeKind.prototype.combine = function (a, b) {
        return a.union(b);
    };
    ProvenanceTypeAttributeKind.prototype.makeInferred = function (p) {
        return p;
    };
    ProvenanceTypeAttributeKind.prototype.stringify = function (p) {
        return p
            .map(function (r) { return r.index; })
            .toList()
            .sort()
            .map(function (i) { return i.toString(); })
            .join(",");
    };
    return ProvenanceTypeAttributeKind;
}(TypeAttributes_1.TypeAttributeKind));
exports.provenanceTypeAttributeKind = new ProvenanceTypeAttributeKind();
exports.NoStringTypeMapping = {
    date: "date",
    time: "time",
    dateTime: "date-time"
};
var TypeBuilder = /** @class */ (function () {
    function TypeBuilder(_stringTypeMapping, canonicalOrder, _allPropertiesOptional, _addProvenanceAttributes, inheritsProvenanceAttributes) {
        var _this = this;
        this._stringTypeMapping = _stringTypeMapping;
        this.canonicalOrder = canonicalOrder;
        this._allPropertiesOptional = _allPropertiesOptional;
        this._addProvenanceAttributes = _addProvenanceAttributes;
        this.topLevels = immutable_1.Map();
        this.types = [];
        this.typeAttributes = [];
        this._addedForwardingIntersection = false;
        this.commitType = function (tref, t) {
            var index = tref.index;
            // const name = names !== undefined ? ` ${names.combinedName}` : "";
            // console.log(`committing ${t.kind}${name} to ${index}`);
            Support_1.assert(_this.types[index] === undefined, "A type index was committed twice");
            _this.types[index] = t;
        };
        // FIXME: make mutable?
        this._typeForIdentity = immutable_1.Map();
        Support_1.assert(!_addProvenanceAttributes || !inheritsProvenanceAttributes, "We can't both inherit as well as add provenance");
        this.typeGraph = new TypeGraph_1.TypeGraph(this, _addProvenanceAttributes || inheritsProvenanceAttributes);
    }
    TypeBuilder.prototype.addTopLevel = function (name, tref) {
        // assert(t.typeGraph === this.typeGraph, "Adding top-level to wrong type graph");
        Support_1.assert(!this.topLevels.has(name), "Trying to add top-level with existing name");
        Support_1.assert(this.types[tref.index] !== undefined, "Trying to add a top-level type that doesn't exist (yet?)");
        this.topLevels = this.topLevels.set(name, tref);
    };
    TypeBuilder.prototype.reserveTypeRef = function () {
        var index = this.types.length;
        // console.log(`reserving ${index}`);
        this.types.push(undefined);
        var tref = new TypeRef(this.typeGraph, index);
        var attributes = this._addProvenanceAttributes
            ? exports.provenanceTypeAttributeKind.makeAttributes(immutable_1.Set([tref]))
            : TypeAttributes_1.emptyTypeAttributes;
        this.typeAttributes.push(attributes);
        return tref;
    };
    TypeBuilder.prototype.addType = function (forwardingRef, creator, attributes) {
        if (forwardingRef !== undefined) {
            Support_1.assert(this.types[forwardingRef.index] === undefined);
        }
        var tref = forwardingRef !== undefined ? forwardingRef : this.reserveTypeRef();
        if (attributes !== undefined) {
            var index = tref.index;
            this.typeAttributes[index] = TypeAttributes_1.combineTypeAttributes("union", this.typeAttributes[index], attributes);
        }
        var t = creator(tref);
        this.commitType(tref, t);
        return tref;
    };
    TypeBuilder.prototype.atIndex = function (index) {
        var maybeType = this.types[index];
        if (maybeType === undefined) {
            return Support_1.panic("Trying to deref an undefined type in a type builder");
        }
        var maybeNames = this.typeAttributes[index];
        return [maybeType, maybeNames];
    };
    TypeBuilder.prototype.addAttributes = function (tref, attributes) {
        var index = tref.index;
        var existingAttributes = this.typeAttributes[index];
        Support_1.assert(attributes.every(function (v, k) {
            if (!k.inIdentity)
                return true;
            var existing = existingAttributes.get(k);
            if (existing === undefined)
                return false;
            return immutable_1.is(existing, v);
        }), "Can't add different identity type attributes to an existing type");
        var nonIdentityAttributes = attributes.filterNot(function (_, k) { return k.inIdentity; });
        this.typeAttributes[index] = TypeAttributes_1.combineTypeAttributes("union", existingAttributes, nonIdentityAttributes);
    };
    TypeBuilder.prototype.makeNullable = function (tref, attributes) {
        var t = Support_1.defined(this.types[tref.index]);
        if (t.kind === "null" || t.kind === "any") {
            return tref;
        }
        var nullType = this.getPrimitiveType("null");
        if (!(t instanceof Type_1.UnionType)) {
            return this.getUnionType(attributes, immutable_1.OrderedSet([tref, nullType]));
        }
        var _a = TypeUtils_1.removeNullFromUnion(t), maybeNull = _a[0], nonNulls = _a[1];
        if (maybeNull !== null)
            return tref;
        return this.getUnionType(attributes, nonNulls.map(function (nn) { return nn.typeRef; }).add(nullType));
    };
    TypeBuilder.prototype.finish = function () {
        this.typeGraph.freeze(this.topLevels, this.types.map(Support_1.defined), this.typeAttributes);
        return this.typeGraph;
    };
    TypeBuilder.prototype.addForwardingIntersection = function (forwardingRef, tref) {
        this._addedForwardingIntersection = true;
        return this.addType(forwardingRef, function (tr) { return new Type_1.IntersectionType(tr, immutable_1.OrderedSet([tref])); }, undefined);
    };
    TypeBuilder.prototype.forwardIfNecessary = function (forwardingRef, tref) {
        if (tref === undefined)
            return undefined;
        if (forwardingRef === undefined)
            return tref;
        return this.addForwardingIntersection(forwardingRef, tref);
    };
    Object.defineProperty(TypeBuilder.prototype, "didAddForwardingIntersection", {
        get: function () {
            return this._addedForwardingIntersection;
        },
        enumerable: true,
        configurable: true
    });
    TypeBuilder.prototype.registerTypeForIdentity = function (identity, tref) {
        if (identity === undefined)
            return;
        this._typeForIdentity = this._typeForIdentity.set(identity, tref);
    };
    TypeBuilder.prototype.makeIdentity = function (maker) {
        return maker();
    };
    TypeBuilder.prototype.getOrAddType = function (identityMaker, creator, attributes, forwardingRef) {
        var identity = this.makeIdentity(identityMaker);
        var maybeTypeRef;
        if (identity === undefined) {
            maybeTypeRef = undefined;
        }
        else {
            maybeTypeRef = this._typeForIdentity.get(identity);
        }
        if (maybeTypeRef !== undefined) {
            var result = this.forwardIfNecessary(forwardingRef, maybeTypeRef);
            if (attributes !== undefined) {
                // We only add the attributes that are not in the identity, since
                // we found the type based on its identity, i.e. all the identity
                // attributes must be in there already, and we have a check that
                // asserts that no identity attributes are added later.
                this.addAttributes(result, attributes.filter(function (_, k) { return !k.inIdentity; }));
            }
            return result;
        }
        var tref = this.addType(forwardingRef, creator, attributes);
        this.registerTypeForIdentity(identity, tref);
        return tref;
    };
    TypeBuilder.prototype.registerType = function (t) {
        this.registerTypeForIdentity(t.identity, t.typeRef);
    };
    TypeBuilder.prototype.getPrimitiveType = function (kind, maybeAttributes, forwardingRef) {
        var attributes = Support_1.withDefault(maybeAttributes, TypeAttributes_1.emptyTypeAttributes);
        // FIXME: Why do date/time types need a StringTypes attribute?
        // FIXME: Remove this from here and put it into flattenStrings
        var stringTypes = kind === "string" ? undefined : StringTypes_1.StringTypes.unrestricted;
        if (kind === "date")
            kind = this._stringTypeMapping.date;
        if (kind === "time")
            kind = this._stringTypeMapping.time;
        if (kind === "date-time")
            kind = this._stringTypeMapping.dateTime;
        if (kind === "string") {
            return this.getStringType(attributes, stringTypes, forwardingRef);
        }
        return this.getOrAddType(function () { return Type_1.primitiveTypeIdentity(kind, attributes); }, function (tr) { return new Type_1.PrimitiveType(tr, kind); }, attributes, forwardingRef);
    };
    TypeBuilder.prototype.getStringType = function (attributes, stringTypes, forwardingRef) {
        var existingStringTypes = attributes.find(function (_, k) { return k === StringTypes_1.stringTypesTypeAttributeKind; });
        Support_1.assert((stringTypes === undefined) !== (existingStringTypes === undefined), "Must instantiate string type with one enum case attribute");
        if (existingStringTypes === undefined) {
            attributes = TypeAttributes_1.combineTypeAttributes("union", attributes, StringTypes_1.stringTypesTypeAttributeKind.makeAttributes(Support_1.defined(stringTypes)));
        }
        return this.getOrAddType(function () { return Type_1.primitiveTypeIdentity("string", attributes); }, function (tr) { return new Type_1.PrimitiveType(tr, "string"); }, attributes, forwardingRef);
    };
    TypeBuilder.prototype.getEnumType = function (attributes, cases, forwardingRef) {
        return this.getOrAddType(function () { return Type_1.enumTypeIdentity(attributes, cases); }, function (tr) { return new Type_1.EnumType(tr, cases); }, attributes, forwardingRef);
    };
    TypeBuilder.prototype.getUniqueObjectType = function (attributes, properties, additionalProperties, forwardingRef) {
        var _this = this;
        properties = Support_1.mapOptional(function (p) { return _this.modifyPropertiesIfNecessary(p); }, properties);
        return this.addType(forwardingRef, function (tref) { return new Type_1.ObjectType(tref, "object", true, properties, additionalProperties); }, attributes);
    };
    TypeBuilder.prototype.getUniqueMapType = function (forwardingRef) {
        return this.addType(forwardingRef, function (tr) { return new Type_1.MapType(tr, undefined); }, undefined);
    };
    TypeBuilder.prototype.getMapType = function (attributes, values, forwardingRef) {
        return this.getOrAddType(function () { return Type_1.mapTypeIdentify(attributes, values); }, function (tr) { return new Type_1.MapType(tr, values); }, attributes, forwardingRef);
    };
    TypeBuilder.prototype.setObjectProperties = function (ref, properties, additionalProperties) {
        var type = ref.deref()[0];
        if (!(type instanceof Type_1.ObjectType)) {
            return Support_1.panic("Tried to set properties of non-object type");
        }
        type.setProperties(this.modifyPropertiesIfNecessary(properties), additionalProperties);
        this.registerType(type);
    };
    TypeBuilder.prototype.getUniqueArrayType = function (forwardingRef) {
        return this.addType(forwardingRef, function (tr) { return new Type_1.ArrayType(tr, undefined); }, undefined);
    };
    TypeBuilder.prototype.getArrayType = function (items, forwardingRef) {
        return this.getOrAddType(function () { return Type_1.arrayTypeIdentity(TypeAttributes_1.emptyTypeAttributes, items); }, function (tr) { return new Type_1.ArrayType(tr, items); }, undefined, forwardingRef);
    };
    TypeBuilder.prototype.setArrayItems = function (ref, items) {
        var type = ref.deref()[0];
        if (!(type instanceof Type_1.ArrayType)) {
            return Support_1.panic("Tried to set items of non-array type");
        }
        type.setItems(items);
        this.registerType(type);
    };
    TypeBuilder.prototype.modifyPropertiesIfNecessary = function (properties) {
        if (this.canonicalOrder) {
            properties = properties.sortBy(function (_, n) { return n; });
        }
        if (this._allPropertiesOptional) {
            properties = properties.map(function (cp) { return new Type_1.ClassProperty(cp.typeRef, true); });
        }
        return properties;
    };
    TypeBuilder.prototype.getClassType = function (attributes, properties, forwardingRef) {
        properties = this.modifyPropertiesIfNecessary(properties);
        return this.getOrAddType(function () { return Type_1.classTypeIdentity(attributes, properties); }, function (tr) { return new Type_1.ClassType(tr, false, properties); }, attributes, forwardingRef);
    };
    // FIXME: Maybe just distinguish between this and `getClassType`
    // via a flag?  That would make `ClassType.map` simpler.
    TypeBuilder.prototype.getUniqueClassType = function (attributes, isFixed, properties, forwardingRef) {
        var _this = this;
        properties = Support_1.mapOptional(function (p) { return _this.modifyPropertiesIfNecessary(p); }, properties);
        return this.addType(forwardingRef, function (tref) { return new Type_1.ClassType(tref, isFixed, properties); }, attributes);
    };
    TypeBuilder.prototype.getUnionType = function (attributes, members, forwardingRef) {
        return this.getOrAddType(function () { return Type_1.unionTypeIdentity(attributes, members); }, function (tr) { return new Type_1.UnionType(tr, members); }, attributes, forwardingRef);
    };
    // FIXME: why do we sometimes call this with defined members???
    TypeBuilder.prototype.getUniqueUnionType = function (attributes, members, forwardingRef) {
        return this.addType(forwardingRef, function (tref) { return new Type_1.UnionType(tref, members); }, attributes);
    };
    TypeBuilder.prototype.getIntersectionType = function (attributes, members, forwardingRef) {
        return this.getOrAddType(function () { return Type_1.intersectionTypeIdentity(attributes, members); }, function (tr) { return new Type_1.IntersectionType(tr, members); }, attributes, forwardingRef);
    };
    // FIXME: why do we sometimes call this with defined members???
    TypeBuilder.prototype.getUniqueIntersectionType = function (attributes, members, forwardingRef) {
        return this.addType(forwardingRef, function (tref) { return new Type_1.IntersectionType(tref, members); }, attributes);
    };
    TypeBuilder.prototype.setSetOperationMembers = function (ref, members) {
        var type = ref.deref()[0];
        if (!(type instanceof Type_1.UnionType || type instanceof Type_1.IntersectionType)) {
            return Support_1.panic("Tried to set members of non-set-operation type");
        }
        type.setMembers(members);
        this.registerType(type);
    };
    TypeBuilder.prototype.setLostTypeAttributes = function () {
        return;
    };
    return TypeBuilder;
}());
exports.TypeBuilder = TypeBuilder;
