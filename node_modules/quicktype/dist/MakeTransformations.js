"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("./Type");
var Support_1 = require("./Support");
var Transformers_1 = require("./Transformers");
var TypeAttributes_1 = require("./TypeAttributes");
var StringTypes_1 = require("./StringTypes");
function transformationAttributes(reconstitutedTargetType, transformer, debugPrintTransformation) {
    var transformation = new Transformers_1.Transformation(reconstitutedTargetType, transformer);
    if (debugPrintTransformation) {
        console.log("transformation for " + reconstitutedTargetType.index + ":");
        transformation.debugPrint();
    }
    return Transformers_1.transformationTypeAttributeKind.makeAttributes(transformation);
}
function makeEnumTransformer(enumType, stringType, continuation) {
    var sortedCases = enumType.cases.toList().sort();
    var caseTransformers = sortedCases.map(function (c) { return new Transformers_1.StringMatchTransformer(stringType, new Transformers_1.StringProducerTransformer(stringType, continuation, c), c); });
    return new Transformers_1.ChoiceTransformer(stringType, caseTransformers);
}
function replaceUnion(union, builder, forwardingRef, debugPrintTransformations) {
    Support_1.assert(!union.members.isEmpty(), "We can't have empty unions");
    var reconstitutedMembersByKind = union.members
        .toOrderedMap()
        .mapKeys(function (m) { return m.kind; })
        .map(function (m) { return builder.reconstituteType(m); });
    var reconstitutedUnion = builder.getUnionType(union.getAttributes(), reconstitutedMembersByKind.toOrderedSet());
    function memberForKind(kind) {
        return Support_1.defined(reconstitutedMembersByKind.get(kind));
    }
    function transformerForKind(kind) {
        var member = union.findMember(kind);
        if (member === undefined)
            return undefined;
        var memberTypeRef = Support_1.defined(reconstitutedMembersByKind.get(kind));
        return new Transformers_1.UnionInstantiationTransformer(memberTypeRef);
    }
    var maybeStringType = undefined;
    function getStringType() {
        if (maybeStringType === undefined) {
            maybeStringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
        }
        return maybeStringType;
    }
    function transformerForStringType(t) {
        var memberRef = memberForKind(t.kind);
        switch (t.kind) {
            case "string":
                return Support_1.defined(transformerForKind(t.kind));
            case "date-time":
                return new Transformers_1.ParseDateTimeTransformer(getStringType(), new Transformers_1.UnionInstantiationTransformer(memberRef));
            case "enum": {
                var enumType = t;
                return makeEnumTransformer(enumType, getStringType(), new Transformers_1.UnionInstantiationTransformer(memberRef));
            }
            default:
                return Support_1.panic("Can't transform string type " + t.kind);
        }
    }
    var stringTypes = union.stringTypeMembers;
    var transformerForString;
    if (stringTypes.isEmpty()) {
        transformerForString = undefined;
    }
    else if (stringTypes.size === 1) {
        var t = Support_1.defined(stringTypes.first());
        transformerForString = new Transformers_1.UnionInstantiationTransformer(memberForKind(t.kind));
    }
    else {
        transformerForString = new Transformers_1.ChoiceTransformer(getStringType(), stringTypes.toList().map(transformerForStringType));
    }
    var transformerForClass = transformerForKind("class");
    var transformerForMap = transformerForKind("map");
    Support_1.assert(transformerForClass === undefined || transformerForMap === undefined, "Can't have both class and map in a transformed union");
    var transformerForObject = transformerForClass !== undefined ? transformerForClass : transformerForMap;
    var transformer = new Transformers_1.DecodingChoiceTransformer(builder.getPrimitiveType("any"), transformerForKind("null"), transformerForKind("integer"), transformerForKind("double"), transformerForKind("bool"), transformerForString, transformerForKind("array"), transformerForObject);
    var attributes = transformationAttributes(reconstitutedUnion, transformer, debugPrintTransformations);
    return builder.getPrimitiveType("any", attributes, forwardingRef);
}
function replaceEnum(enumType, builder, forwardingRef, debugPrintTransformations) {
    var stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
    var transformer = new Transformers_1.DecodingTransformer(stringType, makeEnumTransformer(enumType, stringType));
    var reconstitutedEnum = builder.getEnumType(enumType.getAttributes(), enumType.cases);
    var attributes = transformationAttributes(reconstitutedEnum, transformer, debugPrintTransformations);
    return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
}
function makeTransformations(graph, stringTypeMapping, targetLanguage, debugPrintTransformations, debugPrintReconstitution) {
    function replace(setOfOneUnion, builder, forwardingRef) {
        var t = Support_1.defined(setOfOneUnion.first());
        if (t instanceof Type_1.UnionType) {
            return replaceUnion(t, builder, forwardingRef, debugPrintTransformations);
        }
        if (t instanceof Type_1.EnumType) {
            return replaceEnum(t, builder, forwardingRef, debugPrintTransformations);
        }
        return Support_1.panic("Cannot make transformation for type " + t.kind);
    }
    var allTypesUnordered = graph.allTypesUnordered();
    var unions = allTypesUnordered.filter(function (t) { return t instanceof Type_1.UnionType && targetLanguage.needsTransformerForUnion(t); });
    var enums = targetLanguage.needsTransformerForEnums
        ? allTypesUnordered.filter(function (t) { return t instanceof Type_1.EnumType; })
        : immutable_1.Set();
    var groups = unions
        .union(enums)
        .toArray()
        .map(function (t) { return [t]; });
    return graph.rewrite("make-transformations", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
}
exports.makeTransformations = makeTransformations;
