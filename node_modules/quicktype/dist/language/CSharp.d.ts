import { OrderedSet } from "immutable";
import { Type, UnionType, ClassType, ClassProperty } from "../Type";
import { TypeGraph } from "../TypeGraph";
import { Sourcelike } from "../Source";
import { StringMap } from "../Support";
import { Name, DependencyName, Namer } from "../Naming";
import { ConvenienceRenderer, ForbiddenWordsInfo } from "../ConvenienceRenderer";
import { TargetLanguage } from "../TargetLanguage";
import { Option } from "../RendererOptions";
import { StringTypeMapping } from "../TypeBuilder";
export declare type Version = 5 | 6;
export declare type OutputFeatures = {
    helpers: boolean;
    attributes: boolean;
};
export declare enum AccessModifier {
    None = 0,
    Public = 1,
    Internal = 2,
}
export declare type CSharpTypeForAny = "object" | "dynamic";
export default class CSharpTargetLanguage extends TargetLanguage {
    private readonly _listOption;
    private readonly _denseOption;
    private readonly _featuresOption;
    private readonly _namespaceOption;
    private readonly _versionOption;
    private readonly _checkRequiredOption;
    private readonly _typeForAnyOption;
    private readonly _useDecimalOption;
    constructor();
    protected getOptions(): Option<any>[];
    protected readonly partialStringTypeMapping: Partial<StringTypeMapping>;
    readonly supportsUnionsWithBothNumberTypes: boolean;
    readonly supportsOptionalClassProperties: boolean;
    needsTransformerForUnion(u: UnionType): boolean;
    readonly needsTransformerForEnums: boolean;
    protected readonly rendererClass: new (targetLanguage: TargetLanguage, graph: TypeGraph, leadingComments: string[] | undefined, ...optionValues: any[]) => ConvenienceRenderer;
}
export declare class CSharpRenderer extends ConvenienceRenderer {
    protected readonly namespaceName: string;
    private readonly _version;
    protected readonly dense: boolean;
    private readonly _useList;
    private readonly _useDecimal;
    private readonly _typeForAny;
    constructor(targetLanguage: TargetLanguage, graph: TypeGraph, leadingComments: string[] | undefined, namespaceName: string, _version: Version, dense: boolean, _useList: boolean, _useDecimal: boolean, _typeForAny: CSharpTypeForAny);
    protected forbiddenNamesForGlobalNamespace(): string[];
    protected forbiddenForObjectProperties(_: ClassType, classNamed: Name): ForbiddenWordsInfo;
    protected forbiddenForUnionMembers(_: UnionType, unionNamed: Name): ForbiddenWordsInfo;
    protected makeNamedTypeNamer(): Namer;
    protected namerForObjectProperty(): Namer;
    protected makeUnionMemberNamer(): Namer;
    protected makeEnumCaseNamer(): Namer;
    protected unionNeedsName(u: UnionType): boolean;
    protected namedTypeToNameForTopLevel(type: Type): Type | undefined;
    protected emitBlock(f: () => void, semicolon?: boolean): void;
    protected readonly doubleType: string;
    protected csType(t: Type, follow?: (t: Type) => Type, withIssues?: boolean): Sourcelike;
    protected nullableCSType(t: Type, withIssues?: boolean): Sourcelike;
    protected superclassForType(_t: Type): Sourcelike | undefined;
    protected emitType(description: string[] | undefined, accessModifier: AccessModifier, declaration: Sourcelike, name: Sourcelike, superclass: Sourcelike | undefined, emitter: () => void): void;
    protected attributesForProperty(_property: ClassProperty, _jsonName: string): Sourcelike[] | undefined;
    protected emitDescriptionBlock(lines: string[]): void;
    protected blankLinesBetweenAttributes(): boolean;
    private emitClassDefinition(c, className);
    private emitUnionDefinition(u, unionName);
    private emitEnumDefinition(e, enumName);
    protected emitExpressionMember(declare: Sourcelike, define: Sourcelike, isProperty?: boolean): void;
    protected emitTypeSwitch<T extends Sourcelike>(types: OrderedSet<T>, condition: (t: T) => Sourcelike, withBlock: boolean, withReturn: boolean, f: (t: T) => void): void;
    protected emitUsing(ns: Sourcelike): void;
    protected emitUsings(): void;
    protected emitRequiredHelpers(): void;
    private emitTypesAndSupport();
    protected emitDefaultLeadingComments(): void;
    protected needNamespace(): boolean;
    protected emitSourceStructure(): void;
    protected registerHandlebarsHelpers(context: StringMap): void;
    protected makeHandlebarsContextForType(t: Type): StringMap;
    protected makeHandlebarsContextForUnionMember(t: Type, name: Name): StringMap;
}
export declare class NewtonsoftCSharpRenderer extends CSharpRenderer {
    private readonly _checkRequiredProperties;
    private _enumExtensionsNames;
    private readonly _needHelpers;
    private readonly _needAttributes;
    constructor(targetLanguage: TargetLanguage, graph: TypeGraph, leadingComments: string[] | undefined, namespaceName: string, version: Version, dense: boolean, useList: boolean, useDecimal: boolean, outputFeatures: OutputFeatures, _checkRequiredProperties: boolean, typeForAny: CSharpTypeForAny);
    protected forbiddenNamesForGlobalNamespace(): string[];
    protected forbiddenForObjectProperties(c: ClassType, className: Name): ForbiddenWordsInfo;
    protected makeNameForTransformation(_t: Type, typeName: Name | undefined): Name;
    protected makeNamedTypeDependencyNames(t: Type, name: Name): DependencyName[];
    protected emitUsings(): void;
    protected emitDefaultLeadingComments(): void;
    private converterForType(_t);
    protected attributesForProperty(property: ClassProperty, jsonName: string): Sourcelike[] | undefined;
    protected blankLinesBetweenAttributes(): boolean;
    private topLevelResultType(t);
    private emitFromJsonForTopLevel(t, name);
    private emitDecoderSwitch(emitBody);
    private emitTokenCase(tokenType);
    private emitThrow(message);
    private deserializeTypeCode(typeName);
    private serializeValueCode(value);
    private emitSerializeClass();
    private emitCanConvert(expr);
    private emitReadJson(emitBody);
    private emitWriteJson(variable, emitBody);
    private emitConverterClass();
    private emitDecoderTransformerCase(tokenCases, varName, xfer, targetType);
    private emitConsume(value, consumer, targetType);
    private emitDecodeTransformer(xfer, targetType);
    private stringCaseValue(t, stringCase);
    private emitTransformer(variable, xfer, targetType);
    private emitTransformation(converterName, t);
    protected emitRequiredHelpers(): void;
    protected needNamespace(): boolean;
    protected makeHandlebarsContextForType(t: Type): StringMap;
}
