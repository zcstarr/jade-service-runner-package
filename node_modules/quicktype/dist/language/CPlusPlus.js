"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var TargetLanguage_1 = require("../TargetLanguage");
var Type_1 = require("../Type");
var TypeUtils_1 = require("../TypeUtils");
var Naming_1 = require("../Naming");
var Source_1 = require("../Source");
var Annotation_1 = require("../Annotation");
var Strings_1 = require("../Strings");
var Support_1 = require("../Support");
var ConvenienceRenderer_1 = require("../ConvenienceRenderer");
var RendererOptions_1 = require("../RendererOptions");
var Support_2 = require("../Support");
var pascalValue = ["pascal-case", "pascal"];
var underscoreValue = ["underscore-case", "underscore"];
var camelValue = ["camel-case", "camel"];
var upperUnderscoreValue = ["upper-underscore-case", "upper-underscore"];
var CPlusPlusTargetLanguage = /** @class */ (function (_super) {
    __extends(CPlusPlusTargetLanguage, _super);
    function CPlusPlusTargetLanguage() {
        var _this = _super.call(this, "C++", ["c++", "cpp", "cplusplus"], "cpp") || this;
        _this._justTypesOption = new RendererOptions_1.BooleanOption("just-types", "Plain types only", false);
        _this._namespaceOption = new RendererOptions_1.StringOption("namespace", "Name of the generated namespace(s)", "NAME", "quicktype");
        _this._typeNamingStyleOption = new RendererOptions_1.EnumOption("type-style", "Naming style for types", [
            pascalValue,
            underscoreValue,
            camelValue,
            upperUnderscoreValue
        ]);
        _this._memberNamingStyleOption = new RendererOptions_1.EnumOption("member-style", "Naming style for members", [underscoreValue, pascalValue, camelValue, upperUnderscoreValue]);
        _this._enumeratorNamingStyleOption = new RendererOptions_1.EnumOption("enumerator-style", "Naming style for enumerators", [upperUnderscoreValue, underscoreValue, pascalValue, camelValue]);
        return _this;
    }
    CPlusPlusTargetLanguage.prototype.getOptions = function () {
        return [
            this._justTypesOption,
            this._namespaceOption,
            this._typeNamingStyleOption,
            this._memberNamingStyleOption,
            this._enumeratorNamingStyleOption
        ];
    };
    Object.defineProperty(CPlusPlusTargetLanguage.prototype, "supportsUnionsWithBothNumberTypes", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CPlusPlusTargetLanguage.prototype, "rendererClass", {
        get: function () {
            return CPlusPlusRenderer;
        },
        enumerable: true,
        configurable: true
    });
    return CPlusPlusTargetLanguage;
}(TargetLanguage_1.TargetLanguage));
exports.default = CPlusPlusTargetLanguage;
var legalizeName = Strings_1.legalizeCharacters(function (cp) { return Strings_1.isAscii(cp) && Strings_1.isLetterOrUnderscoreOrDigit(cp); });
function cppNameStyle(namingStyle) {
    var separator;
    var firstWordStyle;
    var restWordStyle;
    var firstWordAcronymStyle;
    var restAcronymStyle;
    if (namingStyle === "pascal" || namingStyle === "camel") {
        separator = "";
        restWordStyle = Strings_1.firstUpperWordStyle;
        restAcronymStyle = Strings_1.allUpperWordStyle;
    }
    else {
        separator = "_";
    }
    switch (namingStyle) {
        case "pascal":
            firstWordStyle = firstWordAcronymStyle = Strings_1.firstUpperWordStyle;
            break;
        case "camel":
            firstWordStyle = firstWordAcronymStyle = Strings_1.allLowerWordStyle;
            break;
        case "underscore":
            firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = Strings_1.allLowerWordStyle;
            break;
        case "upper-underscore":
            firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = Strings_1.allUpperWordStyle;
            break;
        default:
            return Support_1.assertNever(namingStyle);
    }
    return function (original) {
        var words = Strings_1.splitIntoWords(original);
        return Strings_1.combineWords(words, legalizeName, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, Strings_1.isLetterOrUnderscore);
    };
}
var keywords = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "char16_t",
    "char32_t",
    "class",
    "compl",
    "concept",
    "const",
    "constexpr",
    "const_cast",
    "continue",
    "co_await",
    "co_return",
    "co_yield",
    "decltype",
    "default",
    "delete",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "int",
    "long",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "private",
    "protected",
    "public",
    "register",
    "reinterpret_cast",
    "requires",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_assert",
    "static_cast",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "unsigned",
    "using",
    "virtual",
    "void",
    "volatile",
    "wchar_t",
    "while",
    "xor",
    "xor_eq",
    "override",
    "final",
    "transaction_safe",
    "transaction_safe_dynamic",
    "NULL"
];
var optionalType = "std::unique_ptr";
var CPlusPlusRenderer = /** @class */ (function (_super) {
    __extends(CPlusPlusRenderer, _super);
    function CPlusPlusRenderer(targetLanguage, graph, leadingComments, _justTypes, namespaceName, _typeNamingStyle, _memberNamingStyle, _enumeratorNamingStyle) {
        var _this = _super.call(this, targetLanguage, graph, leadingComments) || this;
        _this._justTypes = _justTypes;
        _this.emitBlock = function (line, withSemicolon, f, withIndent) {
            if (withIndent === void 0) { withIndent = true; }
            _this.emitLine(line, " {");
            _this.preventBlankLine();
            if (withIndent) {
                _this.indent(f);
            }
            else {
                f();
            }
            _this.preventBlankLine();
            if (withSemicolon) {
                _this.emitLine("};");
            }
            else {
                _this.emitLine("}");
            }
        };
        _this.emitNamespaces = function (namespaceNames, f) {
            var first = namespaceNames.first();
            if (first === undefined) {
                f();
            }
            else {
                _this.emitBlock(["namespace ", first], false, function () { return _this.emitNamespaces(namespaceNames.rest(), f); }, namespaceNames.size === 1);
            }
        };
        _this.cppTypeInOptional = function (nonNulls, ctx, withIssues) {
            if (nonNulls.size === 1) {
                return _this.cppType(Support_1.defined(nonNulls.first()), ctx, withIssues);
            }
            var typeList = [];
            nonNulls.forEach(function (t) {
                if (typeList.length !== 0) {
                    typeList.push(", ");
                }
                typeList.push(_this.cppType(t, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: false,
                    inJsonNamespace: ctx.inJsonNamespace
                }, withIssues));
            });
            return ["boost::variant<", typeList, ">"];
        };
        _this.variantType = function (u, inJsonNamespace) {
            var _a = TypeUtils_1.removeNullFromUnion(u, true), maybeNull = _a[0], nonNulls = _a[1];
            Support_2.assert(nonNulls.size >= 2, "Variant not needed for less than two types.");
            var indirection = maybeNull !== null;
            var variant = _this.cppTypeInOptional(nonNulls, { needsForwardIndirection: !indirection, needsOptionalIndirection: !indirection, inJsonNamespace: inJsonNamespace }, true);
            if (!indirection) {
                return variant;
            }
            return [optionalType, "<", variant, ">"];
        };
        _this.ourQualifier = function (inJsonNamespace) {
            return inJsonNamespace ? [Support_1.intercalate("::", _this._namespaceNames).toArray(), "::"] : [];
        };
        _this.jsonQualifier = function (inJsonNamespace) {
            return inJsonNamespace ? [] : "nlohmann::";
        };
        _this.variantIndirection = function (needIndirection, typeSrc) {
            if (!needIndirection)
                return typeSrc;
            return ["std::unique_ptr<", typeSrc, ">"];
        };
        _this.cppType = function (t, ctx, withIssues) {
            var inJsonNamespace = ctx.inJsonNamespace;
            return TypeUtils_1.matchType(t, function (_anyType) {
                return Source_1.maybeAnnotated(withIssues, Annotation_1.anyTypeIssueAnnotation, [_this.jsonQualifier(inJsonNamespace), "json"]);
            }, function (_nullType) {
                return Source_1.maybeAnnotated(withIssues, Annotation_1.nullTypeIssueAnnotation, [_this.jsonQualifier(inJsonNamespace), "json"]);
            }, function (_boolType) { return "bool"; }, function (_integerType) { return "int64_t"; }, function (_doubleType) { return "double"; }, function (_stringType) { return "std::string"; }, function (arrayType) { return [
                "std::vector<",
                _this.cppType(arrayType.items, { needsForwardIndirection: false, needsOptionalIndirection: true, inJsonNamespace: inJsonNamespace }, withIssues),
                ">"
            ]; }, function (classType) {
                return _this.variantIndirection(ctx.needsForwardIndirection && _this.isForwardDeclaredType(classType), [
                    "struct ",
                    _this.ourQualifier(inJsonNamespace),
                    _this.nameForNamedType(classType)
                ]);
            }, function (mapType) { return [
                "std::map<std::string, ",
                _this.cppType(mapType.values, { needsForwardIndirection: false, needsOptionalIndirection: true, inJsonNamespace: inJsonNamespace }, withIssues),
                ">"
            ]; }, function (enumType) { return [_this.ourQualifier(inJsonNamespace), _this.nameForNamedType(enumType)]; }, function (unionType) {
                var nullable = TypeUtils_1.nullableFromUnion(unionType);
                if (nullable === null)
                    return [_this.ourQualifier(inJsonNamespace), _this.nameForNamedType(unionType)];
                return [
                    optionalType,
                    "<",
                    _this.cppType(nullable, { needsForwardIndirection: false, needsOptionalIndirection: false, inJsonNamespace: inJsonNamespace }, withIssues),
                    ">"
                ];
            });
        };
        _this.emitClass = function (c, className) {
            _this.emitDescription(_this.descriptionForType(c));
            _this.emitBlock(["struct ", className], true, function () {
                _this.forEachClassProperty(c, "none", function (name, jsonName, property) {
                    _this.emitDescription(_this.descriptionForClassProperty(c, jsonName));
                    _this.emitLine(_this.cppType(property.type, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: false }, true), " ", name, ";");
                });
            });
        };
        _this.emitClassFunctions = function (c, className) {
            var ourQualifier = _this.ourQualifier(true);
            _this.emitBlock(["inline void from_json(const json& _j, struct ", ourQualifier, className, "& _x)"], false, function () {
                _this.forEachClassProperty(c, "none", function (name, json, p) {
                    var t = p.type;
                    if (t instanceof Type_1.UnionType) {
                        var _a = TypeUtils_1.removeNullFromUnion(t, true), maybeNull = _a[0], nonNulls = _a[1];
                        if (maybeNull !== null) {
                            _this.emitLine("_x.", name, " = ", ourQualifier, "get_optional<", _this.cppTypeInOptional(nonNulls, {
                                needsForwardIndirection: false,
                                needsOptionalIndirection: false,
                                inJsonNamespace: true
                            }, false), '>(_j, "', Strings_1.stringEscape(json), '");');
                            return;
                        }
                    }
                    if (t.kind === "null" || t.kind === "any") {
                        _this.emitLine("_x.", name, " = ", ourQualifier, 'get_untyped(_j, "', Strings_1.stringEscape(json), '");');
                        return;
                    }
                    var cppType = _this.cppType(t, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: true }, false);
                    _this.emitLine("_x.", name, ' = _j.at("', Strings_1.stringEscape(json), '").get<', cppType, ">();");
                });
            });
            _this.ensureBlankLine();
            _this.emitBlock(["inline void to_json(json& _j, const struct ", ourQualifier, className, "& _x)"], false, function () {
                _this.emitLine("_j = json::object();");
                _this.forEachClassProperty(c, "none", function (name, json, _) {
                    _this.emitLine('_j["', Strings_1.stringEscape(json), '"] = _x.', name, ";");
                });
            });
        };
        _this.emitEnum = function (e, enumName) {
            var caseNames = [];
            _this.forEachEnumCase(e, "none", function (name) {
                if (caseNames.length > 0)
                    caseNames.push(", ");
                caseNames.push(name);
            });
            _this.emitDescription(_this.descriptionForType(e));
            _this.emitLine("enum class ", enumName, " { ", caseNames, " };");
        };
        _this.emitUnionTypedefs = function (u, unionName) {
            _this.emitLine("typedef ", _this.variantType(u, false), " ", unionName, ";");
        };
        _this.emitUnionFunctions = function (u) {
            var functionForKind = [
                ["bool", "is_boolean"],
                ["integer", "is_number_integer"],
                ["double", "is_number"],
                ["string", "is_string"],
                ["class", "is_object"],
                ["map", "is_object"],
                ["array", "is_array"],
                ["enum", "is_string"]
            ];
            var nonNulls = TypeUtils_1.removeNullFromUnion(u, true)[1];
            var variantType = _this.cppTypeInOptional(nonNulls, { needsForwardIndirection: false, needsOptionalIndirection: false, inJsonNamespace: true }, false);
            _this.emitBlock(["inline void from_json(const json& _j, ", variantType, "& _x)"], false, function () {
                var onFirst = true;
                var _loop_1 = function (kind, func) {
                    var typeForKind = nonNulls.find(function (t) { return t.kind === kind; });
                    if (typeForKind === undefined)
                        return "continue";
                    _this.emitLine(onFirst ? "if" : "else if", " (_j.", func, "())");
                    _this.indent(function () {
                        _this.emitLine("_x = _j.get<", _this.cppType(typeForKind, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: true }, false), ">();");
                    });
                    onFirst = false;
                };
                for (var _i = 0, functionForKind_1 = functionForKind; _i < functionForKind_1.length; _i++) {
                    var _a = functionForKind_1[_i], kind = _a[0], func = _a[1];
                    _loop_1(kind, func);
                }
                _this.emitLine('else throw "Could not deserialize";');
            });
            _this.ensureBlankLine();
            _this.emitBlock(["inline void to_json(json& _j, const ", variantType, "& _x)"], false, function () {
                _this.emitBlock("switch (_x.which())", false, function () {
                    var i = 0;
                    nonNulls.forEach(function (t) {
                        _this.emitLine("case ", i.toString(), ":");
                        _this.indent(function () {
                            _this.emitLine("_j = boost::get<", _this.cppType(t, {
                                needsForwardIndirection: true,
                                needsOptionalIndirection: true,
                                inJsonNamespace: true
                            }, false), ">(_x);");
                            _this.emitLine("break;");
                        });
                        i++;
                    });
                    _this.emitLine('default: throw "Input JSON does not conform to schema";');
                });
            });
        };
        _this.emitEnumFunctions = function (e, enumName) {
            var ourQualifier = _this.ourQualifier(true);
            _this.emitBlock(["inline void from_json(const json& _j, ", ourQualifier, enumName, "& _x)"], false, function () {
                var onFirst = true;
                _this.forEachEnumCase(e, "none", function (name, jsonName) {
                    var maybeElse = onFirst ? "" : "else ";
                    _this.emitLine(maybeElse, 'if (_j == "', Strings_1.stringEscape(jsonName), '") _x = ', ourQualifier, enumName, "::", name, ";");
                    onFirst = false;
                });
                _this.emitLine('else throw "Input JSON does not conform to schema";');
            });
            _this.ensureBlankLine();
            _this.emitBlock(["inline void to_json(json& _j, const ", ourQualifier, enumName, "& _x)"], false, function () {
                _this.emitBlock("switch (_x)", false, function () {
                    _this.forEachEnumCase(e, "none", function (name, jsonName) {
                        _this.emitLine("case ", ourQualifier, enumName, "::", name, ': _j = "', Strings_1.stringEscape(jsonName), '"; break;');
                    });
                    _this.emitLine('default: throw "This should not happen";');
                });
            });
        };
        _this.emitTopLevelTypedef = function (t, name) {
            _this.emitLine("typedef ", _this.cppType(t, { needsForwardIndirection: true, needsOptionalIndirection: true, inJsonNamespace: false }, true), " ", name, ";");
        };
        _this.emitAllUnionFunctions = function () {
            _this.forEachUniqueUnion("interposing", function (u) {
                return _this.sourcelikeToString(_this.cppTypeInOptional(TypeUtils_1.removeNullFromUnion(u, true)[1], { needsForwardIndirection: false, needsOptionalIndirection: false, inJsonNamespace: true }, false));
            }, _this.emitUnionFunctions);
        };
        _this.emitOptionalHelpers = function () {
            _this.emitLine("template <typename T>");
            _this.emitMultiline("struct adl_serializer<std::unique_ptr<T>> {\n    static void to_json(json& j, const std::unique_ptr<T>& opt) {\n        if (!opt)\n            j = nullptr;\n        else\n            j = *opt;\n    }\n\n    static std::unique_ptr<T> from_json(const json& j) {\n        if (j.is_null())\n            return std::unique_ptr<T>();\n        else\n            return std::unique_ptr<T>(new T(j.get<T>()));\n    }\n};");
        };
        _this.emitTypes = function () {
            if (!_this._justTypes) {
                _this.emitLine("using nlohmann::json;");
                _this.ensureBlankLine();
            }
            _this.forEachDeclaration("interposing", function (decl) { return _this.emitDeclaration(decl); });
            if (_this._justTypes)
                return;
            _this.forEachTopLevel("leading", _this.emitTopLevelTypedef, function (t) { return _this.namedTypeToNameForTopLevel(t) === undefined; });
            _this.emitMultiline("\ninline json get_untyped(const json &j, const char *property) {\n    if (j.find(property) != j.end()) {\n        return j.at(property).get<json>();\n    }\n    return json();\n}");
            if (_this.haveUnions) {
                _this.emitMultiline("\ntemplate <typename T>\ninline " + optionalType + "<T> get_optional(const json &j, const char *property) {\n    if (j.find(property) != j.end())\n        return j.at(property).get<" + optionalType + "<T>>();\n    return " + optionalType + "<T>();\n}");
            }
        };
        _this._namespaceNames = immutable_1.List(namespaceName.split("::"));
        _this._typeNameStyle = cppNameStyle(_typeNamingStyle);
        _this._typeNamingFunction = Naming_1.funPrefixNamer("types", _this._typeNameStyle);
        _this._memberNamingFunction = Naming_1.funPrefixNamer("members", cppNameStyle(_memberNamingStyle));
        _this._caseNamingFunction = Naming_1.funPrefixNamer("enumerators", cppNameStyle(_enumeratorNamingStyle));
        return _this;
    }
    CPlusPlusRenderer.prototype.forbiddenNamesForGlobalNamespace = function () {
        return keywords;
    };
    CPlusPlusRenderer.prototype.forbiddenForObjectProperties = function (_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    };
    CPlusPlusRenderer.prototype.forbiddenForEnumCases = function (_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    };
    CPlusPlusRenderer.prototype.makeNamedTypeNamer = function () {
        return this._typeNamingFunction;
    };
    CPlusPlusRenderer.prototype.namerForObjectProperty = function () {
        return this._memberNamingFunction;
    };
    CPlusPlusRenderer.prototype.makeUnionMemberNamer = function () {
        return null;
    };
    CPlusPlusRenderer.prototype.makeEnumCaseNamer = function () {
        return this._caseNamingFunction;
    };
    Object.defineProperty(CPlusPlusRenderer.prototype, "needsTypeDeclarationBeforeUse", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    CPlusPlusRenderer.prototype.canBeForwardDeclared = function (t) {
        var kind = t.kind;
        return kind === "class";
    };
    CPlusPlusRenderer.prototype.emitDescriptionBlock = function (lines) {
        this.emitCommentLines(lines, " * ", "/**", " */");
    };
    CPlusPlusRenderer.prototype.emitDeclaration = function (decl) {
        if (decl.kind === "forward") {
            this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
        }
        else if (decl.kind === "define") {
            var t = decl.type;
            var name = this.nameForNamedType(t);
            if (t instanceof Type_1.ClassType) {
                this.emitClass(t, name);
            }
            else if (t instanceof Type_1.EnumType) {
                this.emitEnum(t, name);
            }
            else if (t instanceof Type_1.UnionType) {
                this.emitUnionTypedefs(t, name);
            }
            else {
                return Support_1.panic("Cannot declare type " + t.kind);
            }
        }
        else {
            return Support_1.assertNever(decl.kind);
        }
    };
    CPlusPlusRenderer.prototype.emitSourceStructure = function () {
        var _this = this;
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else if (!this._justTypes) {
            this.emitCommentLines([
                " To parse this JSON data, first install",
                "",
                "     Boost     http://www.boost.org",
                "     json.hpp  https://github.com/nlohmann/json",
                "",
                " Then include this file, and then do",
                ""
            ]);
            this.forEachTopLevel("none", function (_, topLevelName) {
                _this.emitLine("//     ", _this.ourQualifier(false), topLevelName, " data = nlohmann::json::parse(jsonString);");
            });
        }
        this.ensureBlankLine();
        var guardName = [
            "__QUICKTYPE_",
            Support_1.intercalate("_", this.topLevels.keySeq().map(function (n) { return legalizeName(Strings_1.allUpperWordStyle(n)); })).toArray(),
            "_HPP__"
        ];
        this.emitLine("#ifndef ", guardName);
        this.emitLine("#define ", guardName);
        this.ensureBlankLine();
        var include = function (name) {
            _this.emitLine("#include " + name);
        };
        if (this.haveNamedUnions)
            include("<boost/variant.hpp>");
        if (!this._justTypes)
            include('"json.hpp"');
        this.ensureBlankLine();
        if (this._justTypes) {
            this.emitTypes();
        }
        else {
            this.emitNamespaces(this._namespaceNames, this.emitTypes);
        }
        if (!this._justTypes && this.haveNamedTypes) {
            this.ensureBlankLine();
            this.emitNamespaces(immutable_1.List(["nlohmann"]), function () {
                if (_this.haveUnions) {
                    _this.emitOptionalHelpers();
                }
                _this.forEachObject("leading-and-interposing", _this.emitClassFunctions);
                _this.forEachEnum("leading-and-interposing", _this.emitEnumFunctions);
                if (_this.haveUnions) {
                    _this.ensureBlankLine();
                    _this.emitAllUnionFunctions();
                }
            });
        }
        this.ensureBlankLine();
        this.emitLine("#endif");
    };
    return CPlusPlusRenderer;
}(ConvenienceRenderer_1.ConvenienceRenderer));
exports.CPlusPlusRenderer = CPlusPlusRenderer;
