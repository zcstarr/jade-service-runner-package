"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TargetLanguage_1 = require("../TargetLanguage");
var TypeUtils_1 = require("../TypeUtils");
var ConvenienceRenderer_1 = require("../ConvenienceRenderer");
var Naming_1 = require("../Naming");
var Strings_1 = require("../Strings");
var Support_1 = require("../Support");
var TypeAttributes_1 = require("../TypeAttributes");
var JSONSchemaTargetLanguage = /** @class */ (function (_super) {
    __extends(JSONSchemaTargetLanguage, _super);
    function JSONSchemaTargetLanguage() {
        return _super.call(this, "JSON Schema", ["schema", "json-schema"], "schema") || this;
    }
    JSONSchemaTargetLanguage.prototype.getOptions = function () {
        return [];
    };
    Object.defineProperty(JSONSchemaTargetLanguage.prototype, "partialStringTypeMapping", {
        get: function () {
            return { date: "date", time: "time", dateTime: "date-time" };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONSchemaTargetLanguage.prototype, "supportsOptionalClassProperties", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONSchemaTargetLanguage.prototype, "supportsFullObjectType", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JSONSchemaTargetLanguage.prototype, "rendererClass", {
        get: function () {
            return JSONSchemaRenderer;
        },
        enumerable: true,
        configurable: true
    });
    return JSONSchemaTargetLanguage;
}(TargetLanguage_1.TargetLanguage));
exports.default = JSONSchemaTargetLanguage;
var namingFunction = Naming_1.funPrefixNamer("namer", jsonNameStyle);
var legalizeName = Strings_1.legalizeCharacters(function (cp) { return cp >= 32 && cp < 128 && cp !== 0x2f; } /* slash */);
function jsonNameStyle(original) {
    var words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", function (_) { return true; });
}
var JSONSchemaRenderer = /** @class */ (function (_super) {
    __extends(JSONSchemaRenderer, _super);
    function JSONSchemaRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.nameForType = function (t) {
            return Support_1.defined(_this.names.get(_this.nameForNamedType(t)));
        };
        _this.makeOneOf = function (types) {
            var count = types.count();
            Support_1.assert(count > 0, "Must have at least one type for oneOf");
            if (count === 1) {
                return _this.schemaForType(Support_1.defined(types.first()));
            }
            return { oneOf: types.map(_this.schemaForType).toArray() };
        };
        _this.schemaForType = function (t) {
            var schema = TypeUtils_1.matchTypeExhaustive(t, function (_noneType) {
                return Support_1.panic("None type should have been replaced");
            }, function (_anyType) { return ({}); }, function (_nullType) { return ({ type: "null" }); }, function (_boolType) { return ({ type: "boolean" }); }, function (_integerType) { return ({ type: "integer" }); }, function (_doubleType) { return ({ type: "number" }); }, function (_stringType) { return ({ type: "string" }); }, function (arrayType) { return ({ type: "array", items: _this.schemaForType(arrayType.items) }); }, function (classType) { return _this.makeRef(classType); }, function (mapType) { return _this.definitionForObject(mapType, undefined); }, function (objectType) { return _this.makeRef(objectType); }, function (enumType) { return _this.makeRef(enumType); }, function (unionType) {
                if (_this.unionNeedsName(unionType)) {
                    return _this.makeRef(unionType);
                }
                else {
                    return _this.definitionForUnion(unionType);
                }
            }, function (_dateType) { return ({ type: "string", format: "date" }); }, function (_timeType) { return ({ type: "string", format: "time" }); }, function (_dateTimeType) { return ({ type: "string", format: "date-time" }); });
            if (schema.$ref === undefined) {
                _this.addDescription(t, schema);
            }
            return schema;
        };
        return _this;
    }
    JSONSchemaRenderer.prototype.makeNamedTypeNamer = function () {
        return namingFunction;
    };
    JSONSchemaRenderer.prototype.namerForObjectProperty = function () {
        return null;
    };
    JSONSchemaRenderer.prototype.makeUnionMemberNamer = function () {
        return null;
    };
    JSONSchemaRenderer.prototype.makeEnumCaseNamer = function () {
        return null;
    };
    JSONSchemaRenderer.prototype.makeRef = function (t) {
        return { $ref: "#/definitions/" + this.nameForType(t) };
    };
    JSONSchemaRenderer.prototype.addDescription = function (t, schema) {
        var description = this.typeGraph.attributeStore.tryGet(TypeAttributes_1.descriptionTypeAttributeKind, t);
        if (description !== undefined) {
            schema.description = description.join("\n");
        }
    };
    JSONSchemaRenderer.prototype.definitionForObject = function (o, title) {
        var _this = this;
        var properties;
        var required;
        if (o.getProperties().isEmpty()) {
            properties = undefined;
            required = undefined;
        }
        else {
            var props_1 = {};
            var req_1 = [];
            o.getProperties().forEach(function (p, name) {
                props_1[name] = _this.schemaForType(p.type);
                if (!p.isOptional) {
                    req_1.push(name);
                }
            });
            properties = props_1;
            required = req_1.sort();
        }
        var additional = o.getAdditionalProperties();
        var additionalProperties = additional !== undefined ? this.schemaForType(additional) : false;
        var schema = {
            type: "object",
            additionalProperties: additionalProperties,
            properties: properties,
            required: required,
            title: title
        };
        this.addDescription(o, schema);
        return schema;
    };
    JSONSchemaRenderer.prototype.definitionForUnion = function (u, title) {
        var oneOf = this.makeOneOf(u.sortedMembers);
        if (title !== undefined) {
            oneOf.title = title;
        }
        this.addDescription(u, oneOf);
        return oneOf;
    };
    JSONSchemaRenderer.prototype.definitionForEnum = function (e, title) {
        var schema = { type: "string", enum: e.cases.toArray(), title: title };
        this.addDescription(e, schema);
        return schema;
    };
    JSONSchemaRenderer.prototype.emitSourceStructure = function () {
        var _this = this;
        // FIXME: Find a better way to do multiple top-levels.  Maybe multiple files?
        var schema = Object.assign({ $schema: "http://json-schema.org/draft-06/schema#" }, this.makeOneOf(this.topLevels.toList()));
        var definitions = {};
        this.forEachObject("none", function (o, name) {
            var title = Support_1.defined(_this.names.get(name));
            definitions[title] = _this.definitionForObject(o, title);
        });
        this.forEachUnion("none", function (u, name) {
            if (!_this.unionNeedsName(u))
                return;
            var title = Support_1.defined(_this.names.get(name));
            definitions[title] = _this.definitionForUnion(u, title);
        });
        this.forEachEnum("none", function (e, name) {
            var title = Support_1.defined(_this.names.get(name));
            definitions[title] = _this.definitionForEnum(e, title);
        });
        schema.definitions = definitions;
        this.emitMultiline(JSON.stringify(schema, undefined, "    "));
    };
    return JSONSchemaRenderer;
}(ConvenienceRenderer_1.ConvenienceRenderer));
exports.JSONSchemaRenderer = JSONSchemaRenderer;
