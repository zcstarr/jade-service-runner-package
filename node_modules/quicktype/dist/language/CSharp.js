"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var handlebars = require("handlebars");
var Type_1 = require("../Type");
var TypeUtils_1 = require("../TypeUtils");
var Source_1 = require("../Source");
var Strings_1 = require("../Strings");
var Support_1 = require("../Support");
var Naming_1 = require("../Naming");
var ConvenienceRenderer_1 = require("../ConvenienceRenderer");
var TargetLanguage_1 = require("../TargetLanguage");
var RendererOptions_1 = require("../RendererOptions");
var Annotation_1 = require("../Annotation");
var Transformers_1 = require("../Transformers");
var unicode = require("unicode-properties");
var AccessModifier;
(function (AccessModifier) {
    AccessModifier[AccessModifier["None"] = 0] = "None";
    AccessModifier[AccessModifier["Public"] = 1] = "Public";
    AccessModifier[AccessModifier["Internal"] = 2] = "Internal";
})(AccessModifier = exports.AccessModifier || (exports.AccessModifier = {}));
function noFollow(t) {
    return t;
}
function needTransformerForUnion(u) {
    return TypeUtils_1.nullableFromUnion(u) === null;
}
var CSharpTargetLanguage = /** @class */ (function (_super) {
    __extends(CSharpTargetLanguage, _super);
    function CSharpTargetLanguage() {
        var _this = _super.call(this, "C#", ["cs", "csharp"], "cs") || this;
        _this._listOption = new RendererOptions_1.EnumOption("array-type", "Use T[] or List<T>", [
            ["array", false],
            ["list", true]
        ]);
        _this._denseOption = new RendererOptions_1.EnumOption("density", "Property density", [["normal", false], ["dense", true]], "normal", "secondary");
        _this._featuresOption = new RendererOptions_1.EnumOption("features", "Output features", [
            ["complete", { helpers: true, attributes: true }],
            ["attributes-only", { helpers: false, attributes: true }],
            ["just-types", { helpers: false, attributes: false }]
        ]);
        // FIXME: Do this via a configurable named eventually.
        _this._namespaceOption = new RendererOptions_1.StringOption("namespace", "Generated namespace", "NAME", "QuickType");
        _this._versionOption = new RendererOptions_1.EnumOption("csharp-version", "C# version", [["5", 5], ["6", 6]], "6", "secondary");
        _this._checkRequiredOption = new RendererOptions_1.BooleanOption("check-required", "Fail if required properties are missing", false);
        _this._typeForAnyOption = new RendererOptions_1.EnumOption("any-type", 'Type to use for "any"', [["object", "object"], ["dynamic", "dynamic"]], "object", "secondary");
        _this._useDecimalOption = new RendererOptions_1.EnumOption("number-type", "Type to use for numbers", [["double", false], ["decimal", true]], "double", "secondary");
        return _this;
    }
    CSharpTargetLanguage.prototype.getOptions = function () {
        return [
            this._namespaceOption,
            this._versionOption,
            this._denseOption,
            this._listOption,
            this._useDecimalOption,
            this._featuresOption,
            this._checkRequiredOption,
            this._typeForAnyOption
        ];
    };
    Object.defineProperty(CSharpTargetLanguage.prototype, "partialStringTypeMapping", {
        get: function () {
            return { date: "date-time", time: "date-time", dateTime: "date-time" };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CSharpTargetLanguage.prototype, "supportsUnionsWithBothNumberTypes", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CSharpTargetLanguage.prototype, "supportsOptionalClassProperties", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    CSharpTargetLanguage.prototype.needsTransformerForUnion = function (u) {
        return needTransformerForUnion(u);
    };
    Object.defineProperty(CSharpTargetLanguage.prototype, "needsTransformerForEnums", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CSharpTargetLanguage.prototype, "rendererClass", {
        get: function () {
            return NewtonsoftCSharpRenderer;
        },
        enumerable: true,
        configurable: true
    });
    return CSharpTargetLanguage;
}(TargetLanguage_1.TargetLanguage));
exports.default = CSharpTargetLanguage;
var namingFunction = Naming_1.funPrefixNamer("namer", csNameStyle);
// FIXME: Make a Named?
var denseJsonPropertyName = "J";
var denseRequiredEnumName = "R";
var denseNullValueHandlingEnumName = "N";
function isStartCharacter(utf16Unit) {
    if (unicode.isAlphabetic(utf16Unit)) {
        return true;
    }
    return utf16Unit === 0x5f; // underscore
}
function isPartCharacter(utf16Unit) {
    var category = unicode.getCategory(utf16Unit);
    if (["Nd", "Pc", "Mn", "Mc"].indexOf(category) >= 0) {
        return true;
    }
    return isStartCharacter(utf16Unit);
}
var legalizeName = Strings_1.utf16LegalizeCharacters(isPartCharacter);
function csNameStyle(original) {
    var words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, "", isStartCharacter);
}
function isValueType(t) {
    if (t instanceof Type_1.UnionType) {
        return TypeUtils_1.nullableFromUnion(t) === null;
    }
    return ["integer", "double", "bool", "enum", "date-time"].indexOf(t.kind) >= 0;
}
var CSharpRenderer = /** @class */ (function (_super) {
    __extends(CSharpRenderer, _super);
    function CSharpRenderer(targetLanguage, graph, leadingComments, namespaceName, _version, dense, _useList, _useDecimal, _typeForAny) {
        var _this = _super.call(this, targetLanguage, graph, leadingComments) || this;
        _this.namespaceName = namespaceName;
        _this._version = _version;
        _this.dense = dense;
        _this._useList = _useList;
        _this._useDecimal = _useDecimal;
        _this._typeForAny = _typeForAny;
        return _this;
    }
    CSharpRenderer.prototype.forbiddenNamesForGlobalNamespace = function () {
        return ["QuickType", "Type", "System", "Console", "Exception", "DateTimeOffset"];
    };
    CSharpRenderer.prototype.forbiddenForObjectProperties = function (_, classNamed) {
        return {
            names: [
                classNamed,
                "ToString",
                "GetHashCode",
                "Finalize",
                "Equals",
                "GetType",
                "MemberwiseClone",
                "ReferenceEquals"
            ],
            includeGlobalForbidden: false
        };
    };
    CSharpRenderer.prototype.forbiddenForUnionMembers = function (_, unionNamed) {
        return { names: [unionNamed], includeGlobalForbidden: true };
    };
    CSharpRenderer.prototype.makeNamedTypeNamer = function () {
        return namingFunction;
    };
    CSharpRenderer.prototype.namerForObjectProperty = function () {
        return namingFunction;
    };
    CSharpRenderer.prototype.makeUnionMemberNamer = function () {
        return namingFunction;
    };
    CSharpRenderer.prototype.makeEnumCaseNamer = function () {
        return namingFunction;
    };
    CSharpRenderer.prototype.unionNeedsName = function (u) {
        return TypeUtils_1.nullableFromUnion(u) === null;
    };
    CSharpRenderer.prototype.namedTypeToNameForTopLevel = function (type) {
        // If the top-level type doesn't contain any classes or unions
        // we have to define a class just for the `FromJson` method, in
        // emitFromJsonForTopLevel.
        return TypeUtils_1.directlyReachableSingleNamedType(type);
    };
    CSharpRenderer.prototype.emitBlock = function (f, semicolon) {
        if (semicolon === void 0) { semicolon = false; }
        this.emitLine("{");
        this.indent(f);
        this.emitLine("}", semicolon ? ";" : "");
    };
    Object.defineProperty(CSharpRenderer.prototype, "doubleType", {
        get: function () {
            return this._useDecimal ? "decimal" : "double";
        },
        enumerable: true,
        configurable: true
    });
    CSharpRenderer.prototype.csType = function (t, follow, withIssues) {
        var _this = this;
        if (follow === void 0) { follow = Transformers_1.followTargetType; }
        if (withIssues === void 0) { withIssues = false; }
        return TypeUtils_1.matchType(follow(t), function (_anyType) { return Source_1.maybeAnnotated(withIssues, Annotation_1.anyTypeIssueAnnotation, _this._typeForAny); }, function (_nullType) { return Source_1.maybeAnnotated(withIssues, Annotation_1.nullTypeIssueAnnotation, _this._typeForAny); }, function (_boolType) { return "bool"; }, function (_integerType) { return "long"; }, function (_doubleType) { return _this.doubleType; }, function (_stringType) { return "string"; }, function (arrayType) {
            var itemsType = _this.csType(arrayType.items, noFollow, withIssues);
            if (_this._useList) {
                return ["List<", itemsType, ">"];
            }
            else {
                return [itemsType, "[]"];
            }
        }, function (classType) { return _this.nameForNamedType(classType); }, function (mapType) { return ["Dictionary<string, ", _this.csType(mapType.values, noFollow, withIssues), ">"]; }, function (enumType) { return _this.nameForNamedType(enumType); }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null)
                return _this.nullableCSType(nullable);
            return _this.nameForNamedType(unionType);
        }, {
            dateTimeType: function (_) { return "DateTimeOffset"; }
        });
    };
    CSharpRenderer.prototype.nullableCSType = function (t, withIssues) {
        if (withIssues === void 0) { withIssues = false; }
        t = Transformers_1.followTargetType(t);
        var csType = this.csType(t, noFollow, withIssues);
        if (isValueType(t)) {
            return [csType, "?"];
        }
        else {
            return csType;
        }
    };
    CSharpRenderer.prototype.superclassForType = function (_t) {
        return undefined;
    };
    CSharpRenderer.prototype.emitType = function (description, accessModifier, declaration, name, superclass, emitter) {
        switch (accessModifier) {
            case AccessModifier.Public:
                declaration = ["public ", declaration];
                break;
            case AccessModifier.Internal:
                declaration = ["internal ", declaration];
                break;
            default:
                break;
        }
        this.emitDescription(description);
        if (superclass === undefined) {
            this.emitLine(declaration, " ", name);
        }
        else {
            this.emitLine(declaration, " ", name, " : ", superclass);
        }
        this.emitBlock(emitter);
    };
    CSharpRenderer.prototype.attributesForProperty = function (_property, _jsonName) {
        return undefined;
    };
    CSharpRenderer.prototype.emitDescriptionBlock = function (lines) {
        var start = "/// <summary>";
        if (this.dense) {
            this.emitLine(start, lines.join("; "), "</summary>");
        }
        else {
            this.emitCommentLines(lines, "/// ", start, "/// </summary>");
        }
    };
    CSharpRenderer.prototype.blankLinesBetweenAttributes = function () {
        return false;
    };
    CSharpRenderer.prototype.emitClassDefinition = function (c, className) {
        var _this = this;
        this.emitType(this.descriptionForType(c), AccessModifier.Public, "partial class", className, this.superclassForType(c), function () {
            if (c.getProperties().isEmpty())
                return;
            var blankLines = _this.blankLinesBetweenAttributes() ? "interposing" : "none";
            var columns = [];
            var isFirstProperty = true;
            var previousDescription = undefined;
            _this.forEachClassProperty(c, blankLines, function (name, jsonName, p) {
                var t = Transformers_1.followTargetType(p.type);
                var csType = p.isOptional ? _this.nullableCSType(t, true) : _this.csType(t, noFollow, true);
                var attributes = _this.attributesForProperty(p, jsonName);
                var description = _this.descriptionForClassProperty(c, jsonName);
                var property = ["public ", csType, " ", name, " { get; set; }"];
                if (attributes === undefined) {
                    if (
                    // Descriptions should be preceded by an empty line
                    (!isFirstProperty && description !== undefined) ||
                        // If the previous property has a description, leave an empty line
                        previousDescription !== undefined) {
                        _this.ensureBlankLine();
                    }
                    _this.emitDescription(description);
                    _this.emitLine(property);
                }
                else if (_this.dense && attributes.length > 0) {
                    var comment = description === undefined ? "" : " // " + description.join("; ");
                    columns.push([attributes, " ", property, comment]);
                }
                else {
                    _this.emitDescription(description);
                    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                        var attribute = attributes_1[_i];
                        _this.emitLine(attribute);
                    }
                    _this.emitLine(property);
                }
                isFirstProperty = false;
                previousDescription = description;
            });
            if (columns.length > 0) {
                _this.emitTable(columns);
            }
        });
    };
    CSharpRenderer.prototype.emitUnionDefinition = function (u, unionName) {
        var _this = this;
        var nonNulls = TypeUtils_1.removeNullFromUnion(u, true)[1];
        this.emitType(this.descriptionForType(u), AccessModifier.Public, "partial struct", unionName, this.superclassForType(u), function () {
            _this.forEachUnionMember(u, nonNulls, "none", null, function (fieldName, t) {
                var csType = _this.nullableCSType(t);
                _this.emitLine("public ", csType, " ", fieldName, ";");
            });
            _this.ensureBlankLine();
            var nullTests = nonNulls
                .toList()
                .map(function (t) { return [_this.nameForUnionMember(u, t), " == null"]; });
            _this.emitExpressionMember("public bool IsNull", Support_1.intercalate(" && ", nullTests).toArray(), true);
        });
    };
    CSharpRenderer.prototype.emitEnumDefinition = function (e, enumName) {
        var caseNames = [];
        this.forEachEnumCase(e, "none", function (name) {
            if (caseNames.length > 0)
                caseNames.push(", ");
            caseNames.push(name);
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("public enum ", enumName, " { ", caseNames, " };");
    };
    CSharpRenderer.prototype.emitExpressionMember = function (declare, define, isProperty) {
        var _this = this;
        if (isProperty === void 0) { isProperty = false; }
        if (this._version === 5) {
            this.emitLine(declare);
            this.emitBlock(function () {
                var stmt = ["return ", define, ";"];
                if (isProperty) {
                    _this.emitLine("get");
                    _this.emitBlock(function () { return _this.emitLine(stmt); });
                }
                else {
                    _this.emitLine(stmt);
                }
            });
        }
        else {
            this.emitLine(declare, " => ", define, ";");
        }
    };
    CSharpRenderer.prototype.emitTypeSwitch = function (types, condition, withBlock, withReturn, f) {
        var _this = this;
        Support_1.assert(!withReturn || withBlock, "Can only have return with block");
        types.forEach(function (t) {
            _this.emitLine("if (", condition(t), ")");
            if (withBlock) {
                _this.emitBlock(function () {
                    f(t);
                    if (withReturn) {
                        _this.emitLine("return;");
                    }
                });
            }
            else {
                _this.indent(function () { return f(t); });
            }
        });
    };
    CSharpRenderer.prototype.emitUsing = function (ns) {
        this.emitLine("using ", ns, ";");
    };
    CSharpRenderer.prototype.emitUsings = function () {
        for (var _i = 0, _a = ["System", "System.Collections.Generic"]; _i < _a.length; _i++) {
            var ns = _a[_i];
            this.emitUsing(ns);
        }
    };
    CSharpRenderer.prototype.emitRequiredHelpers = function () {
        return;
    };
    CSharpRenderer.prototype.emitTypesAndSupport = function () {
        var _this = this;
        this.forEachObject("leading-and-interposing", function (c, name) { return _this.emitClassDefinition(c, name); });
        this.forEachEnum("leading-and-interposing", function (e, name) { return _this.emitEnumDefinition(e, name); });
        this.forEachUnion("leading-and-interposing", function (u, name) { return _this.emitUnionDefinition(u, name); });
        this.emitRequiredHelpers();
    };
    CSharpRenderer.prototype.emitDefaultLeadingComments = function () {
        return;
    };
    CSharpRenderer.prototype.needNamespace = function () {
        return true;
    };
    CSharpRenderer.prototype.emitSourceStructure = function () {
        var _this = this;
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else {
            this.emitDefaultLeadingComments();
        }
        this.ensureBlankLine();
        if (this.needNamespace()) {
            this.emitLine("namespace ", this.namespaceName);
            this.emitBlock(function () {
                _this.emitUsings();
                _this.emitTypesAndSupport();
            });
        }
        else {
            this.emitUsings();
            this.emitTypesAndSupport();
        }
    };
    CSharpRenderer.prototype.registerHandlebarsHelpers = function (context) {
        _super.prototype.registerHandlebarsHelpers.call(this, context);
        handlebars.registerHelper("string_escape", Strings_1.utf16StringEscape);
    };
    CSharpRenderer.prototype.makeHandlebarsContextForType = function (t) {
        var ctx = _super.prototype.makeHandlebarsContextForType.call(this, t);
        ctx.csType = this.sourcelikeToString(this.csType(t));
        return ctx;
    };
    CSharpRenderer.prototype.makeHandlebarsContextForUnionMember = function (t, name) {
        var value = _super.prototype.makeHandlebarsContextForUnionMember.call(this, t, name);
        value.nullableCSType = this.sourcelikeToString(this.nullableCSType(t));
        return value;
    };
    return CSharpRenderer;
}(ConvenienceRenderer_1.ConvenienceRenderer));
exports.CSharpRenderer = CSharpRenderer;
var NewtonsoftCSharpRenderer = /** @class */ (function (_super) {
    __extends(NewtonsoftCSharpRenderer, _super);
    function NewtonsoftCSharpRenderer(targetLanguage, graph, leadingComments, namespaceName, version, dense, useList, useDecimal, outputFeatures, _checkRequiredProperties, typeForAny) {
        var _this = _super.call(this, targetLanguage, graph, leadingComments, namespaceName, version, dense, useList, useDecimal, typeForAny) || this;
        _this._checkRequiredProperties = _checkRequiredProperties;
        _this._enumExtensionsNames = immutable_1.Map();
        _this._needHelpers = outputFeatures.helpers;
        _this._needAttributes = outputFeatures.attributes;
        return _this;
    }
    NewtonsoftCSharpRenderer.prototype.forbiddenNamesForGlobalNamespace = function () {
        var forbidden = [
            "Converter",
            "JsonConverter",
            "JsonSerializer",
            "JsonWriter",
            "JsonToken",
            "Serialize",
            "Newtonsoft",
            "MetadataPropertyHandling",
            "DateParseHandling",
            "FromJson",
            "Required"
        ];
        if (this.dense) {
            forbidden.push("J", "R", "N");
        }
        return _super.prototype.forbiddenNamesForGlobalNamespace.call(this).concat(forbidden);
    };
    NewtonsoftCSharpRenderer.prototype.forbiddenForObjectProperties = function (c, className) {
        var result = _super.prototype.forbiddenForObjectProperties.call(this, c, className);
        result.names = result.names.concat(["ToJson", "FromJson", "Required"]);
        return result;
    };
    NewtonsoftCSharpRenderer.prototype.makeNameForTransformation = function (_t, typeName) {
        if (typeName === undefined) {
            return Support_1.panic("We shouldn't have a transformation for an unnamed type");
        }
        return new Naming_1.DependencyName(namingFunction, typeName.order + 30, function (lookup) { return lookup(typeName) + "_converter"; });
    };
    NewtonsoftCSharpRenderer.prototype.makeNamedTypeDependencyNames = function (t, name) {
        if (!(t instanceof Type_1.EnumType))
            return [];
        var extensionsName = new Naming_1.DependencyName(namingFunction, name.order + 30, function (lookup) { return lookup(name) + "_extensions"; });
        this._enumExtensionsNames = this._enumExtensionsNames.set(name, extensionsName);
        return [extensionsName];
    };
    NewtonsoftCSharpRenderer.prototype.emitUsings = function () {
        // FIXME: We need System.Collections.Generic whenever we have maps or use List.
        if (!this._needAttributes && !this._needHelpers)
            return;
        _super.prototype.emitUsings.call(this);
        this.ensureBlankLine();
        for (var _i = 0, _a = ["System.Globalization", "Newtonsoft.Json", "Newtonsoft.Json.Converters"]; _i < _a.length; _i++) {
            var ns = _a[_i];
            this.emitUsing(ns);
        }
        if (this.dense) {
            this.emitUsing([denseJsonPropertyName, " = Newtonsoft.Json.JsonPropertyAttribute"]);
            this.emitUsing([denseRequiredEnumName, " = Newtonsoft.Json.Required"]);
            this.emitUsing([denseNullValueHandlingEnumName, " = Newtonsoft.Json.NullValueHandling"]);
        }
    };
    NewtonsoftCSharpRenderer.prototype.emitDefaultLeadingComments = function () {
        var _this = this;
        if (!this._needHelpers)
            return;
        this.emitLine("// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do", this.topLevels.size === 1 ? "" : " one of these", ":");
        this.emitLine("//");
        this.emitLine("//    using ", this.namespaceName, ";");
        this.emitLine("//");
        this.forEachTopLevel("none", function (t, topLevelName) {
            var rhs;
            if (t instanceof Type_1.EnumType) {
                rhs = ["JsonConvert.DeserializeObject<", topLevelName, ">(jsonString)"];
            }
            else {
                rhs = [topLevelName, ".FromJson(jsonString)"];
            }
            _this.emitLine("//    var ", Source_1.modifySource(Strings_1.camelCase, topLevelName), " = ", rhs, ";");
        });
    };
    NewtonsoftCSharpRenderer.prototype.converterForType = function (_t) {
        return undefined;
    };
    NewtonsoftCSharpRenderer.prototype.attributesForProperty = function (property, jsonName) {
        if (!this._needAttributes)
            return undefined;
        var attributes = [];
        var jsonProperty = this.dense ? denseJsonPropertyName : "JsonProperty";
        var escapedName = Strings_1.utf16StringEscape(jsonName);
        var isNullable = Transformers_1.followTargetType(property.type).isNullable;
        var isOptional = property.isOptional;
        var requiredClass = this.dense ? "R" : "Required";
        var nullValueHandlingClass = this.dense ? "N" : "NullValueHandling";
        var nullValueHandling = isOptional && !isNullable ? [", NullValueHandling = ", nullValueHandlingClass, ".Ignore"] : [];
        var required;
        if (!this._checkRequiredProperties || (isOptional && isNullable)) {
            required = [nullValueHandling];
        }
        else if (isOptional && !isNullable) {
            required = [", Required = ", requiredClass, ".DisallowNull", nullValueHandling];
        }
        else if (!isOptional && isNullable) {
            required = [", Required = ", requiredClass, ".AllowNull"];
        }
        else {
            required = [", Required = ", requiredClass, ".Always", nullValueHandling];
        }
        attributes.push(["[", jsonProperty, '("', escapedName, '"', required, ")]"]);
        var converter = this.converterForType(property.type);
        if (converter !== undefined) {
            attributes.push(["[JsonConverter(typeof(", converter, "))]"]);
        }
        return attributes;
    };
    NewtonsoftCSharpRenderer.prototype.blankLinesBetweenAttributes = function () {
        return this._needAttributes && !this.dense;
    };
    // The "this" type can't be `dynamic`, so we have to force it to `object`.
    NewtonsoftCSharpRenderer.prototype.topLevelResultType = function (t) {
        return t.kind === "any" || t.kind === "none" ? "object" : this.csType(t);
    };
    NewtonsoftCSharpRenderer.prototype.emitFromJsonForTopLevel = function (t, name) {
        var _this = this;
        if (t instanceof Type_1.EnumType)
            return;
        var partial;
        var typeKind;
        var definedType = this.namedTypeToNameForTopLevel(t);
        if (definedType !== undefined) {
            partial = "partial ";
            typeKind = definedType instanceof Type_1.ClassType ? "class" : "struct";
        }
        else {
            partial = "";
            typeKind = "class";
        }
        var csType = this.topLevelResultType(t);
        this.emitType(undefined, AccessModifier.Public, [partial, typeKind], name, this.superclassForType(t), function () {
            // FIXME: Make FromJson a Named
            _this.emitExpressionMember(["public static ", csType, " FromJson(string json)"], ["JsonConvert.DeserializeObject<", csType, ">(json, ", _this.namespaceName, ".Converter.Settings)"]);
        });
    };
    NewtonsoftCSharpRenderer.prototype.emitDecoderSwitch = function (emitBody) {
        this.emitLine("switch (reader.TokenType)");
        this.emitBlock(emitBody);
    };
    NewtonsoftCSharpRenderer.prototype.emitTokenCase = function (tokenType) {
        this.emitLine("case JsonToken.", tokenType, ":");
    };
    NewtonsoftCSharpRenderer.prototype.emitThrow = function (message) {
        this.emitLine("throw new Exception(", message, ");");
    };
    NewtonsoftCSharpRenderer.prototype.deserializeTypeCode = function (typeName) {
        return ["serializer.Deserialize<", typeName, ">(reader)"];
    };
    NewtonsoftCSharpRenderer.prototype.serializeValueCode = function (value) {
        return ["serializer.Serialize(writer, ", value, ")"];
    };
    NewtonsoftCSharpRenderer.prototype.emitSerializeClass = function () {
        var _this = this;
        // FIXME: Make Serialize a Named
        this.emitType(undefined, AccessModifier.Public, "static class", "Serialize", undefined, function () {
            // Sometimes multiple top-levels will resolve to the same type, so we have to take care
            // not to emit more than one extension method for the same type.
            var seenTypes = immutable_1.Set();
            _this.forEachTopLevel("none", function (t) {
                // FIXME: Make ToJson a Named
                if (!seenTypes.has(t)) {
                    seenTypes = seenTypes.add(t);
                    _this.emitExpressionMember(["public static string ToJson(this ", _this.topLevelResultType(t), " self)"], ["JsonConvert.SerializeObject(self, ", _this.namespaceName, ".Converter.Settings)"]);
                }
            });
        });
    };
    NewtonsoftCSharpRenderer.prototype.emitCanConvert = function (expr) {
        this.emitExpressionMember("public override bool CanConvert(Type t)", expr);
    };
    NewtonsoftCSharpRenderer.prototype.emitReadJson = function (emitBody) {
        this.emitLine("public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)");
        this.emitBlock(emitBody);
    };
    NewtonsoftCSharpRenderer.prototype.emitWriteJson = function (variable, emitBody) {
        this.emitLine("public override void WriteJson(JsonWriter writer, object ", variable, ", JsonSerializer serializer)");
        this.emitBlock(emitBody);
    };
    NewtonsoftCSharpRenderer.prototype.emitConverterClass = function () {
        var _this = this;
        // FIXME: Make Converter a Named
        var converterName = ["Converter"];
        this.emitType(undefined, AccessModifier.Internal, "static class", converterName, undefined, function () {
            _this.emitLine("public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings");
            _this.emitBlock(function () {
                _this.emitLine("MetadataPropertyHandling = MetadataPropertyHandling.Ignore,");
                _this.emitLine("DateParseHandling = DateParseHandling.None,");
                _this.emitLine("Converters = {");
                _this.indent(function () {
                    _this.typesWithNamedTransformations.forEach(function (converter) {
                        _this.emitLine("new ", converter, "(),");
                    });
                    _this.emitLine("new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }");
                });
                _this.emitLine("},");
            }, true);
        });
    };
    NewtonsoftCSharpRenderer.prototype.emitDecoderTransformerCase = function (tokenCases, varName, xfer, targetType) {
        var _this = this;
        if (xfer === undefined)
            return;
        for (var _i = 0, tokenCases_1 = tokenCases; _i < tokenCases_1.length; _i++) {
            var tokenCase = tokenCases_1[_i];
            this.emitTokenCase(tokenCase);
        }
        var deserialized = this.deserializeTypeCode(this.csType(xfer.sourceType, Transformers_1.followTargetType));
        this.indent(function () {
            _this.emitLine("var ", varName, " = ", deserialized, ";");
            var allHandled = _this.emitTransformer(varName, xfer, targetType);
            if (!allHandled) {
                _this.emitLine("break;");
            }
        });
    };
    NewtonsoftCSharpRenderer.prototype.emitConsume = function (value, consumer, targetType) {
        if (consumer === undefined) {
            this.emitLine("return ", value, ";");
            return true;
        }
        else {
            return this.emitTransformer(value, consumer, targetType);
        }
    };
    NewtonsoftCSharpRenderer.prototype.emitDecodeTransformer = function (xfer, targetType) {
        var _this = this;
        if (xfer instanceof Transformers_1.DecodingTransformer) {
            this.emitLine("var value = ", this.deserializeTypeCode(this.csType(xfer.sourceType, noFollow)), ";");
            return this.emitConsume("value", xfer.consumer, targetType);
        }
        else if (xfer instanceof Transformers_1.DecodingChoiceTransformer) {
            this.emitDecoderSwitch(function () {
                var nullTransformer = xfer.nullTransformer;
                if (nullTransformer !== undefined) {
                    _this.emitTokenCase("Null");
                    _this.indent(function () {
                        var allHandled = _this.emitTransformer("null", nullTransformer, targetType);
                        if (!allHandled) {
                            _this.emitLine("break");
                        }
                    });
                }
                _this.emitDecoderTransformerCase(["Integer"], "integerValue", xfer.integerTransformer, targetType);
                _this.emitDecoderTransformerCase(xfer.integerTransformer === undefined ? ["Integer", "Float"] : ["Float"], "doubleValue", xfer.doubleTransformer, targetType);
                _this.emitDecoderTransformerCase(["Boolean"], "boolValue", xfer.boolTransformer, targetType);
                _this.emitDecoderTransformerCase(["String", "Date"], "stringValue", xfer.stringTransformer, targetType);
                _this.emitDecoderTransformerCase(["StartObject"], "objectValue", xfer.objectTransformer, targetType);
                _this.emitDecoderTransformerCase(["StartArray"], "arrayValue", xfer.arrayTransformer, targetType);
            });
            return false;
        }
        else {
            return Support_1.panic("Unknown transformer");
        }
    };
    NewtonsoftCSharpRenderer.prototype.stringCaseValue = function (t, stringCase) {
        if (t.kind === "string") {
            return ['"', Strings_1.utf16StringEscape(stringCase), '"'];
        }
        else if (t instanceof Type_1.EnumType) {
            return [this.nameForNamedType(t), ".", this.nameForEnumCase(t, stringCase)];
        }
        return Support_1.panic("Type " + t.kind + " does not have string cases");
    };
    NewtonsoftCSharpRenderer.prototype.emitTransformer = function (variable, xfer, targetType) {
        var _this = this;
        function directTargetType(continuation) {
            if (continuation === undefined) {
                return targetType;
            }
            return Transformers_1.followTargetType(continuation.sourceType);
        }
        if (xfer instanceof Transformers_1.ChoiceTransformer) {
            var caseXfers_1 = xfer.transformers;
            if (caseXfers_1.size > 1 && caseXfers_1.every(function (caseXfer) { return caseXfer instanceof Transformers_1.StringMatchTransformer; })) {
                this.emitLine("switch (", variable, ")");
                this.emitBlock(function () {
                    caseXfers_1.forEach(function (caseXfer) {
                        var matchXfer = caseXfer;
                        var value = _this.stringCaseValue(Transformers_1.followTargetType(matchXfer.sourceType), matchXfer.stringCase);
                        _this.emitLine("case ", value, ":");
                        _this.indent(function () {
                            var allDone = _this.emitTransformer(variable, matchXfer.transformer, targetType);
                            if (!allDone) {
                                _this.emitLine("break;");
                            }
                        });
                    });
                });
                // FIXME: Can we check for exhaustiveness?  For enums it should be easy.
                return false;
            }
            else {
                caseXfers_1.forEach(function (caseXfer) {
                    _this.emitTransformer(variable, caseXfer, targetType);
                });
            }
        }
        else if (xfer instanceof Transformers_1.UnionMemberMatchTransformer) {
            var test_1;
            var member_1;
            if (xfer.memberType.kind === "null") {
                test_1 = [variable, ".IsNull"];
                member_1 = "null";
            }
            else {
                var memberName = this.nameForUnionMember(xfer.sourceType, xfer.memberType);
                member_1 = [variable, ".", memberName];
                test_1 = [member_1, " != null"];
            }
            this.emitLine("if (", test_1, ")");
            this.emitBlock(function () { return _this.emitTransformer(member_1, xfer.transformer, targetType); });
        }
        else if (xfer instanceof Transformers_1.StringMatchTransformer) {
            var value = this.stringCaseValue(Transformers_1.followTargetType(xfer.sourceType), xfer.stringCase);
            this.emitLine("if (", variable, " == ", value, ")");
            this.emitBlock(function () { return _this.emitTransformer(variable, xfer.transformer, targetType); });
        }
        else if (xfer instanceof Transformers_1.EncodingTransformer) {
            this.emitLine(this.serializeValueCode(variable), "; return;");
            return true;
        }
        else if (xfer instanceof Transformers_1.ParseDateTimeTransformer) {
            this.emitLine("DateTimeOffset dt;");
            this.emitLine("if (DateTimeOffset.TryParse(", variable, ", out dt))");
            this.emitBlock(function () { return _this.emitConsume("dt", xfer.consumer, targetType); });
        }
        else if (xfer instanceof Transformers_1.StringifyDateTimeTransformer) {
            return this.emitConsume([variable, ".ToString()"], xfer.consumer, targetType);
        }
        else if (xfer instanceof Transformers_1.StringProducerTransformer) {
            var value = this.stringCaseValue(directTargetType(xfer.consumer), xfer.result);
            return this.emitConsume(value, xfer.consumer, targetType);
        }
        else if (xfer instanceof Transformers_1.UnionInstantiationTransformer) {
            if (!(targetType instanceof Type_1.UnionType)) {
                return Support_1.panic("Union instantiation transformer must produce a union type");
            }
            var unionName = this.nameForNamedType(targetType);
            var initializer = void 0;
            if (xfer.sourceType.kind === "null") {
                initializer = " ";
            }
            else {
                var memberName = this.nameForUnionMember(targetType, xfer.sourceType);
                initializer = [" ", memberName, " = ", variable, " "];
            }
            this.emitLine("return new ", unionName, " {", initializer, "};");
            return true;
        }
        else {
            return Support_1.panic("Unknown transformer");
        }
        return false;
    };
    NewtonsoftCSharpRenderer.prototype.emitTransformation = function (converterName, t) {
        var _this = this;
        var xf = Support_1.defined(Transformers_1.transformationForType(t));
        var reverse = xf.reverse;
        var targetType = xf.targetType;
        var xfer = xf.transformer;
        this.emitType(undefined, AccessModifier.Internal, "class", converterName, "JsonConverter", function () {
            var csType = _this.csType(targetType, noFollow);
            _this.emitCanConvert(["t == typeof(", csType, ") || t == typeof(", csType, "?)"]);
            _this.ensureBlankLine();
            _this.emitReadJson(function () {
                // FIXME: It's unsatisfying that we need this.  The reason is that we not
                // only match T, but also T?.  If we didn't, then the T in T? would not be
                // deserialized with our converter but with the default one.
                _this.emitLine("if (reader.TokenType == JsonToken.Null) return null;");
                var allHandled = _this.emitDecodeTransformer(xfer, targetType);
                if (!allHandled) {
                    _this.emitThrow(['"Cannot unmarshal type ', csType, '"']);
                }
            });
            _this.ensureBlankLine();
            _this.emitWriteJson("untypedValue", function () {
                _this.emitLine("var value = (", csType, ")untypedValue;");
                var allHandled = _this.emitTransformer("value", reverse.transformer, reverse.targetType);
                if (!allHandled) {
                    _this.emitThrow(['"Cannot marshal type ', csType, '"']);
                }
            });
        });
    };
    NewtonsoftCSharpRenderer.prototype.emitRequiredHelpers = function () {
        var _this = this;
        if (this._needHelpers) {
            this.forEachTopLevel("leading-and-interposing", function (t, n) { return _this.emitFromJsonForTopLevel(t, n); });
            this.ensureBlankLine();
            this.emitSerializeClass();
        }
        if (this._needHelpers || (this._needAttributes && (this.haveNamedUnions || this.haveEnums))) {
            this.ensureBlankLine();
            this.emitConverterClass();
        }
        this.forEachTransformation("leading-and-interposing", function (n, t) { return _this.emitTransformation(n, t); });
    };
    NewtonsoftCSharpRenderer.prototype.needNamespace = function () {
        return this._needHelpers || this._needAttributes;
    };
    NewtonsoftCSharpRenderer.prototype.makeHandlebarsContextForType = function (t) {
        var ctx = _super.prototype.makeHandlebarsContextForType.call(this, t);
        if (t.kind === "enum") {
            var name = this.nameForNamedType(t);
            ctx.extensionsName = Support_1.defined(this.names.get(Support_1.defined(this._enumExtensionsNames.get(name))));
        }
        return ctx;
    };
    return NewtonsoftCSharpRenderer;
}(CSharpRenderer));
exports.NewtonsoftCSharpRenderer = NewtonsoftCSharpRenderer;
