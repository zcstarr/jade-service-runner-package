"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var TargetLanguage_1 = require("../TargetLanguage");
var RendererOptions_1 = require("../RendererOptions");
var Type_1 = require("../Type");
var TypeUtils_1 = require("../TypeUtils");
var ConvenienceRenderer_1 = require("../ConvenienceRenderer");
var Naming_1 = require("../Naming");
var Strings_1 = require("../Strings");
var Support_1 = require("../Support");
var Source_1 = require("../Source");
var Annotation_1 = require("../Annotation");
var ElmTargetLanguage = /** @class */ (function (_super) {
    __extends(ElmTargetLanguage, _super);
    function ElmTargetLanguage() {
        var _this = _super.call(this, "Elm", ["elm"], "elm") || this;
        _this._justTypesOption = new RendererOptions_1.BooleanOption("just-types", "Plain types only", false);
        _this._listOption = new RendererOptions_1.EnumOption("array-type", "Use Array or List", [
            ["array", false],
            ["list", true]
        ]);
        // FIXME: Do this via a configurable named eventually.
        _this._moduleOption = new RendererOptions_1.StringOption("module", "Generated module name", "NAME", "QuickType");
        return _this;
    }
    ElmTargetLanguage.prototype.getOptions = function () {
        return [this._justTypesOption, this._moduleOption, this._listOption];
    };
    Object.defineProperty(ElmTargetLanguage.prototype, "supportsOptionalClassProperties", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElmTargetLanguage.prototype, "supportsUnionsWithBothNumberTypes", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElmTargetLanguage.prototype, "rendererClass", {
        get: function () {
            return ElmRenderer;
        },
        enumerable: true,
        configurable: true
    });
    return ElmTargetLanguage;
}(TargetLanguage_1.TargetLanguage));
exports.default = ElmTargetLanguage;
var forbiddenNames = [
    "if",
    "then",
    "else",
    "case",
    "of",
    "let",
    "in",
    "infix",
    "type",
    "module",
    "where",
    "import",
    "exposing",
    "as",
    "port",
    "int",
    "float",
    "bool",
    "string",
    "Jenc",
    "Jdec",
    "Jpipe",
    "always",
    "identity",
    "Array",
    "List",
    "Dict",
    "Maybe",
    "map",
    "toList",
    "makeArrayEncoder",
    "makeDictEncoder",
    "makeNullableEncoder",
    "Int",
    "True",
    "False",
    "String",
    "Float"
];
var legalizeName = Strings_1.legalizeCharacters(function (cp) { return Strings_1.isAscii(cp) && Strings_1.isLetterOrUnderscoreOrDigit(cp); });
function elmNameStyle(original, upper) {
    var words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", Strings_1.isLetterOrUnderscore);
}
var upperNamingFunction = Naming_1.funPrefixNamer("upper", function (n) { return elmNameStyle(n, true); });
var lowerNamingFunction = Naming_1.funPrefixNamer("lower", function (n) { return elmNameStyle(n, false); });
function requiredOrOptional(p) {
    function optional(fallback) {
        return { reqOrOpt: "Jpipe.optional", fallback: fallback };
    }
    var t = p.type;
    if (p.isOptional || (t instanceof Type_1.UnionType && TypeUtils_1.nullableFromUnion(t) !== null)) {
        return optional(" Nothing");
    }
    if (t.kind === "null") {
        return optional(" ()");
    }
    return { reqOrOpt: "Jpipe.required", fallback: "" };
}
var ElmRenderer = /** @class */ (function (_super) {
    __extends(ElmRenderer, _super);
    function ElmRenderer(targetLanguage, graph, leadingComments, _justTypes, _moduleName, _useList) {
        var _this = _super.call(this, targetLanguage, graph, leadingComments) || this;
        _this._justTypes = _justTypes;
        _this._moduleName = _moduleName;
        _this._useList = _useList;
        _this._topLevelDependents = immutable_1.Map();
        _this._namedTypeDependents = immutable_1.Map();
        _this.decoderNameForNamedType = function (t) {
            var name = _this.nameForNamedType(t);
            return Support_1.defined(_this._namedTypeDependents.get(name)).decoder;
        };
        _this.encoderNameForNamedType = function (t) {
            var name = _this.nameForNamedType(t);
            return Support_1.defined(_this._namedTypeDependents.get(name)).encoder;
        };
        _this.emitTopLevelDefinition = function (t, topLevelName) {
            _this.emitLine("type alias ", topLevelName, " = ", _this.elmType(t).source);
        };
        _this.emitClassDefinition = function (c, className) {
            var description = _this.descriptionForType(c);
            _this.forEachClassProperty(c, "none", function (name, jsonName) {
                var propertyDescription = _this.descriptionForClassProperty(c, jsonName);
                if (propertyDescription === undefined)
                    return;
                if (description === undefined) {
                    description = [];
                }
                else {
                    description.push("");
                }
                description.push(_this.sourcelikeToString(name) + ":");
                description.push.apply(description, propertyDescription);
            });
            _this.emitDescription(description);
            _this.emitLine("type alias ", className, " =");
            _this.indent(function () {
                var onFirst = true;
                _this.forEachClassProperty(c, "none", function (name, _jsonName, p) {
                    _this.emitLine(onFirst ? "{" : ",", " ", name, " : ", _this.elmProperty(p));
                    onFirst = false;
                });
                if (onFirst) {
                    _this.emitLine("{");
                }
                _this.emitLine("}");
            });
        };
        _this.emitEnumDefinition = function (e, enumName) {
            _this.emitDescription(_this.descriptionForType(e));
            _this.emitLine("type ", enumName);
            _this.indent(function () {
                var onFirst = true;
                _this.forEachEnumCase(e, "none", function (name) {
                    var equalsOrPipe = onFirst ? "=" : "|";
                    _this.emitLine(equalsOrPipe, " ", name);
                    onFirst = false;
                });
            });
        };
        _this.emitUnionDefinition = function (u, unionName) {
            _this.emitDescription(_this.descriptionForType(u));
            _this.emitLine("type ", unionName);
            _this.indent(function () {
                var onFirst = true;
                _this.forEachUnionMember(u, null, "none", null, function (constructor, t) {
                    var equalsOrPipe = onFirst ? "=" : "|";
                    if (t.kind === "null") {
                        _this.emitLine(equalsOrPipe, " ", constructor);
                    }
                    else {
                        _this.emitLine(equalsOrPipe, " ", constructor, " ", Source_1.parenIfNeeded(_this.elmType(t)));
                    }
                    onFirst = false;
                });
            });
        };
        _this.emitTopLevelFunctions = function (t, topLevelName) {
            var _a = Support_1.defined(_this._topLevelDependents.get(topLevelName)), encoder = _a.encoder, decoder = _a.decoder;
            if (_this.namedTypeToNameForTopLevel(t) === undefined) {
                _this.emitLine(Support_1.defined(decoder), " : Jdec.Decoder ", topLevelName);
                _this.emitLine(Support_1.defined(decoder), " = ", _this.decoderNameForType(t).source);
                _this.ensureBlankLine();
            }
            _this.emitLine(encoder, " : ", topLevelName, " -> String");
            _this.emitLine(encoder, " r = Jenc.encode 0 (", _this.encoderNameForType(t).source, " r)");
        };
        _this.emitClassFunctions = function (c, className) {
            var decoderName = _this.decoderNameForNamedType(c);
            _this.emitLine(decoderName, " : Jdec.Decoder ", className);
            _this.emitLine(decoderName, " =");
            _this.indent(function () {
                _this.emitLine("Jpipe.decode ", className);
                _this.indent(function () {
                    _this.forEachClassProperty(c, "none", function (_, jsonName, p) {
                        var propDecoder = Source_1.parenIfNeeded(_this.decoderNameForProperty(p));
                        var _a = requiredOrOptional(p), reqOrOpt = _a.reqOrOpt, fallback = _a.fallback;
                        _this.emitLine("|> ", reqOrOpt, ' "', Strings_1.stringEscape(jsonName), '" ', propDecoder, fallback);
                    });
                });
            });
            _this.ensureBlankLine();
            var encoderName = _this.encoderNameForNamedType(c);
            _this.emitLine(encoderName, " : ", className, " -> Jenc.Value");
            _this.emitLine(encoderName, " x =");
            _this.indent(function () {
                _this.emitLine("Jenc.object");
                _this.indent(function () {
                    var onFirst = true;
                    _this.forEachClassProperty(c, "none", function (name, jsonName, p) {
                        var bracketOrComma = onFirst ? "[" : ",";
                        var propEncoder = _this.encoderNameForProperty(p).source;
                        _this.emitLine(bracketOrComma, ' ("', Strings_1.stringEscape(jsonName), '", ', propEncoder, " x.", name, ")");
                        onFirst = false;
                    });
                    if (onFirst) {
                        _this.emitLine("[");
                    }
                    _this.emitLine("]");
                });
            });
        };
        _this.emitEnumFunctions = function (e, enumName) {
            var decoderName = _this.decoderNameForNamedType(e);
            _this.emitLine(decoderName, " : Jdec.Decoder ", enumName);
            _this.emitLine(decoderName, " =");
            _this.indent(function () {
                _this.emitLine("Jdec.string");
                _this.indent(function () {
                    _this.emitLine("|> Jdec.andThen (\\str ->");
                    _this.indent(function () {
                        _this.emitLine("case str of");
                        _this.indent(function () {
                            _this.forEachEnumCase(e, "none", function (name, jsonName) {
                                _this.emitLine('"', Strings_1.stringEscape(jsonName), '" -> Jdec.succeed ', name);
                            });
                            _this.emitLine('somethingElse -> Jdec.fail <| "Invalid ', enumName, ': " ++ somethingElse');
                        });
                    });
                    _this.emitLine(")");
                });
            });
            _this.ensureBlankLine();
            var encoderName = _this.encoderNameForNamedType(e);
            _this.emitLine(encoderName, " : ", enumName, " -> Jenc.Value");
            _this.emitLine(encoderName, " x = case x of");
            _this.indent(function () {
                _this.forEachEnumCase(e, "none", function (name, jsonName) {
                    _this.emitLine(name, ' -> Jenc.string "', Strings_1.stringEscape(jsonName), '"');
                });
            });
        };
        _this.emitUnionFunctions = function (u, unionName) {
            // We need arrays first, then strings, and integers before doubles.
            function sortOrder(_, t) {
                if (t.kind === "array") {
                    return "  array";
                }
                else if (t.kind === "double") {
                    return " xdouble";
                }
                else if (t.isPrimitive()) {
                    return " " + t.kind;
                }
                return t.kind;
            }
            var decoderName = _this.decoderNameForNamedType(u);
            _this.emitLine(decoderName, " : Jdec.Decoder ", unionName);
            _this.emitLine(decoderName, " =");
            _this.indent(function () {
                _this.emitLine("Jdec.oneOf");
                _this.indent(function () {
                    var onFirst = true;
                    _this.forEachUnionMember(u, null, "none", sortOrder, function (constructor, t) {
                        var bracketOrComma = onFirst ? "[" : ",";
                        if (t.kind === "null") {
                            _this.emitLine(bracketOrComma, " Jdec.null ", constructor);
                        }
                        else {
                            var decoder = Source_1.parenIfNeeded(_this.decoderNameForType(t));
                            _this.emitLine(bracketOrComma, " Jdec.map ", constructor, " ", decoder);
                        }
                        onFirst = false;
                    });
                    _this.emitLine("]");
                });
            });
            _this.ensureBlankLine();
            var encoderName = _this.encoderNameForNamedType(u);
            _this.emitLine(encoderName, " : ", unionName, " -> Jenc.Value");
            _this.emitLine(encoderName, " x = case x of");
            _this.indent(function () {
                _this.forEachUnionMember(u, null, "none", sortOrder, function (constructor, t) {
                    if (t.kind === "null") {
                        _this.emitLine(constructor, " -> Jenc.null");
                    }
                    else {
                        var encoder = _this.encoderNameForType(t).source;
                        _this.emitLine(constructor, " y -> ", encoder, " y");
                    }
                });
            });
        };
        return _this;
    }
    ElmRenderer.prototype.forbiddenNamesForGlobalNamespace = function () {
        return forbiddenNames;
    };
    ElmRenderer.prototype.makeTopLevelDependencyNames = function (t, topLevelName) {
        var encoder = new Naming_1.DependencyName(lowerNamingFunction, topLevelName.order, function (lookup) { return lookup(topLevelName) + "_to_string"; });
        var decoder = undefined;
        if (this.namedTypeToNameForTopLevel(t) === undefined) {
            decoder = new Naming_1.DependencyName(lowerNamingFunction, topLevelName.order, function (lookup) { return lookup(topLevelName); });
        }
        this._topLevelDependents = this._topLevelDependents.set(topLevelName, { encoder: encoder, decoder: decoder });
        if (decoder !== undefined) {
            return [encoder, decoder];
        }
        return [encoder];
    };
    ElmRenderer.prototype.makeNamedTypeNamer = function () {
        return upperNamingFunction;
    };
    ElmRenderer.prototype.makeNamedTypeDependencyNames = function (_, typeName) {
        var encoder = new Naming_1.DependencyName(lowerNamingFunction, typeName.order, function (lookup) { return "encode_" + lookup(typeName); });
        var decoder = new Naming_1.DependencyName(lowerNamingFunction, typeName.order, function (lookup) { return lookup(typeName); });
        this._namedTypeDependents = this._namedTypeDependents.set(typeName, { encoder: encoder, decoder: decoder });
        return [encoder, decoder];
    };
    ElmRenderer.prototype.namerForObjectProperty = function () {
        return lowerNamingFunction;
    };
    ElmRenderer.prototype.forbiddenForObjectProperties = function (_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    };
    ElmRenderer.prototype.makeUnionMemberNamer = function () {
        return upperNamingFunction;
    };
    Object.defineProperty(ElmRenderer.prototype, "unionMembersInGlobalNamespace", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    ElmRenderer.prototype.makeEnumCaseNamer = function () {
        return upperNamingFunction;
    };
    Object.defineProperty(ElmRenderer.prototype, "enumCasesInGlobalNamespace", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    ElmRenderer.prototype.proposeUnionMemberName = function (u, unionName, fieldType, lookup) {
        var fieldName = _super.prototype.proposeUnionMemberName.call(this, u, unionName, fieldType, lookup);
        return fieldName + "_in_" + lookup(unionName);
    };
    Object.defineProperty(ElmRenderer.prototype, "commentLineStart", {
        get: function () {
            return "-- ";
        },
        enumerable: true,
        configurable: true
    });
    ElmRenderer.prototype.emitDescriptionBlock = function (lines) {
        if (lines.length === 1) {
            this.emitLine("{-| ", lines[0], " -}");
        }
        else {
            this.emitCommentLines(lines, "", undefined, "-}", "{-| ");
        }
    };
    Object.defineProperty(ElmRenderer.prototype, "arrayType", {
        get: function () {
            return this._useList ? "List" : "Array";
        },
        enumerable: true,
        configurable: true
    });
    ElmRenderer.prototype.elmType = function (t, noOptional) {
        var _this = this;
        if (noOptional === void 0) { noOptional = false; }
        return TypeUtils_1.matchType(t, function (_anyType) { return Source_1.singleWord(Source_1.annotated(Annotation_1.anyTypeIssueAnnotation, "Jdec.Value")); }, function (_nullType) { return Source_1.singleWord(Source_1.annotated(Annotation_1.nullTypeIssueAnnotation, "()")); }, function (_boolType) { return Source_1.singleWord("Bool"); }, function (_integerType) { return Source_1.singleWord("Int"); }, function (_doubleType) { return Source_1.singleWord("Float"); }, function (_stringType) { return Source_1.singleWord("String"); }, function (arrayType) { return Source_1.multiWord(" ", _this.arrayType, Source_1.parenIfNeeded(_this.elmType(arrayType.items))); }, function (classType) { return Source_1.singleWord(_this.nameForNamedType(classType)); }, function (mapType) { return Source_1.multiWord(" ", "Dict String", Source_1.parenIfNeeded(_this.elmType(mapType.values))); }, function (enumType) { return Source_1.singleWord(_this.nameForNamedType(enumType)); }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                var nullableType = _this.elmType(nullable);
                if (noOptional)
                    return nullableType;
                return Source_1.multiWord(" ", "Maybe", Source_1.parenIfNeeded(nullableType));
            }
            return Source_1.singleWord(_this.nameForNamedType(unionType));
        });
    };
    ElmRenderer.prototype.elmProperty = function (p) {
        if (p.isOptional) {
            return Source_1.multiWord(" ", "Maybe", Source_1.parenIfNeeded(this.elmType(p.type, true))).source;
        }
        else {
            return this.elmType(p.type).source;
        }
    };
    ElmRenderer.prototype.decoderNameForType = function (t, noOptional) {
        var _this = this;
        if (noOptional === void 0) { noOptional = false; }
        return TypeUtils_1.matchType(t, function (_anyType) { return Source_1.singleWord("Jdec.value"); }, function (_nullType) { return Source_1.multiWord(" ", "Jdec.null", "()"); }, function (_boolType) { return Source_1.singleWord("Jdec.bool"); }, function (_integerType) { return Source_1.singleWord("Jdec.int"); }, function (_doubleType) { return Source_1.singleWord("Jdec.float"); }, function (_stringType) { return Source_1.singleWord("Jdec.string"); }, function (arrayType) {
            return Source_1.multiWord(" ", ["Jdec.", Strings_1.decapitalize(_this.arrayType)], Source_1.parenIfNeeded(_this.decoderNameForType(arrayType.items)));
        }, function (classType) { return Source_1.singleWord(_this.decoderNameForNamedType(classType)); }, function (mapType) { return Source_1.multiWord(" ", "Jdec.dict", Source_1.parenIfNeeded(_this.decoderNameForType(mapType.values))); }, function (enumType) { return Source_1.singleWord(_this.decoderNameForNamedType(enumType)); }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                var nullableDecoder = _this.decoderNameForType(nullable);
                if (noOptional)
                    return nullableDecoder;
                return Source_1.multiWord(" ", "Jdec.nullable", Source_1.parenIfNeeded(nullableDecoder));
            }
            return Source_1.singleWord(_this.decoderNameForNamedType(unionType));
        });
    };
    ElmRenderer.prototype.decoderNameForProperty = function (p) {
        if (p.isOptional) {
            return Source_1.multiWord(" ", "Jdec.nullable", Source_1.parenIfNeeded(this.decoderNameForType(p.type, true)));
        }
        else {
            return this.decoderNameForType(p.type);
        }
    };
    ElmRenderer.prototype.encoderNameForType = function (t, noOptional) {
        var _this = this;
        if (noOptional === void 0) { noOptional = false; }
        return TypeUtils_1.matchType(t, function (_anyType) { return Source_1.singleWord("identity"); }, function (_nullType) { return Source_1.multiWord(" ", "always", "Jenc.null"); }, function (_boolType) { return Source_1.singleWord("Jenc.bool"); }, function (_integerType) { return Source_1.singleWord("Jenc.int"); }, function (_doubleType) { return Source_1.singleWord("Jenc.float"); }, function (_stringType) { return Source_1.singleWord("Jenc.string"); }, function (arrayType) {
            return Source_1.multiWord(" ", ["make", _this.arrayType, "Encoder"], Source_1.parenIfNeeded(_this.encoderNameForType(arrayType.items)));
        }, function (classType) { return Source_1.singleWord(_this.encoderNameForNamedType(classType)); }, function (mapType) { return Source_1.multiWord(" ", "makeDictEncoder", Source_1.parenIfNeeded(_this.encoderNameForType(mapType.values))); }, function (enumType) { return Source_1.singleWord(_this.encoderNameForNamedType(enumType)); }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                var nullableEncoder = _this.encoderNameForType(nullable);
                if (noOptional)
                    return nullableEncoder;
                return Source_1.multiWord(" ", "makeNullableEncoder", Source_1.parenIfNeeded(nullableEncoder));
            }
            return Source_1.singleWord(_this.encoderNameForNamedType(unionType));
        });
    };
    ElmRenderer.prototype.encoderNameForProperty = function (p) {
        if (p.isOptional) {
            return Source_1.multiWord(" ", "makeNullableEncoder", Source_1.parenIfNeeded(this.encoderNameForType(p.type, true)));
        }
        else {
            return this.encoderNameForType(p.type);
        }
    };
    ElmRenderer.prototype.emitSourceStructure = function () {
        var _this = this;
        var exports = [];
        var topLevelDecoders = immutable_1.List();
        this.forEachTopLevel("none", function (_, name) {
            var _a = Support_1.defined(_this._topLevelDependents.get(name)), encoder = _a.encoder, decoder = _a.decoder;
            if (decoder === undefined) {
                decoder = Support_1.defined(_this._namedTypeDependents.get(name)).decoder;
            }
            topLevelDecoders = topLevelDecoders.push(decoder);
            exports.push(name, encoder, decoder);
        });
        this.forEachObject("none", function (t, name) {
            if (!_this.topLevels.contains(t))
                exports.push(name);
        });
        this.forEachEnum("none", function (t, name) {
            if (!_this.topLevels.contains(t))
                exports.push([name, "(..)"]);
        });
        this.forEachUnion("none", function (t, name) {
            if (!_this.topLevels.contains(t))
                exports.push([name, "(..)"]);
        });
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else if (!this._justTypes) {
            this.emitCommentLines([
                "To decode the JSON data, add this file to your project, run",
                "",
                "    elm-package install NoRedInk/elm-decode-pipeline",
                "",
                "add these imports",
                "",
                "    import Json.Decode exposing (decodeString)`);"
            ]);
            this.emitLine("--     import ", this._moduleName, " exposing (", Support_1.intercalate(", ", topLevelDecoders).toArray(), ")");
            this.emitMultiline("--\n-- and you're off to the races with\n--");
            this.forEachTopLevel("none", function (_, name) {
                var decoder = Support_1.defined(_this._topLevelDependents.get(name)).decoder;
                if (decoder === undefined) {
                    decoder = Support_1.defined(_this._namedTypeDependents.get(name)).decoder;
                }
                _this.emitLine("--     decodeString ", decoder, " myJsonString");
            });
        }
        if (!this._justTypes) {
            this.ensureBlankLine();
            this.emitLine("module ", this._moduleName, " exposing");
            this.indent(function () {
                for (var i = 0; i < exports.length; i++) {
                    _this.emitLine(i === 0 ? "(" : ",", " ", exports[i]);
                }
                _this.emitLine(")");
            });
            this.ensureBlankLine();
            this.emitMultiline("import Json.Decode as Jdec\nimport Json.Decode.Pipeline as Jpipe\nimport Json.Encode as Jenc\nimport Dict exposing (Dict, map, toList)");
            if (this._useList) {
                this.emitLine("import List exposing (map)");
            }
            else {
                this.emitLine("import Array exposing (Array, map)");
            }
        }
        this.forEachTopLevel("leading-and-interposing", this.emitTopLevelDefinition, function (t) { return _this.namedTypeToNameForTopLevel(t) === undefined; });
        this.forEachNamedType("leading-and-interposing", this.emitClassDefinition, this.emitEnumDefinition, this.emitUnionDefinition);
        if (this._justTypes)
            return;
        this.ensureBlankLine();
        this.emitLine("-- decoders and encoders");
        this.forEachTopLevel("leading-and-interposing", this.emitTopLevelFunctions);
        this.forEachNamedType("leading-and-interposing", this.emitClassFunctions, this.emitEnumFunctions, this.emitUnionFunctions);
        this.ensureBlankLine();
        this.emitLine("--- encoder helpers");
        this.ensureBlankLine();
        this.emitLine("make", this.arrayType, "Encoder : (a -> Jenc.Value) -> ", this.arrayType, " a -> Jenc.Value");
        this.emitLine("make", this.arrayType, "Encoder f arr =");
        this.indent(function () {
            _this.emitLine("Jenc.", Strings_1.decapitalize(_this.arrayType), " (", _this.arrayType, ".map f arr)");
        });
        this.ensureBlankLine();
        this.emitMultiline("makeDictEncoder : (a -> Jenc.Value) -> Dict String a -> Jenc.Value\nmakeDictEncoder f dict =\n    Jenc.object (toList (Dict.map (\\k -> f) dict))\n\nmakeNullableEncoder : (a -> Jenc.Value) -> Maybe a -> Jenc.Value\nmakeNullableEncoder f m =\n    case m of\n    Just x -> f x\n    Nothing -> Jenc.null");
    };
    return ElmRenderer;
}(ConvenienceRenderer_1.ConvenienceRenderer));
exports.ElmRenderer = ElmRenderer;
