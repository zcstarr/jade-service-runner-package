"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TypeUtils_1 = require("../TypeUtils");
var Strings_1 = require("../Strings");
var Support_1 = require("../Support");
var Source_1 = require("../Source");
var Naming_1 = require("../Naming");
var ConvenienceRenderer_1 = require("../ConvenienceRenderer");
var TargetLanguage_1 = require("../TargetLanguage");
var RendererOptions_1 = require("../RendererOptions");
var unicode = require("unicode-properties");
var JavaScriptTargetLanguage = /** @class */ (function (_super) {
    __extends(JavaScriptTargetLanguage, _super);
    function JavaScriptTargetLanguage(displayName, names, extension) {
        if (displayName === void 0) { displayName = "JavaScript"; }
        if (names === void 0) { names = ["javascript", "js", "jsx"]; }
        if (extension === void 0) { extension = "js"; }
        var _this = _super.call(this, displayName, names, extension) || this;
        _this.runtimeTypecheck = new RendererOptions_1.BooleanOption("runtime-typecheck", "Verify JSON.parse results at runtime", true);
        return _this;
    }
    JavaScriptTargetLanguage.prototype.getOptions = function () {
        return [this.runtimeTypecheck];
    };
    Object.defineProperty(JavaScriptTargetLanguage.prototype, "supportsOptionalClassProperties", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JavaScriptTargetLanguage.prototype, "supportsFullObjectType", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JavaScriptTargetLanguage.prototype, "rendererClass", {
        get: function () {
            return JavaScriptRenderer;
        },
        enumerable: true,
        configurable: true
    });
    return JavaScriptTargetLanguage;
}(TargetLanguage_1.TargetLanguage));
exports.JavaScriptTargetLanguage = JavaScriptTargetLanguage;
function isStartCharacter(utf16Unit) {
    return unicode.isAlphabetic(utf16Unit) || utf16Unit === 0x5f; // underscore
}
function isPartCharacter(utf16Unit) {
    var category = unicode.getCategory(utf16Unit);
    return ["Nd", "Pc", "Mn", "Mc"].indexOf(category) >= 0 || isStartCharacter(utf16Unit);
}
var legalizeName = Strings_1.utf16LegalizeCharacters(isPartCharacter);
function typeNameStyle(original) {
    var words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
}
function propertyNameStyle(original) {
    var escaped = Strings_1.utf16StringEscape(original);
    var quoted = "\"" + escaped + "\"";
    if (original.length === 0) {
        return quoted;
    }
    else if (!isStartCharacter(original.codePointAt(0))) {
        return quoted;
    }
    else if (escaped !== original) {
        return quoted;
    }
    else if (legalizeName(original) !== original) {
        return quoted;
    }
    else {
        return original;
    }
}
var JavaScriptRenderer = /** @class */ (function (_super) {
    __extends(JavaScriptRenderer, _super);
    function JavaScriptRenderer(targetLanguage, graph, leadingComments, _runtimeTypecheck) {
        var _this = _super.call(this, targetLanguage, graph, leadingComments) || this;
        _this._runtimeTypecheck = _runtimeTypecheck;
        _this.typeMapTypeFor = function (t) {
            if (["class", "object", "enum"].indexOf(t.kind) >= 0) {
                return ['r("', _this.nameForNamedType(t), '")'];
            }
            return TypeUtils_1.matchType(t, function (_anyType) { return '"any"'; }, function (_nullType) { return "null"; }, function (_boolType) { return "true"; }, function (_integerType) { return "0"; }, function (_doubleType) { return "3.14"; }, function (_stringType) { return "\"\""; }, function (arrayType) { return ["a(", _this.typeMapTypeFor(arrayType.items), ")"]; }, function (_classType) { return Support_1.panic("We handled this above"); }, function (mapType) { return ["m(", _this.typeMapTypeFor(mapType.values), ")"]; }, function (_enumType) { return Support_1.panic("We handled this above"); }, function (unionType) {
                var children = unionType.getChildren().map(_this.typeMapTypeFor);
                return ["u("].concat(Support_1.intercalate(", ", children).toArray(), [")"]);
            });
        };
        _this.emitTypeMap = function () {
            var anyAnnotation = _this.typeAnnotations.any;
            _this.emitBlock("const typeMap" + anyAnnotation + " = ", ";", function () {
                _this.forEachObject("none", function (t, name) {
                    var additionalProperties = t.getAdditionalProperties();
                    var additional = additionalProperties !== undefined ? _this.typeMapTypeFor(additionalProperties) : "false";
                    _this.emitBlock(['"', name, '": o('], [", ", additional, "),"], function () {
                        _this.forEachClassProperty(t, "none", function (propName, _propJsonName, property) {
                            _this.emitLine(propName, ": ", _this.typeMapTypeForProperty(property), ",");
                        });
                    });
                });
                _this.forEachEnum("none", function (e, name) {
                    _this.emitLine('"', name, '": [');
                    _this.indent(function () {
                        _this.forEachEnumCase(e, "none", function (_caseName, jsonName) {
                            _this.emitLine("\"" + Strings_1.utf16StringEscape(jsonName) + "\",");
                        });
                    });
                    _this.emitLine("],");
                });
            });
        };
        return _this;
    }
    JavaScriptRenderer.prototype.makeNamedTypeNamer = function () {
        return new Naming_1.Namer("types", typeNameStyle, []);
    };
    JavaScriptRenderer.prototype.namerForObjectProperty = function () {
        return new Naming_1.Namer("properties", propertyNameStyle, []);
    };
    JavaScriptRenderer.prototype.makeUnionMemberNamer = function () {
        return null;
    };
    JavaScriptRenderer.prototype.makeEnumCaseNamer = function () {
        return new Naming_1.Namer("enum-cases", typeNameStyle, []);
    };
    JavaScriptRenderer.prototype.namedTypeToNameForTopLevel = function (type) {
        return TypeUtils_1.directlyReachableSingleNamedType(type);
    };
    JavaScriptRenderer.prototype.makeNameForProperty = function (c, className, p, jsonName, _assignedName) {
        // Ignore the assigned name
        return _super.prototype.makeNameForProperty.call(this, c, className, p, jsonName, undefined);
    };
    JavaScriptRenderer.prototype.emitDescriptionBlock = function (lines) {
        this.emitCommentLines(lines, " * ", "/**", " */");
    };
    JavaScriptRenderer.prototype.typeMapTypeForProperty = function (p) {
        var typeMap = this.typeMapTypeFor(p.type);
        if (!p.isOptional) {
            return typeMap;
        }
        return ["u(undefined, ", typeMap, ")"];
    };
    JavaScriptRenderer.prototype.emitBlock = function (source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
    };
    JavaScriptRenderer.prototype.deserializerFunctionName = function (name) {
        return ["to", name];
    };
    JavaScriptRenderer.prototype.deserializerFunctionLine = function (_t, name) {
        return ["function ", this.deserializerFunctionName(name), "(json)"];
    };
    JavaScriptRenderer.prototype.serializerFunctionName = function (name) {
        var camelCaseName = Source_1.modifySource(Strings_1.camelCase, name);
        return [camelCaseName, "ToJson"];
    };
    JavaScriptRenderer.prototype.serializerFunctionLine = function (_t, name) {
        return ["function ", this.serializerFunctionName(name), "(value)"];
    };
    Object.defineProperty(JavaScriptRenderer.prototype, "moduleLine", {
        get: function () {
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JavaScriptRenderer.prototype, "castFunctionLine", {
        get: function () {
            return "function cast(obj, typ)";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(JavaScriptRenderer.prototype, "typeAnnotations", {
        get: function () {
            return { any: "", anyArray: "", anyMap: "", string: "", stringArray: "", boolean: "" };
        },
        enumerable: true,
        configurable: true
    });
    JavaScriptRenderer.prototype.emitConvertModuleBody = function () {
        var _this = this;
        this.forEachTopLevel("interposing", function (t, name) {
            _this.emitBlock([_this.deserializerFunctionLine(t, name), " "], "", function () {
                if (!_this._runtimeTypecheck) {
                    _this.emitLine("return JSON.parse(json);");
                }
                else {
                    _this.emitLine("return cast(JSON.parse(json), ", _this.typeMapTypeFor(t), ");");
                }
            });
            _this.ensureBlankLine();
            _this.emitBlock([_this.serializerFunctionLine(t, name), " "], "", function () {
                _this.emitLine("return JSON.stringify(value, null, 2);");
            });
        });
        if (this._runtimeTypecheck) {
            var _a = this.typeAnnotations, anyAnnotation = _a.any, anyArrayAnnotation = _a.anyArray, anyMapAnnotation = _a.anyMap, stringAnnotation = _a.string, stringArrayAnnotation = _a.stringArray, booleanAnnotation = _a.boolean;
            this.ensureBlankLine();
            this.emitMultiline(this.castFunctionLine + " {\n    if (!isValid(typ, obj)) {\n        throw Error(`Invalid value`);\n    }\n    return obj;\n}\n\nfunction isValid(typ" + anyAnnotation + ", val" + anyAnnotation + ")" + booleanAnnotation + " {\n    if (typ === \"any\") { return true; }\n    if (typ === null) { return val === null; }\n    if (typ === false) { return false; }\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) { return isValidEnum(typ, val); }\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? isValidUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? isValidArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? isValidObject(typ.props, typ.additional, val)\n            : false;\n    }\n    return isValidPrimitive(typ, val);\n}\n\nfunction isValidPrimitive(typ" + stringAnnotation + ", val" + anyAnnotation + ") {\n    return typeof typ === typeof val;\n}\n\nfunction isValidUnion(typs" + anyArrayAnnotation + ", val" + anyAnnotation + ")" + booleanAnnotation + " {\n    // val must validate against one typ in typs\n    return typs.some((typ) => isValid(typ, val));\n}\n\nfunction isValidEnum(cases" + stringArrayAnnotation + ", val" + anyAnnotation + ")" + booleanAnnotation + " {\n    return cases.indexOf(val) !== -1;\n}\n\nfunction isValidArray(typ" + anyAnnotation + ", val" + anyAnnotation + ")" + booleanAnnotation + " {\n    // val must be an array with no invalid elements\n    return Array.isArray(val) && val.every((element) => {\n        return isValid(typ, element);\n    });\n}\n\nfunction isValidObject(props" + anyMapAnnotation + ", additional" + anyAnnotation + ", val" + anyAnnotation + ")" + booleanAnnotation + " {\n    if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n        return false;\n    }\n    return Object.getOwnPropertyNames(val).every((key) => {\n        const prop = val[key];\n        if (Object.prototype.hasOwnProperty.call(props, key)) {\n            return isValid(props[key], prop);\n        }\n        return isValid(additional, prop);\n    });\n}\n\nfunction a(typ" + anyAnnotation + ") {\n    return { arrayItems: typ };\n}\n\nfunction u(...typs" + anyArrayAnnotation + ") {\n    return { unionMembers: typs };\n}\n\nfunction o(props" + anyMapAnnotation + ", additional" + anyAnnotation + ") {\n    return { props, additional };\n}\n\nfunction m(additional" + anyAnnotation + ") {\n    return { props: {}, additional };\n}\n\nfunction r(name" + stringAnnotation + ") {\n    return { ref: name };\n}\n");
            this.emitTypeMap();
        }
    };
    JavaScriptRenderer.prototype.emitConvertModule = function () {
        var _this = this;
        this.ensureBlankLine();
        this.emitMultiline("// Converts JSON strings to/from your types");
        if (this._runtimeTypecheck) {
            this.emitMultiline("// and asserts the results of JSON.parse at runtime");
        }
        var moduleLine = this.moduleLine;
        if (moduleLine === undefined) {
            this.emitConvertModuleBody();
        }
        else {
            this.emitBlock([moduleLine, " "], "", function () { return _this.emitConvertModuleBody(); });
        }
    };
    JavaScriptRenderer.prototype.emitTypes = function () {
        return;
    };
    JavaScriptRenderer.prototype.emitUsageImportComment = function () {
        this.emitLine('//   const Convert = require("./file");');
    };
    JavaScriptRenderer.prototype.emitUsageComments = function () {
        var _this = this;
        this.emitMultiline("// To parse this data:\n//");
        this.emitUsageImportComment();
        this.emitLine("//");
        this.forEachTopLevel("none", function (_t, name) {
            var camelCaseName = Source_1.modifySource(Strings_1.camelCase, name);
            _this.emitLine("//   const ", camelCaseName, " = Convert.to", name, "(json);");
        });
        if (this._runtimeTypecheck) {
            this.emitLine("//");
            this.emitLine("// These functions will throw an error if the JSON doesn't");
            this.emitLine("// match the expected interface, even if the JSON is valid.");
        }
    };
    JavaScriptRenderer.prototype.emitModuleExports = function () {
        var _this = this;
        this.ensureBlankLine();
        this.emitBlock("module.exports = ", ";", function () {
            _this.forEachTopLevel("none", function (_, name) {
                var serializer = _this.serializerFunctionName(name);
                var deserializer = _this.deserializerFunctionName(name);
                _this.emitLine('"', serializer, '": ', serializer, ",");
                _this.emitLine('"', deserializer, '": ', deserializer, ",");
            });
        });
    };
    JavaScriptRenderer.prototype.emitSourceStructure = function () {
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else {
            this.emitUsageComments();
        }
        this.emitTypes();
        this.emitConvertModule();
        this.emitModuleExports();
    };
    return JavaScriptRenderer;
}(ConvenienceRenderer_1.ConvenienceRenderer));
exports.JavaScriptRenderer = JavaScriptRenderer;
