"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var unicode = require("unicode-properties");
var Source_1 = require("../../Source");
var Naming_1 = require("../../Naming");
var ConvenienceRenderer_1 = require("../../ConvenienceRenderer");
var TargetLanguage_1 = require("../../TargetLanguage");
var RendererOptions_1 = require("../../RendererOptions");
var keywords = require("./keywords");
var Type_1 = require("../../Type");
var TypeUtils_1 = require("../../TypeUtils");
var Strings_1 = require("../../Strings");
function unicodeEscape(codePoint) {
    return "\\u{" + Strings_1.intToHex(codePoint, 0) + "}";
}
var stringEscape = Strings_1.utf32ConcatMap(Strings_1.escapeNonPrintableMapper(Strings_1.isPrintable, unicodeEscape));
var Strictness;
(function (Strictness) {
    Strictness["Strict"] = "Strict::";
    Strictness["Coercible"] = "Coercible::";
    Strictness["None"] = "Types::";
})(Strictness = exports.Strictness || (exports.Strictness = {}));
var RubyTargetLanguage = /** @class */ (function (_super) {
    __extends(RubyTargetLanguage, _super);
    function RubyTargetLanguage() {
        var _this = _super.call(this, "Ruby", ["ruby"], "rb") || this;
        _this._justTypesOption = new RendererOptions_1.BooleanOption("just-types", "Plain types only", false);
        _this._strictnessOption = new RendererOptions_1.EnumOption("strictness", "Type strictness", [
            ["strict", Strictness.Strict],
            ["coercible", Strictness.Coercible],
            ["none", Strictness.None]
        ]);
        return _this;
    }
    RubyTargetLanguage.prototype.getOptions = function () {
        return [this._justTypesOption, this._strictnessOption];
    };
    Object.defineProperty(RubyTargetLanguage.prototype, "supportsOptionalClassProperties", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RubyTargetLanguage.prototype, "defaultIndentation", {
        get: function () {
            return "  ";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RubyTargetLanguage.prototype, "rendererClass", {
        get: function () {
            return RubyRenderer;
        },
        enumerable: true,
        configurable: true
    });
    return RubyTargetLanguage;
}(TargetLanguage_1.TargetLanguage));
exports.default = RubyTargetLanguage;
function isStartCharacter(utf16Unit) {
    return unicode.isAlphabetic(utf16Unit) || utf16Unit === 0x5f; // underscore
}
function isPartCharacter(utf16Unit) {
    var category = unicode.getCategory(utf16Unit);
    return lodash_1.includes(["Nd", "Pc", "Mn", "Mc"], category) || isStartCharacter(utf16Unit);
}
var legalizeName = Strings_1.legalizeCharacters(isPartCharacter);
function simpleNameStyle(original, uppercase) {
    var words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
}
function memberNameStyle(original) {
    var words = Strings_1.splitIntoWords(original);
    return Strings_1.combineWords(words, legalizeName, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, "_", isStartCharacter);
}
var RubyRenderer = /** @class */ (function (_super) {
    __extends(RubyRenderer, _super);
    function RubyRenderer(targetLanguage, graph, leadingComments, _justTypes, _strictness) {
        var _this = _super.call(this, targetLanguage, graph, leadingComments) || this;
        _this._justTypes = _justTypes;
        _this._strictness = _strictness;
        return _this;
    }
    Object.defineProperty(RubyRenderer.prototype, "commentLineStart", {
        get: function () {
            return "# ";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RubyRenderer.prototype, "needsTypeDeclarationBeforeUse", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    RubyRenderer.prototype.canBeForwardDeclared = function (t) {
        return "class" === t.kind;
    };
    RubyRenderer.prototype.forbiddenNamesForGlobalNamespace = function () {
        return keywords.globals.concat(["Types", "JSON", "Dry", "Constructor"]);
    };
    RubyRenderer.prototype.forbiddenForObjectProperties = function (_c, _classNamed) {
        return { names: keywords.reservedProperties, includeGlobalForbidden: true };
    };
    RubyRenderer.prototype.makeNamedTypeNamer = function () {
        return new Naming_1.Namer("types", function (n) { return simpleNameStyle(n, true); }, []);
    };
    RubyRenderer.prototype.namerForObjectProperty = function () {
        return new Naming_1.Namer("properties", memberNameStyle, []);
    };
    RubyRenderer.prototype.makeUnionMemberNamer = function () {
        return new Naming_1.Namer("properties", memberNameStyle, []);
    };
    RubyRenderer.prototype.makeEnumCaseNamer = function () {
        return new Naming_1.Namer("enum-cases", function (n) { return simpleNameStyle(n, true); }, []);
    };
    RubyRenderer.prototype.dryType = function (t, isOptional) {
        var _this = this;
        if (isOptional === void 0) { isOptional = false; }
        var optional = isOptional ? ".optional" : "";
        return TypeUtils_1.matchType(t, function (_anyType) { return ["Types::Any", optional]; }, function (_nullType) { return ["Types::Nil", optional]; }, function (_boolType) { return ["Types::Bool", optional]; }, function (_integerType) { return ["Types::Int", optional]; }, function (_doubleType) { return ["Types::Double", optional]; }, function (_stringType) { return ["Types::String", optional]; }, function (arrayType) { return ["Types.Array(", _this.dryType(arrayType.items), ")", optional]; }, function (classType) { return [_this.nameForNamedType(classType), optional]; }, function (mapType) { return ["Types::Hash.meta(of: ", _this.dryType(mapType.values), ")", optional]; }, function (enumType) { return ["Types::", _this.nameForNamedType(enumType), optional]; }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                return [_this.dryType(nullable), ".optional"];
            }
            return ["Types.Instance(", _this.nameForNamedType(unionType), ")", optional];
        });
    };
    RubyRenderer.prototype.exampleUse = function (t, exp, depth, optional) {
        var _this = this;
        if (depth === void 0) { depth = 6; }
        if (optional === void 0) { optional = false; }
        if (depth-- <= 0) {
            return exp;
        }
        var safeNav = optional ? "&" : "";
        return TypeUtils_1.matchType(t, function (_anyType) { return exp; }, function (_nullType) { return [exp, ".nil?"]; }, function (_boolType) { return exp; }, function (_integerType) { return [exp, ".even?"]; }, function (_doubleType) { return exp; }, function (_stringType) { return exp; }, function (arrayType) { return _this.exampleUse(arrayType.items, [exp, safeNav, ".first"], depth); }, function (classType) {
            var info;
            _this.forEachClassProperty(classType, "none", function (name, _json, prop) {
                if (lodash_1.includes(["class", "map", "array"], prop.type.kind)) {
                    info = { name: name, prop: prop };
                }
                else if (info === undefined) {
                    info = { name: name, prop: prop };
                }
            });
            if (info !== undefined) {
                return _this.exampleUse(info.prop.type, [exp, safeNav, ".", info.name], depth, info.prop.isOptional);
            }
            return exp;
        }, function (mapType) { return _this.exampleUse(mapType.values, [exp, safeNav, "[\"\u2026\"]"], depth); }, function (enumType) {
            var name;
            // FIXME: This is a terrible way to get the first enum case name.
            _this.forEachEnumCase(enumType, "none", function (theName) {
                if (name === undefined) {
                    name = theName;
                }
            });
            if (name !== undefined) {
                return [exp, " == ", _this.nameForNamedType(enumType), "::", name];
            }
            return exp;
        }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                if (["class", "map", "array"].indexOf(nullable.kind) >= 0) {
                    return _this.exampleUse(nullable, exp, depth, true);
                }
                return [exp, ".nil?"];
            }
            return exp;
        });
    };
    RubyRenderer.prototype.jsonSample = function (t) {
        function inner() {
            if (t instanceof Type_1.ArrayType) {
                return "[…]";
            }
            else if (t instanceof Type_1.MapType) {
                return "{…}";
            }
            else if (t instanceof Type_1.ClassType) {
                return "{…}";
            }
            else {
                return "…";
            }
        }
        return "\"" + inner() + "\"";
    };
    RubyRenderer.prototype.fromDynamic = function (t, e, optional, castPrimitives) {
        var _this = this;
        if (optional === void 0) { optional = false; }
        if (castPrimitives === void 0) { castPrimitives = false; }
        var primitiveCast = [this.dryType(t, optional), "[", e, "]"];
        var primitive = castPrimitives ? primitiveCast : e;
        var safeAccess = optional ? "&" : "";
        return TypeUtils_1.matchType(t, function (_anyType) { return primitive; }, function (_nullType) { return primitive; }, function (_boolType) { return primitive; }, function (_integerType) { return primitive; }, function (_doubleType) { return primitive; }, function (_stringType) { return primitive; }, function (arrayType) { return [e, safeAccess, ".map { |x| ", _this.fromDynamic(arrayType.items, "x", false, true), " }"]; }, function (classType) {
            var expression = [_this.nameForNamedType(classType), ".from_dynamic!(", e, ")"];
            return optional ? [e, " ? ", expression, " : nil"] : expression;
        }, function (mapType) { return [
            ["Types::Hash", optional ? ".optional" : "", "[", e, "]"],
            safeAccess,
            ".map { |k, v| [k, ",
            _this.fromDynamic(mapType.values, "v", false, true),
            "] }",
            safeAccess,
            ".to_h"
        ]; }, function (enumType) {
            var expression = ["Types::", _this.nameForNamedType(enumType), "[", e, "]"];
            return optional ? [e, ".nil? ? nil : ", expression] : expression;
        }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                return _this.fromDynamic(nullable, e, true);
            }
            var expression = [_this.nameForNamedType(unionType), ".from_dynamic!(", e, ")"];
            return optional ? [e, " ? ", expression, " : nil"] : expression;
        });
    };
    RubyRenderer.prototype.toDynamic = function (t, e, optional) {
        var _this = this;
        if (optional === void 0) { optional = false; }
        if (this.marshalsImplicitlyToDynamic(t)) {
            return e;
        }
        return TypeUtils_1.matchType(t, function (_anyType) { return e; }, function (_nullType) { return e; }, function (_boolType) { return e; }, function (_integerType) { return e; }, function (_doubleType) { return e; }, function (_stringType) { return e; }, function (arrayType) { return [e, optional ? "&" : "", ".map { |x| ", _this.toDynamic(arrayType.items, "x"), " }"]; }, function (_classType) { return [e, optional ? "&" : "", ".to_dynamic"]; }, function (mapType) { return [e, optional ? "&" : "", ".map { |k, v| [k, ", _this.toDynamic(mapType.values, "v"), "] }.to_h"]; }, function (_enumType) { return e; }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                return _this.toDynamic(nullable, e, true);
            }
            if (_this.marshalsImplicitlyToDynamic(unionType)) {
                return e;
            }
            return [e, optional ? "&" : "", ".to_dynamic"];
        });
    };
    RubyRenderer.prototype.marshalsImplicitlyToDynamic = function (t) {
        var _this = this;
        return TypeUtils_1.matchType(t, function (_anyType) { return true; }, function (_nullType) { return true; }, function (_boolType) { return true; }, function (_integerType) { return true; }, function (_doubleType) { return true; }, function (_stringType) { return true; }, function (arrayType) { return _this.marshalsImplicitlyToDynamic(arrayType.items); }, function (_classType) { return false; }, function (mapType) { return _this.marshalsImplicitlyToDynamic(mapType.values); }, function (_enumType) { return true; }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                return _this.marshalsImplicitlyToDynamic(nullable);
            }
            return false;
        });
    };
    // This is only to be used to allow class properties to possibly
    // marshal implicitly. They are allowed to do this because they will
    // be checked in Dry::Struct.new
    RubyRenderer.prototype.propertyTypeMarshalsImplicitlyFromDynamic = function (t) {
        var _this = this;
        return TypeUtils_1.matchType(t, function (_anyType) { return true; }, function (_nullType) { return true; }, function (_boolType) { return true; }, function (_integerType) { return true; }, function (_doubleType) { return true; }, function (_stringType) { return true; }, function (arrayType) { return _this.propertyTypeMarshalsImplicitlyFromDynamic(arrayType.items); }, function (_classType) { return false; }, 
        // Map properties must be checked because Dry:Types doesn't have a generic Map
        function (_mapType) { return false; }, function (_enumType) { return true; }, function (unionType) {
            var nullable = TypeUtils_1.nullableFromUnion(unionType);
            if (nullable !== null) {
                return _this.propertyTypeMarshalsImplicitlyFromDynamic(nullable);
            }
            return false;
        });
    };
    RubyRenderer.prototype.emitBlock = function (source, emit) {
        this.emitLine(source);
        this.indent(emit);
        this.emitLine("end");
    };
    RubyRenderer.prototype.emitClass = function (c, className) {
        var _this = this;
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock(["class ", className, " < Dry::Struct"], function () {
            var table = [];
            var count = c.getProperties().size;
            _this.forEachClassProperty(c, "none", function (name, jsonName, p) {
                var last = --count === 0;
                var description = _this.descriptionForClassProperty(c, jsonName);
                var attribute = [
                    ["attribute :", name, ","],
                    [" ", _this.dryType(p.type), p.isOptional ? ".optional" : ""]
                ];
                if (description !== undefined) {
                    if (table.length > 0) {
                        _this.emitTable(table);
                        table = [];
                    }
                    _this.ensureBlankLine();
                    _this.emitDescriptionBlock(description);
                    _this.emitLine(attribute);
                    if (!last) {
                        _this.ensureBlankLine();
                    }
                }
                else {
                    table.push(attribute);
                }
            });
            if (table.length > 0) {
                _this.emitTable(table);
            }
            if (_this._justTypes) {
                return;
            }
            _this.ensureBlankLine();
            _this.emitBlock(["def self.from_dynamic!(d)"], function () {
                _this.emitLine("d = Types::Hash[d]");
                _this.emitLine("new(");
                _this.indent(function () {
                    var inits = [];
                    _this.forEachClassProperty(c, "none", function (name, jsonName, p) {
                        var dynamic = p.isOptional
                            ? // If key is not found in hash, this will be nil
                                "d[\"" + stringEscape(jsonName) + "\"]"
                            : // This will raise a runtime error if the key is not found in the hash
                                "d.fetch(\"" + stringEscape(jsonName) + "\")";
                        if (_this.propertyTypeMarshalsImplicitlyFromDynamic(p.type)) {
                            inits.push([[name, ": "], [dynamic, ","]]);
                        }
                        else {
                            var expression = _this.fromDynamic(p.type, dynamic, p.isOptional);
                            inits.push([[name, ": "], [expression, ","]]);
                        }
                    });
                    _this.emitTable(inits);
                });
                _this.emitLine(")");
            });
            _this.ensureBlankLine();
            _this.emitBlock("def self.from_json!(json)", function () {
                _this.emitLine("from_dynamic!(JSON.parse(json))");
            });
            _this.ensureBlankLine();
            _this.emitBlock(["def to_dynamic"], function () {
                _this.emitLine("{");
                _this.indent(function () {
                    var inits = [];
                    _this.forEachClassProperty(c, "none", function (name, jsonName, p) {
                        var expression = _this.toDynamic(p.type, ["@", name], p.isOptional);
                        inits.push([["\"" + stringEscape(jsonName) + "\""], [" => ", expression, ","]]);
                    });
                    _this.emitTable(inits);
                });
                _this.emitLine("}");
            });
            _this.ensureBlankLine();
            _this.emitBlock("def to_json(options = nil)", function () {
                _this.emitLine("JSON.generate(to_dynamic, options)");
            });
        });
    };
    RubyRenderer.prototype.emitEnum = function (e, enumName) {
        var _this = this;
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["module ", enumName], function () {
            var table = [];
            _this.forEachEnumCase(e, "none", function (name, json) {
                table.push([[name], [" = \"" + stringEscape(json) + "\""]]);
            });
            _this.emitTable(table);
        });
    };
    RubyRenderer.prototype.emitUnion = function (u, unionName) {
        var _this = this;
        this.emitDescription(this.descriptionForType(u));
        this.emitBlock(["class ", unionName, " < Dry::Struct"], function () {
            var table = [];
            _this.forEachUnionMember(u, u.getChildren(), "none", null, function (name, t) {
                table.push([["attribute :", name, ", "], [_this.dryType(t, true)]]);
            });
            _this.emitTable(table);
            if (_this._justTypes) {
                return;
            }
            _this.ensureBlankLine();
            var _a = TypeUtils_1.removeNullFromUnion(u, false), maybeNull = _a[0], nonNulls = _a[1];
            _this.emitBlock("def self.from_dynamic!(d)", function () {
                var memberNames = u.getChildren().map(function (member) { return _this.nameForUnionMember(u, member); });
                _this.forEachUnionMember(u, u.getChildren(), "none", null, function (name, t) {
                    var nilMembers = memberNames
                        .remove(name)
                        .toArray()
                        .map(function (memberName) { return [", ", memberName, ": nil"]; });
                    if (_this.propertyTypeMarshalsImplicitlyFromDynamic(t)) {
                        _this.emitBlock(["if schema[:", name, "].right.valid? d"], function () {
                            _this.emitLine("return new(", name, ": d", nilMembers, ")");
                        });
                    }
                    else {
                        _this.emitLine("begin");
                        _this.indent(function () {
                            _this.emitLine("value = ", _this.fromDynamic(t, "d"));
                            _this.emitBlock(["if schema[:", name, "].right.valid? value"], function () {
                                _this.emitLine("return new(", name, ": value", nilMembers, ")");
                            });
                        });
                        _this.emitLine("rescue");
                        _this.emitLine("end");
                    }
                });
                _this.emitLine("raise \"Invalid union\"");
            });
            _this.ensureBlankLine();
            _this.emitBlock("def self.from_json!(json)", function () {
                _this.emitLine("from_dynamic!(JSON.parse(json))");
            });
            _this.ensureBlankLine();
            _this.emitBlock("def to_dynamic", function () {
                var first = true;
                _this.forEachUnionMember(u, nonNulls, "none", null, function (name, t) {
                    _this.emitLine(first ? "if" : "elsif", " @", name, " != nil");
                    _this.indent(function () {
                        _this.emitLine(_this.toDynamic(t, ["@", name]));
                    });
                    first = false;
                });
                if (maybeNull !== null) {
                    _this.emitLine("else");
                    _this.indent(function () {
                        _this.emitLine("nil");
                    });
                }
                _this.emitLine("end");
            });
            _this.ensureBlankLine();
            _this.emitBlock("def to_json(options = nil)", function () {
                _this.emitLine("JSON.generate(to_dynamic, options)");
            });
        });
    };
    RubyRenderer.prototype.emitTypesModule = function () {
        var _this = this;
        this.emitBlock(["module Types"], function () {
            _this.emitLine("include Dry::Types.module");
            var declarations = [];
            if (_this._strictness !== Strictness.None) {
                var has_1 = { int: false, nil: false, bool: false, hash: false, string: false, double: false };
                _this.forEachType(function (t) {
                    has_1 = {
                        int: has_1.int || t.kind === "integer",
                        nil: has_1.nil || t.kind === "null",
                        bool: has_1.bool || t.kind === "bool",
                        hash: has_1.hash || t.kind === "map" || t.kind === "class",
                        string: has_1.string || t.kind === "string" || t.kind === "enum",
                        double: has_1.double || t.kind === "double"
                    };
                });
                if (has_1.int)
                    declarations.push([["Int"], [" = " + _this._strictness + "Int"]]);
                if (_this._strictness === Strictness.Strict) {
                    if (has_1.nil)
                        declarations.push([["Nil"], [" = " + _this._strictness + "Nil"]]);
                }
                if (has_1.bool)
                    declarations.push([["Bool"], [" = " + _this._strictness + "Bool"]]);
                if (has_1.hash)
                    declarations.push([["Hash"], [" = " + _this._strictness + "Hash"]]);
                if (has_1.string)
                    declarations.push([["String"], [" = " + _this._strictness + "String"]]);
                if (has_1.double)
                    declarations.push([["Double"], [" = " + _this._strictness + "Float | " + _this._strictness + "Int"]]);
            }
            _this.forEachEnum("none", function (enumType, enumName) {
                var cases = [];
                _this.forEachEnumCase(enumType, "none", function (_name, json) {
                    cases.push([cases.length === 0 ? "" : ", ", "\"" + stringEscape(json) + "\""]);
                });
                declarations.push([[enumName], [" = ", _this._strictness, "String.enum("].concat(cases, [")"])]);
            });
            if (declarations.length > 0) {
                _this.ensureBlankLine();
                _this.emitTable(declarations);
            }
        });
    };
    RubyRenderer.prototype.emitSourceStructure = function () {
        var _this = this;
        if (this.leadingComments !== undefined) {
            this.emitCommentLines(this.leadingComments);
        }
        else if (!this._justTypes) {
            this.emitLine("# This code may look unusually verbose for Ruby (and it is), but");
            this.emitLine("# it performs some subtle and complex validation of JSON data.");
            this.emitLine("#");
            this.emitLine("# To parse this JSON, add 'dry-struct' and 'dry-types' gems, then do:");
            this.emitLine("#");
            this.forEachTopLevel("none", function (topLevel, name) {
                var variable = Source_1.modifySource(lodash_1.snakeCase, name);
                _this.emitLine("#   ", variable, " = ", name, ".from_json! ", _this.jsonSample(topLevel));
                _this.emitLine("#   puts ", _this.exampleUse(topLevel, variable));
                _this.emitLine("#");
            });
            this.emitLine("# If from_json! succeeds, the value returned matches the schema.");
        }
        this.ensureBlankLine();
        this.emitLine("require 'json'");
        this.emitLine("require 'dry-types'");
        this.emitLine("require 'dry-struct'");
        this.ensureBlankLine();
        this.emitTypesModule();
        this.forEachDeclaration("leading-and-interposing", function (decl) {
            if (decl.kind === "forward") {
                _this.emitCommentLines(["(forward declaration)"]);
                _this.emitLine("class ", _this.nameForNamedType(decl.type), " < Dry::Struct; end");
            }
        });
        this.forEachNamedType("leading-and-interposing", function (c, n) { return _this.emitClass(c, n); }, function (e, n) { return _this.emitEnum(e, n); }, function (u, n) { return _this.emitUnion(u, n); });
        if (!this._justTypes) {
            this.forEachTopLevel("leading-and-interposing", function (topLevel, name) {
                var self = Source_1.modifySource(lodash_1.snakeCase, name);
                // The json gem defines to_json on maps and primitives, so we only need to supply
                // it for arrays.
                var needsToJsonDefined = "array" === topLevel.kind;
                _this.emitBlock(["class ", name], function () {
                    _this.emitBlock(["def self.from_json!(json)"], function () {
                        if (needsToJsonDefined) {
                            _this.emitLine(self, " = ", _this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                            _this.emitBlock([self, ".define_singleton_method(:to_json) do"], function () {
                                _this.emitLine("JSON.generate(", _this.toDynamic(topLevel, "self"), ")");
                            });
                            _this.emitLine(self);
                        }
                        else {
                            _this.emitLine(_this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                        }
                    });
                });
            }, function (t) { return _this.namedTypeToNameForTopLevel(t) === undefined; });
        }
    };
    return RubyRenderer;
}(ConvenienceRenderer_1.ConvenienceRenderer));
exports.RubyRenderer = RubyRenderer;
