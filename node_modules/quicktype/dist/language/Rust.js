"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TargetLanguage_1 = require("../TargetLanguage");
var ConvenienceRenderer_1 = require("../ConvenienceRenderer");
var Strings_1 = require("../Strings");
var Naming_1 = require("../Naming");
var TypeUtils_1 = require("../TypeUtils");
var Source_1 = require("../Source");
var Annotation_1 = require("../Annotation");
var RendererOptions_1 = require("../RendererOptions");
var Support_1 = require("../Support");
var Density;
(function (Density) {
    Density[Density["Normal"] = 0] = "Normal";
    Density[Density["Dense"] = 1] = "Dense";
})(Density = exports.Density || (exports.Density = {}));
var Visibility;
(function (Visibility) {
    Visibility[Visibility["Private"] = 0] = "Private";
    Visibility[Visibility["Crate"] = 1] = "Crate";
    Visibility[Visibility["Public"] = 2] = "Public";
})(Visibility = exports.Visibility || (exports.Visibility = {}));
var RustTargetLanguage = /** @class */ (function (_super) {
    __extends(RustTargetLanguage, _super);
    function RustTargetLanguage() {
        var _this = _super.call(this, "Rust", ["rs", "rust", "rustlang"], "rs") || this;
        _this._denseOption = new RendererOptions_1.EnumOption("density", "Density", [
            ["normal", Density.Normal],
            ["dense", Density.Dense]
        ]);
        _this._visibilityOption = new RendererOptions_1.EnumOption("visibility", "Field visibility", [
            ["private", Visibility.Private],
            ["crate", Visibility.Crate],
            ["public", Visibility.Public]
        ]);
        _this._deriveDebugOption = new RendererOptions_1.BooleanOption("derive-debug", "Derive Debug impl", false);
        return _this;
    }
    Object.defineProperty(RustTargetLanguage.prototype, "rendererClass", {
        get: function () {
            return RustRenderer;
        },
        enumerable: true,
        configurable: true
    });
    RustTargetLanguage.prototype.getOptions = function () {
        return [this._denseOption, this._visibilityOption, this._deriveDebugOption];
    };
    return RustTargetLanguage;
}(TargetLanguage_1.TargetLanguage));
exports.default = RustTargetLanguage;
var keywords = [
    // Special reserved identifiers used internally for elided lifetimes,
    // unnamed method parameters, crate root module, error recovery etc.
    "{{root}}",
    "$crate",
    // Keywords used in the language.
    "as",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "else",
    "enum",
    "extern",
    "false",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "match",
    "mod",
    "move",
    "mut",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "type",
    "unsafe",
    "use",
    "where",
    "while",
    // Keywords reserved for future use.
    "abstract",
    "alignof",
    "become",
    "do",
    "final",
    "macro",
    "offsetof",
    "override",
    "priv",
    "proc",
    "pure",
    "sizeof",
    "typeof",
    "unsized",
    "virtual",
    "yield",
    // Weak keywords, have special meaning only in specific contexts.
    "catch",
    "default",
    "dyn",
    "'static",
    "union"
];
var isAsciiLetterOrUnderscoreOrDigit = function (codePoint) {
    if (!Strings_1.isAscii(codePoint)) {
        return false;
    }
    return Strings_1.isLetterOrUnderscoreOrDigit(codePoint);
};
var isAsciiLetterOrUnderscore = function (codePoint) {
    if (!Strings_1.isAscii(codePoint)) {
        return false;
    }
    return Strings_1.isLetterOrUnderscore(codePoint);
};
var legalizeName = Strings_1.legalizeCharacters(isAsciiLetterOrUnderscoreOrDigit);
function rustStyle(original, isSnakeCase) {
    var words = Strings_1.splitIntoWords(original);
    var wordStyle = isSnakeCase ? Strings_1.allLowerWordStyle : Strings_1.firstUpperWordStyle;
    var combined = Strings_1.combineWords(words, legalizeName, wordStyle, wordStyle, wordStyle, wordStyle, isSnakeCase ? "_" : "", isAsciiLetterOrUnderscore);
    return combined === "_" ? "_underscore" : combined;
}
var snakeNamingFunction = Naming_1.funPrefixNamer("default", function (original) { return rustStyle(original, true); });
var camelNamingFunction = Naming_1.funPrefixNamer("camel", function (original) { return rustStyle(original, false); });
var standardUnicodeRustEscape = function (codePoint) {
    if (codePoint <= 0xffff) {
        return "\\u{" + Strings_1.intToHex(codePoint, 4) + "}";
    }
    else {
        return "\\u{" + Strings_1.intToHex(codePoint, 6) + "}";
    }
};
var rustStringEscape = Strings_1.utf32ConcatMap(Strings_1.escapeNonPrintableMapper(Strings_1.isPrintable, standardUnicodeRustEscape));
var RustRenderer = /** @class */ (function (_super) {
    __extends(RustRenderer, _super);
    function RustRenderer(targetLanguage, graph, leadingComments, _density, _visibility, _deriveDebug) {
        var _this = _super.call(this, targetLanguage, graph, leadingComments) || this;
        _this._density = _density;
        _this._visibility = _visibility;
        _this._deriveDebug = _deriveDebug;
        _this.nullableRustType = function (t, withIssues) {
            return ["Option<", _this.breakCycle(t, withIssues), ">"];
        };
        _this.rustType = function (t, withIssues) {
            if (withIssues === void 0) { withIssues = false; }
            return TypeUtils_1.matchType(t, function (_anyType) { return Source_1.maybeAnnotated(withIssues, Annotation_1.anyTypeIssueAnnotation, "Option<serde_json::Value>"); }, function (_nullType) { return Source_1.maybeAnnotated(withIssues, Annotation_1.nullTypeIssueAnnotation, "Option<serde_json::Value>"); }, function (_boolType) { return "bool"; }, function (_integerType) { return "i64"; }, function (_doubleType) { return "f64"; }, function (_stringType) { return "String"; }, function (arrayType) { return ["Vec<", _this.rustType(arrayType.items, withIssues), ">"]; }, function (classType) { return _this.nameForNamedType(classType); }, function (mapType) { return ["HashMap<String, ", _this.rustType(mapType.values, withIssues), ">"]; }, function (enumType) { return _this.nameForNamedType(enumType); }, function (unionType) {
                var nullable = TypeUtils_1.nullableFromUnion(unionType);
                if (nullable !== null)
                    return _this.nullableRustType(nullable, withIssues);
                var hasNull = TypeUtils_1.removeNullFromUnion(unionType)[0];
                var isCycleBreaker = _this.isCycleBreakerType(unionType);
                var name = isCycleBreaker
                    ? ["Box<", _this.nameForNamedType(unionType), ">"]
                    : _this.nameForNamedType(unionType);
                return hasNull !== null ? ["Option<", name, ">"] : name;
            });
        };
        _this.breakCycle = function (t, withIssues) {
            var rustType = _this.rustType(t, withIssues);
            var isCycleBreaker = _this.isCycleBreakerType(t);
            return isCycleBreaker ? ["Box<", rustType, ">"] : rustType;
        };
        return _this;
    }
    RustRenderer.prototype.makeNamedTypeNamer = function () {
        return camelNamingFunction;
    };
    RustRenderer.prototype.namerForObjectProperty = function () {
        return snakeNamingFunction;
    };
    RustRenderer.prototype.makeUnionMemberNamer = function () {
        return camelNamingFunction;
    };
    RustRenderer.prototype.makeEnumCaseNamer = function () {
        return camelNamingFunction;
    };
    RustRenderer.prototype.forbiddenNamesForGlobalNamespace = function () {
        return keywords;
    };
    RustRenderer.prototype.forbiddenForObjectProperties = function (_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    };
    RustRenderer.prototype.forbiddenForUnionMembers = function (_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
    };
    RustRenderer.prototype.forbiddenForEnumCases = function (_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    };
    Object.defineProperty(RustRenderer.prototype, "commentLineStart", {
        get: function () {
            return "/// ";
        },
        enumerable: true,
        configurable: true
    });
    RustRenderer.prototype.isImplicitCycleBreaker = function (t) {
        var kind = t.kind;
        return kind === "array" || kind === "map";
    };
    RustRenderer.prototype.emitRenameAttribute = function (propName, jsonName) {
        var escapedName = rustStringEscape(jsonName);
        var namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        if (namesDiffer || this._density === Density.Normal) {
            this.emitLine('#[serde(rename = "', escapedName, '")]');
        }
    };
    Object.defineProperty(RustRenderer.prototype, "visibility", {
        get: function () {
            if (this._visibility === Visibility.Crate) {
                return "pub(crate) ";
            }
            else if (this._visibility === Visibility.Public) {
                return "pub ";
            }
            return "";
        },
        enumerable: true,
        configurable: true
    });
    RustRenderer.prototype.emitStructDefinition = function (c, className) {
        var _this = this;
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("#[derive(", this._deriveDebug ? "Debug, " : "", "Serialize, Deserialize)]");
        var blankLines = this._density === Density.Dense ? "none" : "interposing";
        var structBody = function () {
            return _this.forEachClassProperty(c, blankLines, function (name, jsonName, prop) {
                _this.emitDescription(_this.descriptionForClassProperty(c, jsonName));
                _this.emitRenameAttribute(name, jsonName);
                _this.emitLine(_this.visibility, name, ": ", _this.breakCycle(prop.type, true), ",");
            });
        };
        this.emitBlock(["pub struct ", className], structBody);
    };
    RustRenderer.prototype.emitBlock = function (line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    };
    RustRenderer.prototype.emitUnion = function (u, unionName) {
        var _this = this;
        var isMaybeWithSingleType = TypeUtils_1.nullableFromUnion(u);
        if (isMaybeWithSingleType !== null) {
            return;
        }
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("#[derive(", this._deriveDebug ? "Debug, " : "", "Serialize, Deserialize)]");
        this.emitLine("#[serde(untagged)]");
        var _a = TypeUtils_1.removeNullFromUnion(u), nonNulls = _a[1];
        var blankLines = this._density === Density.Dense ? "none" : "interposing";
        this.emitBlock(["pub enum ", unionName], function () {
            return _this.forEachUnionMember(u, nonNulls, blankLines, null, function (fieldName, t) {
                var rustType = _this.breakCycle(t, true);
                _this.emitLine([fieldName, "(", rustType, "),"]);
            });
        });
    };
    RustRenderer.prototype.emitEnumDefinition = function (e, enumName) {
        var _this = this;
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("#[derive(", this._deriveDebug ? "Debug, " : "", "Serialize, Deserialize)]");
        var blankLines = this._density === Density.Dense ? "none" : "interposing";
        this.emitBlock(["pub enum ", enumName], function () {
            return _this.forEachEnumCase(e, blankLines, function (name, jsonName) {
                _this.emitRenameAttribute(name, jsonName);
                _this.emitLine([name, ","]);
            });
        });
    };
    RustRenderer.prototype.emitTopLevelAlias = function (t, name) {
        this.emitLine("pub type ", name, " = ", this.rustType(t), ";");
    };
    RustRenderer.prototype.emitUsageExample = function () {
        var topLevelName = Support_1.defined(this.topLevels.keySeq().first());
        this.emitMultiline("// Example code that deserializes and serializes the model.\n// extern crate serde;\n// #[macro_use]\n// extern crate serde_derive;\n// extern crate serde_json;\n//\n// use generated_module::" + topLevelName + ";\n//\n// fn main() {\n//     let json = r#\"{\"answer\": 42}\"#;\n//     let model: " + topLevelName + " = serde_json::from_str(&json).unwrap();\n// }");
    };
    RustRenderer.prototype.emitSourceStructure = function () {
        var _this = this;
        this.emitUsageExample();
        this.emitLine();
        this.emitLine("extern crate serde_json;");
        if (this.haveMaps) {
            this.emitLine("use std::collections::HashMap;");
        }
        this.forEachTopLevel("leading", function (t, name) { return _this.emitTopLevelAlias(t, name); }, function (t) { return _this.namedTypeToNameForTopLevel(t) === undefined; });
        this.forEachObject("leading-and-interposing", function (c, name) { return _this.emitStructDefinition(c, name); });
        this.forEachUnion("leading-and-interposing", function (u, name) { return _this.emitUnion(u, name); });
        this.forEachEnum("leading-and-interposing", function (e, name) { return _this.emitEnumDefinition(e, name); });
    };
    return RustRenderer;
}(ConvenienceRenderer_1.ConvenienceRenderer));
exports.RustRenderer = RustRenderer;
