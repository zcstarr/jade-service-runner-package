"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("./Type");
var TypeUtils_1 = require("./TypeUtils");
var Support_1 = require("./Support");
var TypeBuilder_1 = require("./TypeBuilder");
var GraphRewriting_1 = require("./GraphRewriting");
var TypeNames_1 = require("./TypeNames");
var Graph_1 = require("./Graph");
var Messages_1 = require("./Messages");
var TypeAttributeStore = /** @class */ (function () {
    function TypeAttributeStore(_typeGraph, _values) {
        this._typeGraph = _typeGraph;
        this._values = _values;
        this._topLevelValues = immutable_1.Map();
    }
    TypeAttributeStore.prototype.getTypeIndex = function (t) {
        var tref = t.typeRef;
        Support_1.assert(tref.graph === this._typeGraph, "Using the wrong type attribute store");
        return tref.index;
    };
    TypeAttributeStore.prototype.attributesForType = function (t) {
        var index = this.getTypeIndex(t);
        var maybeAttributes = this._values[index];
        if (maybeAttributes !== undefined) {
            return maybeAttributes;
        }
        return immutable_1.Map();
    };
    TypeAttributeStore.prototype.attributesForTopLevel = function (name) {
        var maybeAttributes = this._topLevelValues.get(name);
        if (maybeAttributes !== undefined) {
            return maybeAttributes;
        }
        return immutable_1.Map();
    };
    TypeAttributeStore.prototype.setInMap = function (attributes, kind, value) {
        return attributes.set(kind, value);
    };
    TypeAttributeStore.prototype.set = function (kind, t, value) {
        var index = this.getTypeIndex(t);
        while (index >= this._values.length) {
            this._values.push(undefined);
        }
        this._values[index] = this.setInMap(this.attributesForType(t), kind, value);
    };
    TypeAttributeStore.prototype.setForTopLevel = function (kind, topLevelName, value) {
        this._topLevelValues = this._topLevelValues.set(topLevelName, this.setInMap(this.attributesForTopLevel(topLevelName), kind, value));
    };
    TypeAttributeStore.prototype.tryGetInMap = function (attributes, kind) {
        return attributes.get(kind);
    };
    TypeAttributeStore.prototype.tryGet = function (kind, t) {
        return this.tryGetInMap(this.attributesForType(t), kind);
    };
    TypeAttributeStore.prototype.tryGetForTopLevel = function (kind, topLevelName) {
        return this.tryGetInMap(this.attributesForTopLevel(topLevelName), kind);
    };
    return TypeAttributeStore;
}());
exports.TypeAttributeStore = TypeAttributeStore;
var TypeAttributeStoreView = /** @class */ (function () {
    function TypeAttributeStoreView(_attributeStore, _definition) {
        this._attributeStore = _attributeStore;
        this._definition = _definition;
    }
    TypeAttributeStoreView.prototype.set = function (t, value) {
        this._attributeStore.set(this._definition, t, value);
    };
    TypeAttributeStoreView.prototype.setForTopLevel = function (name, value) {
        this._attributeStore.setForTopLevel(this._definition, name, value);
    };
    TypeAttributeStoreView.prototype.tryGet = function (t) {
        return this._attributeStore.tryGet(this._definition, t);
    };
    TypeAttributeStoreView.prototype.get = function (t) {
        return Support_1.defined(this.tryGet(t));
    };
    TypeAttributeStoreView.prototype.tryGetForTopLevel = function (name) {
        return this._attributeStore.tryGetForTopLevel(this._definition, name);
    };
    TypeAttributeStoreView.prototype.getForTopLevel = function (name) {
        return Support_1.defined(this.tryGetForTopLevel(name));
    };
    return TypeAttributeStoreView;
}());
exports.TypeAttributeStoreView = TypeAttributeStoreView;
var TypeGraph = /** @class */ (function () {
    function TypeGraph(typeBuilder, _haveProvenanceAttributes) {
        var _this = this;
        this._haveProvenanceAttributes = _haveProvenanceAttributes;
        this._attributeStore = undefined;
        // FIXME: OrderedMap?  We lose the order in PureScript right now, though,
        // and maybe even earlier in the TypeScript driver.
        this._topLevels = immutable_1.Map();
        this._parents = undefined;
        this._printOnRewrite = false;
        this.allNamedTypes = function (childrenOfType) {
            return _this.filterTypes(TypeUtils_1.isNamedType, childrenOfType, true);
        };
        this.allNamedTypesSeparated = function (childrenOfType) {
            var types = _this.allNamedTypes(childrenOfType);
            return TypeUtils_1.separateNamedTypes(types);
        };
        this.allTypesUnordered = function () {
            Support_1.assert(_this.isFrozen, "Tried to get all graph types before it was frozen");
            return immutable_1.Set(Support_1.defined(_this._types));
        };
        this._typeBuilder = typeBuilder;
    }
    Object.defineProperty(TypeGraph.prototype, "isFrozen", {
        get: function () {
            return this._typeBuilder === undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeGraph.prototype, "attributeStore", {
        get: function () {
            return Support_1.defined(this._attributeStore);
        },
        enumerable: true,
        configurable: true
    });
    TypeGraph.prototype.freeze = function (topLevels, types, typeAttributes) {
        var _this = this;
        Support_1.assert(!this.isFrozen, "Tried to freeze TypeGraph a second time");
        Support_1.assert(types.every(function (t) { return t.typeRef.graph === _this; }), "Trying to freeze a graph with types that don't belong in it");
        this._attributeStore = new TypeAttributeStore(this, typeAttributes);
        // The order of these three statements matters.  If we set _typeBuilder
        // to undefined before we deref the TypeRefs, then we need to set _types
        // before, also, because the deref will call into typeAtIndex, which requires
        // either a _typeBuilder or a _types.
        this._types = types;
        this._typeBuilder = undefined;
        this._topLevels = topLevels.map(function (tref) { return tref.deref()[0]; });
    };
    Object.defineProperty(TypeGraph.prototype, "topLevels", {
        get: function () {
            Support_1.assert(this.isFrozen, "Cannot get top-levels from a non-frozen graph");
            return Support_1.defined(this._topLevels);
        },
        enumerable: true,
        configurable: true
    });
    TypeGraph.prototype.atIndex = function (index) {
        if (this._typeBuilder !== undefined) {
            return this._typeBuilder.atIndex(index);
        }
        var t = Support_1.defined(this._types)[index];
        return [t, Support_1.defined(this._attributeStore).attributesForType(t)];
    };
    TypeGraph.prototype.filterTypes = function (predicate, childrenOfType, topDown) {
        var seen = immutable_1.Set();
        var types = immutable_1.List();
        function addFromType(t) {
            if (seen.has(t))
                return;
            seen = seen.add(t);
            var required = predicate === undefined || predicate(t);
            if (topDown && required) {
                types = types.push(t);
            }
            var children = childrenOfType !== undefined ? childrenOfType(t) : t.getChildren();
            children.forEach(addFromType);
            if (!topDown && required) {
                types = types.push(t);
            }
        }
        this.topLevels.forEach(addFromType);
        return types.toOrderedSet();
    };
    TypeGraph.prototype.allProvenance = function () {
        Support_1.assert(this._haveProvenanceAttributes);
        var view = new TypeAttributeStoreView(this.attributeStore, TypeBuilder_1.provenanceTypeAttributeKind);
        return this.allTypesUnordered()
            .toList()
            .map(function (t) {
            var maybeSet = view.tryGet(t);
            if (maybeSet !== undefined)
                return maybeSet;
            return immutable_1.Set();
        })
            .reduce(function (a, b) { return a.union(b); });
    };
    TypeGraph.prototype.setPrintOnRewrite = function () {
        this._printOnRewrite = true;
    };
    TypeGraph.prototype.checkLostTypeAttributes = function (builder, newGraph) {
        if (!this._haveProvenanceAttributes || builder.lostTypeAttributes)
            return;
        var oldProvenance = this.allProvenance();
        var newProvenance = newGraph.allProvenance();
        if (oldProvenance.size !== newProvenance.size) {
            var difference = oldProvenance.subtract(newProvenance);
            var indexes = difference.map(function (tr) { return tr.index; }).toArray();
            return Messages_1.messageError("IRTypeAttributesNotPropagated", { count: difference.size, indexes: indexes });
        }
    };
    TypeGraph.prototype.printRewrite = function (title) {
        if (!this._printOnRewrite)
            return;
        console.log("\n# " + title);
    };
    // Each array in `replacementGroups` is a bunch of types to be replaced by a
    // single new type.  `replacer` is a function that takes a group and a
    // TypeBuilder, and builds a new type with that builder that replaces the group.
    // That particular TypeBuilder will have to take as inputs types in the old
    // graph, but return types in the new graph.  Recursive types must be handled
    // carefully.
    TypeGraph.prototype.rewrite = function (title, stringTypeMapping, alphabetizeProperties, replacementGroups, debugPrintReconstitution, replacer, force) {
        if (force === void 0) { force = false; }
        this.printRewrite(title);
        if (!force && replacementGroups.length === 0)
            return this;
        var builder = new GraphRewriting_1.GraphRewriteBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, replacementGroups, debugPrintReconstitution, replacer);
        var newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
            newGraph.setPrintOnRewrite();
            newGraph.printGraph();
        }
        if (!builder.didAddForwardingIntersection)
            return newGraph;
        Support_1.assert(!force, "We shouldn't have introduced forwarding intersections in a forced rewrite");
        return removeIndirectionIntersections(newGraph, stringTypeMapping, debugPrintReconstitution);
    };
    TypeGraph.prototype.remap = function (title, stringTypeMapping, alphabetizeProperties, map, debugPrintRemapping) {
        this.printRewrite(title);
        if (map.isEmpty())
            return this;
        var builder = new GraphRewriting_1.GraphRemapBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, map, debugPrintRemapping);
        var newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
            newGraph.setPrintOnRewrite();
            newGraph.printGraph();
        }
        Support_1.assert(!builder.didAddForwardingIntersection);
        return newGraph;
    };
    TypeGraph.prototype.garbageCollect = function (alphabetizeProperties, debugPrintReconstitution) {
        var newGraph = this.rewrite("GC", TypeBuilder_1.NoStringTypeMapping, alphabetizeProperties, [], debugPrintReconstitution, function (_t, _b) { return Support_1.mustNotBeCalled(); }, true);
        // console.log(`GC: ${defined(newGraph._types).length} types`);
        return newGraph;
    };
    TypeGraph.prototype.makeGraph = function (invertDirection, childrenOfType) {
        return new Graph_1.Graph(Support_1.defined(this._types), invertDirection, childrenOfType);
    };
    TypeGraph.prototype.getParentsOfType = function (t) {
        Support_1.assert(t.typeRef.graph === this, "Called on wrong type graph");
        if (this._parents === undefined) {
            var parents_1 = Support_1.defined(this._types).map(function (_) { return immutable_1.Set(); });
            this.allTypesUnordered().forEach(function (p) {
                p.getChildren().forEach(function (c) {
                    var index = c.typeRef.index;
                    parents_1[index] = parents_1[index].add(p);
                });
            });
            this._parents = parents_1;
        }
        return this._parents[t.typeRef.index];
    };
    TypeGraph.prototype.printGraph = function () {
        var types = Support_1.defined(this._types);
        var _loop_1 = function (i) {
            var t = types[i];
            var parts = [];
            parts.push("" + t.debugPrintKind + (t.hasNames ? " " + t.getCombinedName() : ""));
            var children = t.getChildren();
            if (!children.isEmpty()) {
                parts.push("children " + children.map(function (c) { return c.typeRef.index; }).join(","));
            }
            t.getAttributes().forEach(function (value, kind) {
                var maybeString = kind.stringify(value);
                if (maybeString !== undefined) {
                    parts.push(maybeString);
                }
            });
            console.log(i + ": " + parts.join(" | "));
        };
        for (var i = 0; i < types.length; i++) {
            _loop_1(i);
        }
    };
    return TypeGraph;
}());
exports.TypeGraph = TypeGraph;
function noneToAny(graph, stringTypeMapping, debugPrintReconstitution) {
    var noneTypes = graph.allTypesUnordered().filter(function (t) { return t.kind === "none"; });
    if (noneTypes.size === 0) {
        return graph;
    }
    Support_1.assert(noneTypes.size === 1, "Cannot have more than one none type");
    return graph.rewrite("none to any", stringTypeMapping, false, [noneTypes.toArray()], debugPrintReconstitution, function (types, builder, forwardingRef) {
        var attributes = TypeUtils_1.combineTypeAttributesOfTypes("union", types);
        var tref = builder.getPrimitiveType("any", attributes, forwardingRef);
        return tref;
    });
}
exports.noneToAny = noneToAny;
function optionalToNullable(graph, stringTypeMapping, debugPrintReconstitution) {
    function rewriteClass(c, builder, forwardingRef) {
        var properties = c.getProperties().map(function (p, name) {
            var t = p.type;
            var ref;
            if (!p.isOptional || t.isNullable) {
                ref = builder.reconstituteType(t);
            }
            else {
                var nullType = builder.getPrimitiveType("null");
                var members = void 0;
                if (t instanceof Type_1.UnionType) {
                    members = t.members.map(function (m) { return builder.reconstituteType(m); }).add(nullType);
                }
                else {
                    members = immutable_1.OrderedSet([builder.reconstituteType(t), nullType]);
                }
                var attributes = TypeNames_1.namesTypeAttributeKind.setDefaultInAttributes(t.getAttributes(), function () {
                    return TypeNames_1.TypeNames.make(immutable_1.OrderedSet([name]), immutable_1.OrderedSet(), true);
                });
                ref = builder.getUnionType(attributes, members);
            }
            return new Type_1.ClassProperty(ref, false);
        });
        if (c.isFixed) {
            return builder.getUniqueClassType(c.getAttributes(), true, properties, forwardingRef);
        }
        else {
            return builder.getClassType(c.getAttributes(), properties, forwardingRef);
        }
    }
    var classesWithOptional = graph
        .allTypesUnordered()
        .filter(function (t) { return t instanceof Type_1.ClassType && t.getProperties().some(function (p) { return p.isOptional; }); });
    var replacementGroups = classesWithOptional.map(function (c) { return [c]; }).toArray();
    if (classesWithOptional.size === 0) {
        return graph;
    }
    return graph.rewrite("optional to nullable", stringTypeMapping, false, replacementGroups, debugPrintReconstitution, function (setOfClass, builder, forwardingRef) {
        Support_1.assert(setOfClass.size === 1);
        var c = Support_1.defined(setOfClass.first());
        return rewriteClass(c, builder, forwardingRef);
    });
}
exports.optionalToNullable = optionalToNullable;
function removeIndirectionIntersections(graph, stringTypeMapping, debugPrintRemapping) {
    var map = [];
    graph.allTypesUnordered().forEach(function (t) {
        if (!(t instanceof Type_1.IntersectionType))
            return;
        var seen = immutable_1.Set([t]);
        var current = t;
        while (current.members.size === 1) {
            var member = Support_1.defined(current.members.first());
            if (!(member instanceof Type_1.IntersectionType)) {
                map.push([t, member]);
                return;
            }
            if (seen.has(member)) {
                // FIXME: Technically, this is an any type.
                return Support_1.panic("There's a cycle of intersection types");
            }
            seen = seen.add(member);
            current = member;
        }
    });
    return graph.remap("remove indirection intersections", stringTypeMapping, false, immutable_1.Map(map), debugPrintRemapping);
}
exports.removeIndirectionIntersections = removeIndirectionIntersections;
