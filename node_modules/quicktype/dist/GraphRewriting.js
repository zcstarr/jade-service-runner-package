"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var TypeUtils_1 = require("./TypeUtils");
var TypeAttributes_1 = require("./TypeAttributes");
var Support_1 = require("./Support");
var TypeBuilder_1 = require("./TypeBuilder");
var TypeReconstituter = /** @class */ (function () {
    function TypeReconstituter(_typeBuilder, _makeClassUnique, _typeAttributes, _forwardingRef, _register) {
        this._typeBuilder = _typeBuilder;
        this._makeClassUnique = _makeClassUnique;
        this._typeAttributes = _typeAttributes;
        this._forwardingRef = _forwardingRef;
        this._register = _register;
        this._wasUsed = false;
        this._typeRef = undefined;
    }
    TypeReconstituter.prototype.builderForNewType = function () {
        Support_1.assert(!this._wasUsed, "TypeReconstituter used more than once");
        this._wasUsed = true;
        return this._typeBuilder;
    };
    TypeReconstituter.prototype.builderForSetting = function () {
        Support_1.assert(this._wasUsed && this._typeRef !== undefined, "Can't set type members before constructing a type");
        return this._typeBuilder;
    };
    TypeReconstituter.prototype.getResult = function () {
        if (this._typeRef === undefined) {
            return Support_1.panic("Type was not reconstituted");
        }
        return this._typeRef;
    };
    // FIXME: Do registration automatically.
    TypeReconstituter.prototype.register = function (tref) {
        Support_1.assert(this._typeRef === undefined, "Cannot register a type twice");
        this._typeRef = tref;
        this._register(tref);
    };
    TypeReconstituter.prototype.registerAndAddAttributes = function (tref) {
        this._typeBuilder.addAttributes(tref, this._typeAttributes);
        this.register(tref);
    };
    TypeReconstituter.prototype.lookup = function (trefs) {
        var _this = this;
        Support_1.assert(!this._wasUsed, "Cannot lookup constituents after building type");
        if (immutable_1.isCollection(trefs)) {
            var maybeRefs = trefs.map(function (tref) { return _this._typeBuilder.lookupTypeRefs([tref], undefined, false); });
            if (maybeRefs.some(function (tref) { return tref === undefined; }))
                return undefined;
            return maybeRefs;
        }
        return this._typeBuilder.lookupTypeRefs([trefs], undefined, false);
    };
    TypeReconstituter.prototype.reconstitute = function (trefs) {
        var _this = this;
        Support_1.assert(this._wasUsed, "Cannot reconstitute constituents before building type");
        if (immutable_1.isCollection(trefs)) {
            return trefs.map(function (tref) { return _this._typeBuilder.reconstituteTypeRef(tref); });
        }
        return this._typeBuilder.reconstituteTypeRef(trefs);
    };
    TypeReconstituter.prototype.getPrimitiveType = function (kind) {
        this.register(this.builderForNewType().getPrimitiveType(kind, this._typeAttributes, this._forwardingRef));
    };
    TypeReconstituter.prototype.getEnumType = function (cases) {
        this.register(this.builderForNewType().getEnumType(this._typeAttributes, cases, this._forwardingRef));
    };
    TypeReconstituter.prototype.getUniqueMapType = function () {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueMapType(this._forwardingRef));
    };
    TypeReconstituter.prototype.getMapType = function (values) {
        this.register(this.builderForNewType().getMapType(this._typeAttributes, values, this._forwardingRef));
    };
    TypeReconstituter.prototype.getUniqueArrayType = function () {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueArrayType(this._forwardingRef));
    };
    TypeReconstituter.prototype.getArrayType = function (items) {
        this.registerAndAddAttributes(this.builderForNewType().getArrayType(items, this._forwardingRef));
    };
    TypeReconstituter.prototype.setArrayItems = function (items) {
        this.builderForSetting().setArrayItems(this.getResult(), items);
    };
    TypeReconstituter.prototype.getObjectType = function (properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
    };
    TypeReconstituter.prototype.getUniqueObjectType = function (properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
    };
    TypeReconstituter.prototype.getClassType = function (properties) {
        if (this._makeClassUnique) {
            this.getUniqueClassType(false, properties);
            return;
        }
        this.register(this.builderForNewType().getClassType(this._typeAttributes, properties, this._forwardingRef));
    };
    TypeReconstituter.prototype.getUniqueClassType = function (isFixed, properties) {
        this.register(this.builderForNewType().getUniqueClassType(this._typeAttributes, isFixed, properties, this._forwardingRef));
    };
    TypeReconstituter.prototype.setObjectProperties = function (properties, additionalProperties) {
        this.builderForSetting().setObjectProperties(this.getResult(), properties, additionalProperties);
    };
    TypeReconstituter.prototype.getUnionType = function (members) {
        this.register(this.builderForNewType().getUnionType(this._typeAttributes, members, this._forwardingRef));
    };
    TypeReconstituter.prototype.getUniqueUnionType = function () {
        this.register(this.builderForNewType().getUniqueUnionType(this._typeAttributes, undefined, this._forwardingRef));
    };
    TypeReconstituter.prototype.getIntersectionType = function (members) {
        this.register(this.builderForNewType().getIntersectionType(this._typeAttributes, members, this._forwardingRef));
    };
    TypeReconstituter.prototype.getUniqueIntersectionType = function (members) {
        this.register(this.builderForNewType().getUniqueIntersectionType(this._typeAttributes, members, this._forwardingRef));
    };
    TypeReconstituter.prototype.setSetOperationMembers = function (members) {
        this.builderForSetting().setSetOperationMembers(this.getResult(), members);
    };
    return TypeReconstituter;
}());
exports.TypeReconstituter = TypeReconstituter;
var BaseGraphRewriteBuilder = /** @class */ (function (_super) {
    __extends(BaseGraphRewriteBuilder, _super);
    function BaseGraphRewriteBuilder(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrint) {
        var _this = _super.call(this, stringTypeMapping, alphabetizeProperties, false, false, graphHasProvenanceAttributes) || this;
        _this.originalGraph = originalGraph;
        _this.debugPrint = debugPrint;
        _this.reconstitutedTypes = immutable_1.Map();
        _this._lostTypeAttributes = false;
        _this._printIndent = 0;
        return _this;
    }
    BaseGraphRewriteBuilder.prototype.withForwardingRef = function (maybeForwardingRef, typeCreator) {
        if (maybeForwardingRef !== undefined) {
            return typeCreator(maybeForwardingRef);
        }
        var forwardingRef = this.reserveTypeRef();
        var actualRef = typeCreator(forwardingRef);
        Support_1.assert(actualRef === forwardingRef, "Type creator didn't return its forwarding ref");
        return actualRef;
    };
    BaseGraphRewriteBuilder.prototype.reconstituteType = function (t, attributes, forwardingRef) {
        return this.reconstituteTypeRef(t.typeRef, attributes, forwardingRef);
    };
    BaseGraphRewriteBuilder.prototype.reconstituteTypeRef = function (originalRef, attributes, maybeForwardingRef) {
        var maybeRef = this.lookupTypeRefs([originalRef], maybeForwardingRef);
        if (maybeRef !== undefined) {
            if (attributes !== undefined) {
                this.addAttributes(maybeRef, attributes);
            }
            return maybeRef;
        }
        return this.forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef);
    };
    BaseGraphRewriteBuilder.prototype.reconstituteTypeAttributes = function (attributes) {
        var _this = this;
        return attributes.map(function (v, a) { return a.reconstitute(_this, v); });
    };
    BaseGraphRewriteBuilder.prototype.assertTypeRefsToReconstitute = function (typeRefs, forwardingRef) {
        Support_1.assert(typeRefs.length > 0, "Must have at least one type to reconstitute");
        for (var _i = 0, typeRefs_1 = typeRefs; _i < typeRefs_1.length; _i++) {
            var originalRef = typeRefs_1[_i];
            Support_1.assert(originalRef.graph === this.originalGraph, "Trying to reconstitute a type from the wrong graph");
        }
        if (forwardingRef !== undefined) {
            Support_1.assert(forwardingRef.graph === this.typeGraph, "Trying to forward a type to the wrong graph");
        }
    };
    BaseGraphRewriteBuilder.prototype.changeDebugPrintIndent = function (delta) {
        this._printIndent += delta;
    };
    Object.defineProperty(BaseGraphRewriteBuilder.prototype, "debugPrintIndentation", {
        get: function () {
            return Support_1.indentationString(this._printIndent);
        },
        enumerable: true,
        configurable: true
    });
    BaseGraphRewriteBuilder.prototype.finish = function () {
        var _this = this;
        this.originalGraph.topLevels.forEach(function (t, name) {
            _this.addTopLevel(name, _this.reconstituteType(t));
        });
        return _super.prototype.finish.call(this);
    };
    BaseGraphRewriteBuilder.prototype.setLostTypeAttributes = function () {
        this._lostTypeAttributes = true;
    };
    Object.defineProperty(BaseGraphRewriteBuilder.prototype, "lostTypeAttributes", {
        get: function () {
            return this._lostTypeAttributes;
        },
        enumerable: true,
        configurable: true
    });
    return BaseGraphRewriteBuilder;
}(TypeBuilder_1.TypeBuilder));
exports.BaseGraphRewriteBuilder = BaseGraphRewriteBuilder;
var GraphRemapBuilder = /** @class */ (function (_super) {
    __extends(GraphRemapBuilder, _super);
    function GraphRemapBuilder(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, _map, debugPrintRemapping) {
        var _this = _super.call(this, originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintRemapping) || this;
        _this._map = _map;
        _this._attributeSources = immutable_1.Map();
        _map.forEach(function (target, source) {
            var maybeSources = _this._attributeSources.get(target);
            if (maybeSources === undefined) {
                maybeSources = [target];
                _this._attributeSources = _this._attributeSources.set(target, maybeSources);
            }
            maybeSources.push(source);
        });
        return _this;
    }
    GraphRemapBuilder.prototype.makeIdentity = function (_maker) {
        return undefined;
    };
    GraphRemapBuilder.prototype.getMapTarget = function (tref) {
        var maybeType = this._map.get(tref.deref()[0]);
        if (maybeType === undefined)
            return tref;
        Support_1.assert(this._map.get(maybeType) === undefined, "We have a type that's remapped to a remapped type");
        return maybeType.typeRef;
    };
    GraphRemapBuilder.prototype.addForwardingIntersection = function (_forwardingRef, _tref) {
        return Support_1.panic("We can't add forwarding intersections when we're removing forwarding intersections");
    };
    GraphRemapBuilder.prototype.lookupTypeRefs = function (typeRefs, forwardingRef) {
        Support_1.assert(forwardingRef === undefined, "We can't have a forwarding ref when we remap");
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        var first = this.reconstitutedTypes.get(this.getMapTarget(typeRefs[0]).index);
        if (first === undefined)
            return undefined;
        for (var i = 1; i < typeRefs.length; i++) {
            var other = this.reconstitutedTypes.get(this.getMapTarget(typeRefs[i]).index);
            if (first !== other)
                return undefined;
        }
        return first;
    };
    GraphRemapBuilder.prototype.forceReconstituteTypeRef = function (originalRef, attributes, maybeForwardingRef) {
        var _this = this;
        originalRef = this.getMapTarget(originalRef);
        var index = originalRef.index;
        Support_1.assert(this.reconstitutedTypes.get(index) === undefined, "Type has already been reconstituted");
        Support_1.assert(maybeForwardingRef === undefined, "We can't have a forwarding ref when we remap");
        var _a = originalRef.deref(), originalType = _a[0], originalAttributes = _a[1];
        var attributeSources = this._attributeSources.get(originalType);
        if (attributes === undefined) {
            attributes = TypeAttributes_1.emptyTypeAttributes;
        }
        if (attributeSources === undefined) {
            attributes = TypeAttributes_1.combineTypeAttributes("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
        }
        else {
            attributes = TypeAttributes_1.combineTypeAttributes("union", attributes, this.reconstituteTypeAttributes(TypeUtils_1.combineTypeAttributesOfTypes("union", attributeSources)));
        }
        var newAttributes = attributes;
        return this.withForwardingRef(undefined, function (forwardingRef) {
            _this.reconstitutedTypes = _this.reconstitutedTypes.set(index, forwardingRef);
            if (_this.debugPrint) {
                console.log(_this.debugPrintIndentation + "reconstituting " + index + " as " + forwardingRef.index);
                _this.changeDebugPrintIndent(1);
            }
            var reconstituter = new TypeReconstituter(_this, _this.canonicalOrder, newAttributes, forwardingRef, function (tref) {
                Support_1.assert(tref === forwardingRef, "Reconstituted type as a different ref");
                if (_this.debugPrint) {
                    _this.changeDebugPrintIndent(-1);
                    console.log(_this.debugPrintIndentation + "reconstituted " + index + " as " + tref.index);
                }
            });
            originalType.reconstitute(reconstituter, _this.canonicalOrder);
            return reconstituter.getResult();
        });
    };
    return GraphRemapBuilder;
}(BaseGraphRewriteBuilder));
exports.GraphRemapBuilder = GraphRemapBuilder;
var GraphRewriteBuilder = /** @class */ (function (_super) {
    __extends(GraphRewriteBuilder, _super);
    function GraphRewriteBuilder(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, setsToReplace, debugPrintReconstitution, _replacer) {
        var _this = _super.call(this, originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintReconstitution) || this;
        _this._replacer = _replacer;
        _this._reconstitutedUnions = immutable_1.Map();
        _this._setsToReplaceByMember = immutable_1.Map();
        var _loop_1 = function (types) {
            var set = immutable_1.Set(types);
            set.forEach(function (t) {
                var index = t.typeRef.index;
                Support_1.assert(!_this._setsToReplaceByMember.has(index), "A type is member of more than one set to be replaced");
                _this._setsToReplaceByMember = _this._setsToReplaceByMember.set(index, set);
            });
        };
        for (var _i = 0, setsToReplace_1 = setsToReplace; _i < setsToReplace_1.length; _i++) {
            var types = setsToReplace_1[_i];
            _loop_1(types);
        }
        return _this;
    }
    GraphRewriteBuilder.prototype.registerUnion = function (typeRefs, reconstituted) {
        var set = immutable_1.Set(typeRefs);
        Support_1.assert(!this._reconstitutedUnions.has(set), "Cannot register reconstituted set twice");
        this._reconstitutedUnions = this._reconstitutedUnions.set(set, reconstituted);
    };
    GraphRewriteBuilder.prototype.replaceSet = function (typesToReplace, maybeForwardingRef) {
        var _this = this;
        return this.withForwardingRef(maybeForwardingRef, function (forwardingRef) {
            if (_this.debugPrint) {
                console.log(_this.debugPrintIndentation + "replacing set " + typesToReplace
                    .map(function (t) { return t.typeRef.index.toString(); })
                    .join(",") + " as " + forwardingRef.index);
                _this.changeDebugPrintIndent(1);
            }
            typesToReplace.forEach(function (t) {
                var originalRef = t.typeRef;
                var index = originalRef.index;
                _this.reconstitutedTypes = _this.reconstitutedTypes.set(index, forwardingRef);
                _this._setsToReplaceByMember = _this._setsToReplaceByMember.remove(index);
            });
            var result = _this._replacer(typesToReplace, _this, forwardingRef);
            Support_1.assert(result === forwardingRef, "The forwarding ref got lost when replacing");
            if (_this.debugPrint) {
                _this.changeDebugPrintIndent(-1);
                console.log(_this.debugPrintIndentation + "replaced set " + typesToReplace
                    .map(function (t) { return t.typeRef.index.toString(); })
                    .join(",") + " as " + forwardingRef.index);
            }
            return result;
        });
    };
    GraphRewriteBuilder.prototype.forceReconstituteTypeRef = function (originalRef, attributes, maybeForwardingRef) {
        var _this = this;
        var _a = originalRef.deref(), originalType = _a[0], originalAttributes = _a[1];
        var index = originalRef.index;
        if (this.debugPrint) {
            console.log(this.debugPrintIndentation + "reconstituting " + index);
            this.changeDebugPrintIndent(1);
        }
        if (attributes === undefined) {
            attributes = this.reconstituteTypeAttributes(originalAttributes);
        }
        else {
            attributes = TypeAttributes_1.combineTypeAttributes("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
        }
        var reconstituter = new TypeReconstituter(this, this.canonicalOrder, attributes, maybeForwardingRef, function (tref) {
            if (_this.debugPrint) {
                _this.changeDebugPrintIndent(-1);
                console.log(_this.debugPrintIndentation + "reconstituted " + index + " as " + tref.index);
            }
            if (maybeForwardingRef !== undefined) {
                Support_1.assert(tref === maybeForwardingRef, "We didn't pass the forwarding ref");
            }
            var alreadyReconstitutedType = _this.reconstitutedTypes.get(index);
            if (alreadyReconstitutedType === undefined) {
                _this.reconstitutedTypes = _this.reconstitutedTypes.set(index, tref);
            }
            else {
                Support_1.assert(tref.equals(alreadyReconstitutedType), "We reconstituted a type twice differently");
            }
        });
        originalType.reconstitute(reconstituter, this.canonicalOrder);
        return reconstituter.getResult();
    };
    /*
    reconstituteTypeUnmodified(originalType: Type): TypeRef {
        const reconstituter = new TypeReconstituter(
            this,
            this.alphabetizeProperties,
            emptyTypeAttributes,
            undefined,
            () => {}
        );
        originalType.reconstitute(reconstituter);
        return reconstituter.getResult();
    }
    */
    // If the union of these type refs have been, or are supposed to be, reconstituted to
    // one target type, return it.  Otherwise return undefined.
    GraphRewriteBuilder.prototype.lookupTypeRefs = function (typeRefs, forwardingRef, replaceSet) {
        if (replaceSet === void 0) { replaceSet = true; }
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        // Check whether we have already reconstituted them.  That means ensuring
        // that they all have the same target type.
        var maybeRef = this.reconstitutedTypes.get(typeRefs[0].index);
        if (maybeRef !== undefined && maybeRef !== forwardingRef) {
            var allEqual = true;
            for (var i = 1; i < typeRefs.length; i++) {
                if (this.reconstitutedTypes.get(typeRefs[i].index) !== maybeRef) {
                    allEqual = false;
                    break;
                }
            }
            if (allEqual) {
                return this.forwardIfNecessary(forwardingRef, maybeRef);
            }
        }
        // Has this been reconstituted as a set?
        maybeRef = this._reconstitutedUnions.get(immutable_1.Set(typeRefs));
        if (maybeRef !== undefined && maybeRef !== forwardingRef) {
            return this.forwardIfNecessary(forwardingRef, maybeRef);
        }
        // Is this set requested to be replaced?  If not, we're out of options.
        var maybeSet = this._setsToReplaceByMember.get(typeRefs[0].index);
        if (maybeSet === undefined) {
            return undefined;
        }
        for (var i = 1; i < typeRefs.length; i++) {
            if (this._setsToReplaceByMember.get(typeRefs[i].index) !== maybeSet) {
                return undefined;
            }
        }
        // Yes, this set is requested to be replaced, so do it.
        if (!replaceSet)
            return undefined;
        return this.replaceSet(maybeSet, forwardingRef);
    };
    return GraphRewriteBuilder;
}(BaseGraphRewriteBuilder));
exports.GraphRewriteBuilder = GraphRewriteBuilder;
