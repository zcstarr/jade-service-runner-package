"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var handlebars = require("handlebars");
var Naming_1 = require("./Naming");
var Source_1 = require("./Source");
var Annotation_1 = require("./Annotation");
var Support_1 = require("./Support");
function lineIndentation(line) {
    var len = line.length;
    var indent = 0;
    for (var i = 0; i < len; i++) {
        var c = line.charAt(i);
        if (c === " ") {
            indent += 1;
        }
        else if (c === "\t") {
            indent = (indent / 4 + 1) * 4;
        }
        else {
            return { indent: indent, text: line.substring(i) };
        }
    }
    return { indent: 0, text: null };
}
var Renderer = /** @class */ (function () {
    function Renderer(targetLanguage, typeGraph, leadingComments) {
        var _this = this;
        this.targetLanguage = targetLanguage;
        this.typeGraph = typeGraph;
        this.leadingComments = leadingComments;
        this.emitNewline = function () {
            var nl = Source_1.newline();
            _this.pushItem(nl);
            _this._lastNewline = nl;
        };
        this.emitItem = function (item) {
            if (_this._needBlankLine) {
                _this.emitNewline();
                _this._needBlankLine = false;
            }
            _this.pushItem(item);
        };
        this.emitTable = function (tableArray) {
            if (tableArray.length === 0)
                return;
            var table = immutable_1.List(tableArray.map(function (r) { return immutable_1.List(r.map(function (sl) { return Source_1.sourcelikeToSource(sl); })); }));
            _this.emitItem({ kind: "table", table: table });
            _this.emitNewline();
        };
        this._finishedFiles = immutable_1.Map();
        this.startEmit();
    }
    Renderer.prototype.startEmit = function () {
        this._currentEmitTarget = this._emitted = [];
        this._needBlankLine = false;
        this._preventBlankLine = true; // no blank lines at start of file
    };
    Renderer.prototype.pushItem = function (item) {
        this._currentEmitTarget.push(item);
        this._preventBlankLine = false;
    };
    Renderer.prototype.ensureBlankLine = function () {
        if (this._preventBlankLine)
            return;
        this._needBlankLine = true;
    };
    Renderer.prototype.preventBlankLine = function () {
        this._needBlankLine = false;
        this._preventBlankLine = true;
    };
    Renderer.prototype.emitLine = function () {
        var lineParts = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            lineParts[_i] = arguments[_i];
        }
        if (lineParts.length === 1) {
            this.emitItem(lineParts[0]);
        }
        else if (lineParts.length > 1) {
            this.emitItem(lineParts);
        }
        this.emitNewline();
    };
    Renderer.prototype.emitMultiline = function (linesString) {
        var lines = linesString.split("\n");
        var numLines = lines.length;
        if (numLines === 0)
            return;
        this.emitLine(lines[0]);
        var currentIndent = 0;
        for (var i = 1; i < numLines; i++) {
            var line = lines[i];
            var _a = lineIndentation(line), indent = _a.indent, text = _a.text;
            Support_1.assert(indent % 4 === 0, "Indentation is not a multiple of 4.");
            if (text !== null) {
                var newIndent = indent / 4;
                this.changeIndent(newIndent - currentIndent);
                currentIndent = newIndent;
                this.emitLine(text);
            }
            else {
                this.emitNewline();
            }
        }
        if (currentIndent !== 0) {
            this.changeIndent(-currentIndent);
        }
    };
    Renderer.prototype.emitAnnotated = function (annotation, emitter) {
        var oldEmitTarget = this._currentEmitTarget;
        var emitTarget = [];
        this._currentEmitTarget = emitTarget;
        emitter();
        Support_1.assert(this._currentEmitTarget === emitTarget, "_currentEmitTarget not restored correctly");
        this._currentEmitTarget = oldEmitTarget;
        var source = Source_1.sourcelikeToSource(emitTarget);
        this.pushItem(Source_1.annotated(annotation, source));
    };
    Renderer.prototype.emitIssue = function (message, emitter) {
        this.emitAnnotated(new Annotation_1.IssueAnnotationData(message), emitter);
    };
    Renderer.prototype.changeIndent = function (offset) {
        if (this._lastNewline === undefined) {
            return Support_1.panic("Cannot change indent for the first line");
        }
        this._lastNewline.indentationChange += offset;
    };
    Renderer.prototype.forEach = function (iterable, interposedBlankLines, leadingBlankLine, emitter) {
        var _this = this;
        var onFirst = true;
        iterable.forEach(function (v, k) {
            if ((leadingBlankLine && onFirst) || (interposedBlankLines && !onFirst)) {
                _this.ensureBlankLine();
            }
            emitter(v, k);
            onFirst = false;
        });
    };
    Renderer.prototype.forEachWithBlankLines = function (iterable, blankLineLocations, emitter) {
        var interposing = ["interposing", "leading-and-interposing"].indexOf(blankLineLocations) >= 0;
        var leading = ["leading", "leading-and-interposing"].indexOf(blankLineLocations) >= 0;
        this.forEach(iterable, interposing, leading, emitter);
    };
    Renderer.prototype.indent = function (fn) {
        this.changeIndent(1);
        fn();
        this.changeIndent(-1);
    };
    Renderer.prototype.assignNames = function () {
        return Naming_1.assignNames(this.setUpNaming());
    };
    Renderer.prototype.finishFile = function (filename) {
        Support_1.assert(!this._finishedFiles.has(filename), "Tried to emit file " + filename + " more than once");
        var source = Source_1.sourcelikeToSource(this._emitted);
        this._finishedFiles = this._finishedFiles.set(filename, source);
        this.startEmit();
    };
    Renderer.prototype.render = function (givenOutputFilename) {
        this._names = this.assignNames();
        this.emitSource(givenOutputFilename);
        if (this._emitted.length > 0) {
            this.finishFile(givenOutputFilename);
        }
        return { sources: this._finishedFiles, names: this._names };
    };
    Renderer.prototype.registerHandlebarsHelpers = function (_context) {
        handlebars.registerHelper("if_eq", function (a, b, options) {
            if (a === b) {
                return options.fn(this);
            }
        });
    };
    Renderer.prototype.processHandlebarsTemplate = function (template) {
        this._names = this.assignNames();
        var context = this.makeHandlebarsContext();
        this.registerHandlebarsHelpers(context);
        var compiledTemplate = handlebars.compile(template);
        return compiledTemplate(context);
    };
    Object.defineProperty(Renderer.prototype, "names", {
        get: function () {
            if (this._names === undefined) {
                return Support_1.panic("Names accessed before they were assigned");
            }
            return this._names;
        },
        enumerable: true,
        configurable: true
    });
    return Renderer;
}());
exports.Renderer = Renderer;
