"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("./Type");
var TypeUtils_1 = require("./TypeUtils");
var TypeAttributes_1 = require("./TypeAttributes");
var Support_1 = require("./Support");
var StringTypes_1 = require("./StringTypes");
function addAttributes(accumulatorAttributes, newAttributes) {
    if (accumulatorAttributes === undefined)
        return newAttributes;
    return TypeAttributes_1.combineTypeAttributes("union", accumulatorAttributes, newAttributes);
}
function setAttributes(attributeMap, kind, newAttributes) {
    return attributeMap.set(kind, addAttributes(attributeMap.get(kind), newAttributes));
}
function moveAttributes(map, fromKind, toKind) {
    var fromAttributes = Support_1.defined(map.get(fromKind));
    map = map.remove(fromKind);
    return setAttributes(map, toKind, fromAttributes);
}
var UnionAccumulator = /** @class */ (function () {
    function UnionAccumulator(_conflateNumbers) {
        this._conflateNumbers = _conflateNumbers;
        this._nonStringTypeAttributes = immutable_1.OrderedMap();
        this._stringTypeAttributes = immutable_1.OrderedMap();
        this.arrayData = [];
        this.objectData = [];
        this._enumCases = immutable_1.OrderedSet();
        this._lostTypeAttributes = false;
    }
    UnionAccumulator.prototype.have = function (kind) {
        return (this._nonStringTypeAttributes.has(kind) || this._stringTypeAttributes.has(kind));
    };
    UnionAccumulator.prototype.addNone = function (_attributes) {
        // FIXME: Add them to all members?  Or add them to the union, which means we'd have
        // to change getMemberKinds() to also return the attributes for the union itself,
        // or add a new method that does that.
        this._lostTypeAttributes = true;
    };
    UnionAccumulator.prototype.addAny = function (attributes) {
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "any", attributes);
        this._lostTypeAttributes = true;
    };
    UnionAccumulator.prototype.addNull = function (attributes) {
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "null", attributes);
    };
    UnionAccumulator.prototype.addBool = function (attributes) {
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "bool", attributes);
    };
    UnionAccumulator.prototype.addInteger = function (attributes) {
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "integer", attributes);
    };
    UnionAccumulator.prototype.addDouble = function (attributes) {
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "double", attributes);
    };
    UnionAccumulator.prototype.addFullStringType = function (attributes, stringTypes) {
        if (stringTypes === undefined) {
            stringTypes = StringTypes_1.stringTypesTypeAttributeKind.tryGetInAttributes(attributes);
        }
        else {
            attributes = StringTypes_1.stringTypesTypeAttributeKind.combineInAttributes(attributes, stringTypes);
        }
        if (stringTypes === undefined) {
            stringTypes = StringTypes_1.StringTypes.unrestricted;
            attributes = StringTypes_1.stringTypesTypeAttributeKind.combineInAttributes(attributes, stringTypes);
        }
        var maybeEnumAttributes = this._nonStringTypeAttributes.get("enum");
        if (stringTypes.isRestricted) {
            Support_1.assert(maybeEnumAttributes === undefined, "We can't add both an enum as well as a restricted string type to a union builder");
        }
        this._stringTypeAttributes = setAttributes(this._stringTypeAttributes, "string", attributes);
    };
    UnionAccumulator.prototype.addStringType = function (kind, attributes, stringTypes) {
        if (kind === "string") {
            this.addFullStringType(attributes, stringTypes);
            return;
        }
        if (stringTypes !== undefined) {
            attributes = StringTypes_1.stringTypesTypeAttributeKind.combineInAttributes(attributes, stringTypes);
        }
        this._stringTypeAttributes = setAttributes(this._stringTypeAttributes, kind, attributes);
    };
    UnionAccumulator.prototype.addArray = function (t, attributes) {
        this.arrayData.push(t);
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "array", attributes);
    };
    UnionAccumulator.prototype.addObject = function (t, attributes) {
        this.objectData.push(t);
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "object", attributes);
    };
    UnionAccumulator.prototype.addEnum = function (cases, attributes) {
        var maybeStringAttributes = this._stringTypeAttributes.get("string");
        if (maybeStringAttributes !== undefined) {
            Support_1.assert(!Support_1.defined(StringTypes_1.stringTypesTypeAttributeKind.tryGetInAttributes(maybeStringAttributes)).isRestricted, "We can't add an enum to a union builder that has a restricted string type");
            this._stringTypeAttributes = setAttributes(this._stringTypeAttributes, "string", attributes);
            return;
        }
        this._nonStringTypeAttributes = setAttributes(this._nonStringTypeAttributes, "enum", attributes);
        this._enumCases = this._enumCases.union(cases);
    };
    UnionAccumulator.prototype.addStringCases = function (cases, attributes) {
        this.addFullStringType(attributes, StringTypes_1.StringTypes.fromCases(cases));
    };
    UnionAccumulator.prototype.addStringCase = function (s, count, attributes) {
        this.addFullStringType(attributes, StringTypes_1.StringTypes.fromCase(s, count));
    };
    Object.defineProperty(UnionAccumulator.prototype, "enumCases", {
        get: function () {
            return this._enumCases;
        },
        enumerable: true,
        configurable: true
    });
    UnionAccumulator.prototype.getMemberKinds = function () {
        Support_1.assert(!(this.have("enum") && this.have("string")), "We can't have both strings and enums in the same union");
        var merged = this._nonStringTypeAttributes.merge(this._stringTypeAttributes);
        if (merged.isEmpty()) {
            return immutable_1.OrderedMap([["none", immutable_1.Map()]]);
        }
        if (this._nonStringTypeAttributes.has("any")) {
            Support_1.assert(this._lostTypeAttributes, "This had to be set when we added 'any'");
            var allAttributes = TypeAttributes_1.combineTypeAttributes("union", merged.valueSeq().toArray());
            return immutable_1.OrderedMap([["any", allAttributes]]);
        }
        if (this._conflateNumbers && this.have("integer") && this.have("double")) {
            merged = moveAttributes(merged, "integer", "double");
        }
        if (this.have("map")) {
            merged = moveAttributes(merged, "map", "class");
        }
        return merged;
    };
    Object.defineProperty(UnionAccumulator.prototype, "lostTypeAttributes", {
        get: function () {
            return this._lostTypeAttributes;
        },
        enumerable: true,
        configurable: true
    });
    return UnionAccumulator;
}());
exports.UnionAccumulator = UnionAccumulator;
var FauxUnion = /** @class */ (function () {
    function FauxUnion() {
    }
    FauxUnion.prototype.getAttributes = function () {
        return TypeAttributes_1.emptyTypeAttributes;
    };
    return FauxUnion;
}());
function attributesForTypes(types) {
    var unionsForType = immutable_1.OrderedMap();
    var typesForUnion = immutable_1.Map();
    var unions = immutable_1.OrderedSet();
    var unionsEquivalentToRoot = immutable_1.Set();
    function traverse(t, path, isEquivalentToRoot) {
        if (t instanceof Type_1.UnionType) {
            unions = unions.add(t);
            if (isEquivalentToRoot) {
                unionsEquivalentToRoot = unionsEquivalentToRoot.add(t);
            }
            path = path.add(t);
            isEquivalentToRoot = isEquivalentToRoot && t.members.size === 1;
            t.members.forEach(function (m) { return traverse(m, path, isEquivalentToRoot); });
        }
        else {
            unionsForType = unionsForType.update(t, immutable_1.Set(), function (s) { return s.union(path); });
            path.forEach(function (u) {
                typesForUnion = typesForUnion.update(u, immutable_1.Set(), function (s) { return s.add(t); });
            });
        }
    }
    var rootPath = immutable_1.Set([new FauxUnion()]);
    types.forEach(function (t) { return traverse(t, rootPath, types.size === 1); });
    var resultAttributes = unionsForType.map(function (unionForType, t) {
        var singleAncestors = unionForType.filter(function (u) { return Support_1.defined(typesForUnion.get(u)).size === 1; });
        Support_1.assert(singleAncestors.every(function (u) { return Support_1.defined(typesForUnion.get(u)).has(t); }), "We messed up bookkeeping");
        var inheritedAttributes = singleAncestors.toArray().map(function (u) { return u.getAttributes(); });
        return TypeAttributes_1.combineTypeAttributes("union", [t.getAttributes()].concat(inheritedAttributes));
    });
    var unionAttributes = unions.toArray().map(function (u) {
        var t = typesForUnion.get(u);
        if (t !== undefined && t.size === 1) {
            return TypeAttributes_1.emptyTypeAttributes;
        }
        var attributes = u.getAttributes();
        if (unionsEquivalentToRoot.has(u)) {
            return attributes;
        }
        return TypeAttributes_1.makeTypeAttributesInferred(attributes);
    });
    return [resultAttributes, TypeAttributes_1.combineTypeAttributes("union", unionAttributes)];
}
// FIXME: Move this to UnifyClasses.ts?
var TypeRefUnionAccumulator = /** @class */ (function (_super) {
    __extends(TypeRefUnionAccumulator, _super);
    function TypeRefUnionAccumulator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // There is a method analogous to this in the IntersectionAccumulator.  It might
    // make sense to find a common interface.
    TypeRefUnionAccumulator.prototype.addType = function (t, attributes) {
        var _this = this;
        TypeUtils_1.matchTypeExhaustive(t, function (_noneType) { return _this.addNone(attributes); }, function (_anyType) { return _this.addAny(attributes); }, function (_nullType) { return _this.addNull(attributes); }, function (_boolType) { return _this.addBool(attributes); }, function (_integerType) { return _this.addInteger(attributes); }, function (_doubleType) { return _this.addDouble(attributes); }, function (_stringType) { return _this.addStringType("string", attributes); }, function (arrayType) { return _this.addArray(arrayType.items.typeRef, attributes); }, function (classType) { return _this.addObject(classType.typeRef, attributes); }, function (mapType) { return _this.addObject(mapType.typeRef, attributes); }, function (objectType) { return _this.addObject(objectType.typeRef, attributes); }, 
        // FIXME: We're not carrying counts, so this is not correct if we do enum
        // inference.  JSON Schema input uses this case, however, without enum
        // inference, which is fine, but still a bit ugly.
        function (enumType) { return _this.addEnum(enumType.cases, attributes); }, function (_unionType) {
            return Support_1.panic("The unions should have been eliminated in attributesForTypesInUnion");
        }, function (_dateType) { return _this.addStringType("date", attributes); }, function (_timeType) { return _this.addStringType("time", attributes); }, function (_dateTimeType) { return _this.addStringType("date-time", attributes); });
    };
    TypeRefUnionAccumulator.prototype.addTypes = function (types) {
        var _this = this;
        var _a = attributesForTypes(types), attributesMap = _a[0], unionAttributes = _a[1];
        attributesMap.forEach(function (attributes, t) { return _this.addType(t, attributes); });
        return unionAttributes;
    };
    return TypeRefUnionAccumulator;
}(UnionAccumulator));
exports.TypeRefUnionAccumulator = TypeRefUnionAccumulator;
var UnionBuilder = /** @class */ (function () {
    function UnionBuilder(typeBuilder) {
        this.typeBuilder = typeBuilder;
    }
    UnionBuilder.prototype.makeTypeOfKind = function (typeProvider, kind, typeAttributes, forwardingRef) {
        switch (kind) {
            case "any":
            case "none":
            case "null":
            case "bool":
            case "double":
            case "integer":
            case "date":
            case "time":
            case "date-time":
                return this.typeBuilder.getPrimitiveType(kind, typeAttributes, forwardingRef);
            case "string":
                return this.typeBuilder.getStringType(typeAttributes, undefined, forwardingRef);
            case "enum":
                return this.typeBuilder.getEnumType(typeAttributes, typeProvider.enumCases, forwardingRef);
            case "object":
                return this.makeObject(typeProvider.objectData, typeAttributes, forwardingRef);
            case "array":
                return this.makeArray(typeProvider.arrayData, typeAttributes, forwardingRef);
            default:
                if (kind === "union" || kind === "class" || kind === "map" || kind === "intersection") {
                    return Support_1.panic("getMemberKinds() shouldn't return " + kind);
                }
                return Support_1.assertNever(kind);
        }
    };
    UnionBuilder.prototype.buildUnion = function (typeProvider, unique, typeAttributes, forwardingRef) {
        var _this = this;
        var kinds = typeProvider.getMemberKinds();
        if (typeProvider.lostTypeAttributes) {
            this.typeBuilder.setLostTypeAttributes();
        }
        if (kinds.size === 1) {
            var _a = kinds.toArray()[0], kind = _a[0], memberAttributes = _a[1];
            var allAttributes = TypeAttributes_1.combineTypeAttributes("union", typeAttributes, memberAttributes);
            var t = this.makeTypeOfKind(typeProvider, kind, allAttributes, forwardingRef);
            return t;
        }
        var union = unique
            ? this.typeBuilder.getUniqueUnionType(typeAttributes, undefined, forwardingRef)
            : undefined;
        var types = [];
        kinds.forEach(function (memberAttributes, kind) {
            types.push(_this.makeTypeOfKind(typeProvider, kind, memberAttributes, undefined));
        });
        var typesSet = immutable_1.OrderedSet(types);
        if (union !== undefined) {
            this.typeBuilder.setSetOperationMembers(union, typesSet);
            return union;
        }
        else {
            return this.typeBuilder.getUnionType(typeAttributes, typesSet, forwardingRef);
        }
    };
    return UnionBuilder;
}());
exports.UnionBuilder = UnionBuilder;
