export declare type OptionKind = "primary" | "secondary";
export interface OptionDefinition {
    name: string;
    type: StringConstructor | BooleanConstructor;
    kind?: OptionKind;
    renderer?: boolean;
    alias?: string;
    multiple?: boolean;
    defaultOption?: boolean;
    defaultValue?: any;
    typeLabel?: string;
    description: string;
    legalValues?: string[];
}
export declare abstract class UntypedOption {
    readonly definition: OptionDefinition;
    constructor(definition: OptionDefinition);
    readonly cliDefinitions: {
        display: OptionDefinition[];
        actual: OptionDefinition[];
    };
}
export declare abstract class Option<T> extends UntypedOption {
    getValue(values: {
        [name: string]: any;
    }): T;
}
export declare class BooleanOption extends Option<boolean> {
    constructor(name: string, description: string, defaultValue: boolean, kind?: OptionKind);
    readonly cliDefinitions: {
        display: OptionDefinition[];
        actual: OptionDefinition[];
    };
    getValue(values: {
        [name: string]: any;
    }): boolean;
}
export declare class StringOption extends Option<string> {
    constructor(name: string, description: string, typeLabel: string, defaultValue: string, kind?: OptionKind);
}
export declare class EnumOption<T> extends Option<T> {
    private readonly _values;
    constructor(name: string, description: string, values: [string, T][], defaultValue?: string | undefined, kind?: OptionKind);
    getValue(values: {
        [name: string]: any;
    }): T;
}
