import { OrderedSet, OrderedMap, Set, List } from "immutable";
import { TypeRef } from "./TypeBuilder";
import { TypeReconstituter, BaseGraphRewriteBuilder } from "./GraphRewriting";
import { TypeNames } from "./TypeNames";
import { TypeAttributes } from "./TypeAttributes";
export declare type DateTimeTypeKind = "date" | "time" | "date-time";
export declare type PrimitiveStringTypeKind = "string" | DateTimeTypeKind;
export declare type PrimitiveTypeKind = "none" | "any" | "null" | "bool" | "integer" | "double" | PrimitiveStringTypeKind;
export declare type NamedTypeKind = "class" | "enum" | "union";
export declare type TypeKind = PrimitiveTypeKind | NamedTypeKind | "array" | "object" | "map" | "intersection";
export declare type ObjectTypeKind = "object" | "map" | "class";
export declare function isPrimitiveStringTypeKind(kind: TypeKind): kind is PrimitiveStringTypeKind;
export declare function isNumberTypeKind(kind: TypeKind): kind is "integer" | "double";
export declare function isPrimitiveTypeKind(kind: TypeKind): kind is PrimitiveTypeKind;
export declare type TypeIdentity = List<any> | undefined;
export declare abstract class Type {
    readonly typeRef: TypeRef;
    readonly kind: TypeKind;
    constructor(typeRef: TypeRef, kind: TypeKind);
    abstract getNonAttributeChildren(): OrderedSet<Type>;
    getChildren(): OrderedSet<Type>;
    getAttributes(): TypeAttributes;
    readonly hasNames: boolean;
    getNames(): TypeNames;
    getCombinedName(): string;
    readonly abstract isNullable: boolean;
    abstract isPrimitive(): this is PrimitiveType;
    readonly abstract identity: TypeIdentity;
    abstract reconstitute<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>, canonicalOrder: boolean): void;
    readonly debugPrintKind: string;
    equals(other: any): boolean;
    hashCode(): number;
    protected abstract structuralEqualityStep(other: Type, conflateNumbers: boolean, queue: (a: Type, b: Type) => boolean): boolean;
    structurallyCompatible(other: Type, conflateNumbers?: boolean): boolean;
    getParentTypes(): Set<Type>;
    getAncestorsNotInSet(set: Set<TypeRef>): Set<Type>;
}
export declare function primitiveTypeIdentity(kind: PrimitiveTypeKind, attributes: TypeAttributes): TypeIdentity;
export declare class PrimitiveType extends Type {
    readonly kind: PrimitiveTypeKind;
    readonly isNullable: boolean;
    isPrimitive(): this is PrimitiveType;
    getNonAttributeChildren(): OrderedSet<Type>;
    readonly identity: TypeIdentity;
    reconstitute<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>): void;
    protected structuralEqualityStep(_other: Type, _conflateNumbers: boolean, _queue: (a: Type, b: Type) => boolean): boolean;
}
export declare function arrayTypeIdentity(attributes: TypeAttributes, itemsRef: TypeRef): TypeIdentity;
export declare class ArrayType extends Type {
    private _itemsRef;
    readonly kind: "array";
    constructor(typeRef: TypeRef, _itemsRef?: TypeRef | undefined);
    setItems(itemsRef: TypeRef): undefined;
    private getItemsRef();
    readonly items: Type;
    getNonAttributeChildren(): OrderedSet<Type>;
    readonly isNullable: boolean;
    isPrimitive(): this is PrimitiveType;
    readonly identity: TypeIdentity;
    reconstitute<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>): void;
    protected structuralEqualityStep(other: ArrayType, _conflateNumbers: boolean, queue: (a: Type, b: Type) => boolean): boolean;
}
export declare class GenericClassProperty<T> {
    readonly typeData: T;
    readonly isOptional: boolean;
    constructor(typeData: T, isOptional: boolean);
    equals(other: any): boolean;
    hashCode(): number;
}
export declare class ClassProperty extends GenericClassProperty<TypeRef> {
    constructor(typeRef: TypeRef, isOptional: boolean);
    readonly typeRef: TypeRef;
    readonly type: Type;
}
export declare function classTypeIdentity(attributes: TypeAttributes, properties: OrderedMap<string, ClassProperty>): TypeIdentity;
export declare function mapTypeIdentify(attributes: TypeAttributes, additionalPropertiesRef: TypeRef | undefined): TypeIdentity;
export declare class ObjectType extends Type {
    readonly isFixed: boolean;
    private _properties;
    private _additionalPropertiesRef;
    readonly kind: ObjectTypeKind;
    constructor(typeRef: TypeRef, kind: ObjectTypeKind, isFixed: boolean, _properties: OrderedMap<string, ClassProperty> | undefined, _additionalPropertiesRef: TypeRef | undefined);
    setProperties(properties: OrderedMap<string, ClassProperty>, additionalPropertiesRef: TypeRef | undefined): void;
    getProperties(): OrderedMap<string, ClassProperty>;
    getSortedProperties(): OrderedMap<string, ClassProperty>;
    private getAdditionalPropertiesRef();
    getAdditionalProperties(): Type | undefined;
    getNonAttributeChildren(): OrderedSet<Type>;
    readonly isNullable: boolean;
    isPrimitive(): this is PrimitiveType;
    readonly identity: TypeIdentity;
    reconstitute<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>, canonicalOrder: boolean): void;
    protected structuralEqualityStep(other: ObjectType, _conflateNumbers: boolean, queue: (a: Type, b: Type) => boolean): boolean;
}
export declare class ClassType extends ObjectType {
    kind: "class";
    constructor(typeRef: TypeRef, isFixed: boolean, properties: OrderedMap<string, ClassProperty> | undefined);
}
export declare class MapType extends ObjectType {
    readonly kind: "map";
    constructor(typeRef: TypeRef, valuesRef: TypeRef | undefined);
    readonly values: Type;
}
export declare function enumTypeIdentity(attributes: TypeAttributes, cases: OrderedSet<string>): TypeIdentity;
export declare class EnumType extends Type {
    readonly cases: OrderedSet<string>;
    kind: "enum";
    constructor(typeRef: TypeRef, cases: OrderedSet<string>);
    readonly isNullable: boolean;
    isPrimitive(): this is PrimitiveType;
    readonly identity: TypeIdentity;
    getNonAttributeChildren(): OrderedSet<Type>;
    reconstitute<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>): void;
    protected structuralEqualityStep(other: EnumType, _conflateNumbers: boolean, _queue: (a: Type, b: Type) => void): boolean;
}
export declare function setOperationCasesEqual(ma: OrderedSet<Type>, mb: OrderedSet<Type>, conflateNumbers: boolean, membersEqual: (a: Type, b: Type) => boolean): boolean;
export declare function setOperationTypeIdentity(kind: TypeKind, attributes: TypeAttributes, memberRefs: OrderedSet<TypeRef>): TypeIdentity;
export declare function unionTypeIdentity(attributes: TypeAttributes, memberRefs: OrderedSet<TypeRef>): TypeIdentity;
export declare function intersectionTypeIdentity(attributes: TypeAttributes, memberRefs: OrderedSet<TypeRef>): TypeIdentity;
export declare abstract class SetOperationType extends Type {
    private _memberRefs;
    constructor(typeRef: TypeRef, kind: TypeKind, _memberRefs?: OrderedSet<TypeRef> | undefined);
    setMembers(memberRefs: OrderedSet<TypeRef>): void;
    protected getMemberRefs(): OrderedSet<TypeRef>;
    readonly members: OrderedSet<Type>;
    readonly sortedMembers: OrderedSet<Type>;
    getNonAttributeChildren(): OrderedSet<Type>;
    isPrimitive(): this is PrimitiveType;
    readonly identity: TypeIdentity;
    protected reconstituteSetOperation<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>, canonicalOrder: boolean, getType: (members: OrderedSet<TypeRef> | undefined) => void): void;
    protected structuralEqualityStep(other: SetOperationType, conflateNumbers: boolean, queue: (a: Type, b: Type) => boolean): boolean;
}
export declare class IntersectionType extends SetOperationType {
    kind: "intersection";
    constructor(typeRef: TypeRef, memberRefs?: OrderedSet<TypeRef>);
    readonly isNullable: boolean;
    reconstitute<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>, canonicalOrder: boolean): void;
}
export declare class UnionType extends SetOperationType {
    kind: "union";
    constructor(typeRef: TypeRef, memberRefs?: OrderedSet<TypeRef>);
    setMembers(memberRefs: OrderedSet<TypeRef>): void;
    readonly stringTypeMembers: OrderedSet<Type>;
    findMember(kind: TypeKind): Type | undefined;
    readonly isNullable: boolean;
    readonly isCanonical: boolean;
    reconstitute<T extends BaseGraphRewriteBuilder>(builder: TypeReconstituter<T>, canonicalOrder: boolean): void;
}
