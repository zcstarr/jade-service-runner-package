"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var TypeAttributes_1 = require("./TypeAttributes");
var Support_1 = require("./Support");
var StringTypes = /** @class */ (function () {
    // undefined means no restrictions
    function StringTypes(cases, allowDate, allowTime, allowDateTime) {
        this.cases = cases;
        this.allowDate = allowDate;
        this.allowTime = allowTime;
        this.allowDateTime = allowDateTime;
        if (cases === undefined) {
            Support_1.assert(!this.allowDate && !this.allowTime && !this.allowDateTime, "We can't have an unrestricted string that also allows date/times");
        }
    }
    StringTypes.fromCase = function (s, count) {
        var caseMap = {};
        caseMap[s] = count;
        return new StringTypes(immutable_1.OrderedMap([[s, count]]), false, false, false);
    };
    StringTypes.fromCases = function (cases) {
        var caseMap = {};
        for (var _i = 0, cases_1 = cases; _i < cases_1.length; _i++) {
            var s = cases_1[_i];
            caseMap[s] = 1;
        }
        return new StringTypes(immutable_1.OrderedMap(cases.map(function (s) { return [s, 1]; })), false, false, false);
    };
    Object.defineProperty(StringTypes.prototype, "isRestricted", {
        get: function () {
            return this.cases !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    StringTypes.prototype.union = function (other) {
        var cases = this.cases === undefined || other.cases === undefined
            ? undefined
            : this.cases.mergeWith(function (x, y) { return x + y; }, other.cases);
        var allowDate = cases !== undefined && (this.allowDate || other.allowDate);
        var allowTime = cases !== undefined && (this.allowTime || other.allowTime);
        var allowDateTime = cases !== undefined && (this.allowDateTime || other.allowDateTime);
        return new StringTypes(cases, allowDate, allowTime, allowDateTime);
    };
    StringTypes.prototype.intersect = function (other) {
        var thisCases = this.cases;
        var otherCases = other.cases;
        var cases;
        if (thisCases === undefined) {
            cases = otherCases;
        }
        else if (otherCases === undefined) {
            cases = thisCases;
        }
        else {
            cases = thisCases
                .keySeq()
                .toOrderedSet()
                .intersect(otherCases.keySeq().toOrderedSet())
                .toOrderedMap()
                .map(function (k) { return Math.min(Support_1.defined(thisCases.get(k)), Support_1.defined(otherCases.get(k))); });
        }
        var allowDate = this.allowDate && other.allowDate;
        var allowTime = this.allowTime && other.allowTime;
        var allowDateTime = this.allowDateTime && other.allowDateTime;
        return new StringTypes(cases, allowDate, allowTime, allowDateTime);
    };
    StringTypes.prototype.applyStringTypeMapping = function (mapping) {
        if (!this.isRestricted)
            return this;
        var kinds = [];
        if (this.allowDate) {
            kinds.push(mapping.date);
        }
        if (this.allowTime) {
            kinds.push(mapping.time);
        }
        if (this.allowDateTime) {
            kinds.push(mapping.dateTime);
        }
        if (kinds.indexOf("string") >= 0) {
            return StringTypes.unrestricted;
        }
        var allowDate = kinds.indexOf("date") >= 0;
        var allowTime = kinds.indexOf("time") >= 0;
        var allowDateTime = kinds.indexOf("date-time") >= 0;
        return new StringTypes(this.cases, allowDate, allowTime, allowDateTime);
    };
    StringTypes.prototype.equals = function (other) {
        if (!(other instanceof StringTypes))
            return false;
        return (immutable_1.is(this.cases, other.cases) &&
            this.allowDate === other.allowDate &&
            this.allowTime === other.allowTime &&
            this.allowDateTime === other.allowDateTime);
    };
    StringTypes.prototype.hashCode = function () {
        var h = immutable_1.hash(this.cases);
        h = Support_1.addHashCode(h, immutable_1.hash(this.allowDate));
        h = Support_1.addHashCode(h, immutable_1.hash(this.allowTime));
        h = Support_1.addHashCode(h, immutable_1.hash(this.allowDateTime));
        return h;
    };
    StringTypes.prototype.toString = function () {
        var parts = [];
        var enumCases = this.cases;
        if (enumCases === undefined) {
            parts.push("unrestricted");
        }
        else {
            var firstKey = enumCases.keySeq().first();
            if (firstKey === undefined) {
                parts.push("enum with no cases");
            }
            else {
                parts.push(enumCases.size.toString() + " enums: " + firstKey + " (" + enumCases.get(firstKey) + "), ...");
            }
        }
        if (this.allowDate)
            parts.push("d");
        if (this.allowTime)
            parts.push("t");
        if (this.allowDateTime)
            parts.push("dt");
        return parts.join(",");
    };
    StringTypes.unrestricted = new StringTypes(undefined, false, false, false);
    StringTypes.date = new StringTypes(immutable_1.OrderedMap(), true, false, false);
    StringTypes.time = new StringTypes(immutable_1.OrderedMap(), false, true, false);
    StringTypes.dateTime = new StringTypes(immutable_1.OrderedMap(), false, false, true);
    return StringTypes;
}());
exports.StringTypes = StringTypes;
var StringTypesTypeAttributeKind = /** @class */ (function (_super) {
    __extends(StringTypesTypeAttributeKind, _super);
    function StringTypesTypeAttributeKind() {
        return _super.call(this, "stringTypes") || this;
    }
    Object.defineProperty(StringTypesTypeAttributeKind.prototype, "inIdentity", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    StringTypesTypeAttributeKind.prototype.requiresUniqueIdentity = function (st) {
        return st.cases !== undefined && !st.cases.isEmpty();
    };
    StringTypesTypeAttributeKind.prototype.combine = function (a, b) {
        return a.union(b);
    };
    StringTypesTypeAttributeKind.prototype.intersect = function (a, b) {
        return a.intersect(b);
    };
    StringTypesTypeAttributeKind.prototype.makeInferred = function (_) {
        return undefined;
    };
    StringTypesTypeAttributeKind.prototype.stringify = function (st) {
        return st.toString();
    };
    return StringTypesTypeAttributeKind;
}(TypeAttributes_1.TypeAttributeKind));
exports.stringTypesTypeAttributeKind = new StringTypesTypeAttributeKind();
