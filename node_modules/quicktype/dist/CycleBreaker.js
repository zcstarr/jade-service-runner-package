"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Support_1 = require("./Support");
function breakCycles(outEdges, chooseBreaker) {
    var numNodes = outEdges.length;
    var inEdges = [];
    var inDegree = [];
    var outDegree = [];
    var done = [];
    var results = [];
    for (var i = 0; i < numNodes; i++) {
        inEdges.push([]);
        inDegree.push(0);
        outDegree.push(outEdges[i].length);
        done.push(false);
    }
    for (var i = 0; i < numNodes; i++) {
        for (var _i = 0, _a = outEdges[i]; _i < _a.length; _i++) {
            var n = _a[_i];
            inEdges[n].push(i);
            inDegree[n] += 1;
        }
    }
    var workList = [];
    for (var i = 0; i < numNodes; i++) {
        if (inDegree[i] === 0 || outDegree[i] === 0) {
            workList.push(i);
        }
    }
    function removeNode(node) {
        for (var _i = 0, _a = outEdges[node]; _i < _a.length; _i++) {
            var n = _a[_i];
            Support_1.assert(inDegree[n] > 0);
            inDegree[n] -= 1;
            if (inDegree[n] === 0) {
                workList.push(n);
            }
        }
        for (var _b = 0, _c = inEdges[node]; _b < _c.length; _b++) {
            var n = _c[_b];
            Support_1.assert(outDegree[n] > 0);
            outDegree[n] -= 1;
            if (outDegree[n] === 0) {
                workList.push(n);
            }
        }
        done[node] = true;
    }
    for (;;) {
        var i = workList.pop();
        if (i !== undefined) {
            if (done[i] || (inDegree[i] === 0 && outDegree[i] === 0)) {
                done[i] = true;
                continue;
            }
            Support_1.assert(inDegree[i] === 0 || outDegree[i] === 0, "Can't have nodes in the worklist with in and out edges");
            removeNode(i);
            continue;
        }
        var n = done.indexOf(false);
        if (n < 0) {
            // We're done!
            break;
        }
        // There's a cycle
        var path = [n];
        for (;;) {
            // FIXME: We look an arbitrary node that's still in the graph and follow it
            // until we see a cycle.  This cycle might not be the first cycle the needs to
            // be broken.  For example, imagine two cycles that are connected via an edge,
            // i.e. one cycle depends on the other cycle.  The dependee cycle should be
            // broken up first.
            //
            // We could count the number of reachable nodes for all nodes in the graph,
            // and then pick one of the nodes with the lowest number, which would pick
            // the dependee cycle.
            var maybeEdge = outEdges[n].find(function (x) { return !done[x]; });
            if (maybeEdge === undefined) {
                return Support_1.panic("Presumed cycle is not a cycle");
            }
            var maybeFirst = path.indexOf(maybeEdge);
            if (maybeFirst === undefined) {
                // No cycle yet, continue
                n = maybeEdge;
                path.push(n);
                continue;
            }
            // We found a cycle - break it
            var cycle = path.slice(maybeFirst);
            var _b = chooseBreaker(cycle), breakNode = _b[0], info = _b[1];
            Support_1.assert(cycle.indexOf(breakNode) >= 0, "Breaker chose an invalid node");
            removeNode(breakNode);
            results.push([breakNode, info]);
            break;
        }
        continue;
    }
    return results;
}
exports.breakCycles = breakCycles;
