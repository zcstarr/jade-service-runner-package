import { Collection, List, Set } from "immutable";
export declare function intercalate<T>(separator: T, items: Collection<any, T>): List<T>;
export declare function intercalateArray<T>(separator: T, items: T[]): T[];
export declare function setUnion<T, TSet extends Set<T>>(a: TSet, b: TSet): TSet;
export declare function unionOfSets<T, TSet extends Set<T>>(sets: TSet[]): TSet;
export declare type StringMap = {
    [name: string]: any;
};
export declare function isStringMap(x: any): x is StringMap;
export declare function isStringMap<T>(x: any, checkValue: (v: any) => v is T): x is {
    [name: string]: T;
};
export declare function checkStringMap(x: any): StringMap;
export declare function checkStringMap<T>(x: any, checkValue: (v: any) => v is T): {
    [name: string]: T;
};
export declare function checkArray(x: any): any[];
export declare function checkArray<T>(x: any, checkItem: (v: any) => v is T): T[];
export declare function mapOptional<T, U>(f: (x: T) => U, x: T | undefined): U | undefined;
export declare function defined<T>(x: T | undefined): T;
export declare function nonNull<T>(x: T | null): T;
export declare function assertNever(x: never): never;
export declare function assert(condition: boolean, message?: string): void;
export declare function panic(message: string): never;
export declare function mustNotBeCalled(): never;
export declare function mustNotHappen(): never;
export declare const hashCodeInit = 17;
export declare function addHashCode(acc: number, h: number): number;
export declare function repeated<T>(n: number, value: T): T[];
export declare function repeatedCall<T>(n: number, producer: () => T): T[];
export declare function withDefault<T>(x: T | undefined, theDefault: T): T;
export declare function errorMessage(e: any): string;
export declare function forEachSync<V>(coll: V[], f: (v: V, k: number) => Promise<void>): Promise<void>;
export declare function forEachSync<K, V>(coll: Collection.Keyed<K, V>, f: (v: V, k: K) => Promise<void>): Promise<void>;
export declare function forEachSync<V>(coll: Collection.Set<V>, f: (v: V, k: V) => Promise<void>): Promise<void>;
export declare function forEachSync<V>(coll: Collection.Indexed<V>, f: (v: V, k: number) => Promise<void>): Promise<void>;
export declare function mapSync<V, U>(coll: V[], f: (v: V, k: number) => Promise<U>): Promise<U[]>;
export declare function mapSync<K, V, U>(coll: Collection.Keyed<K, V>, f: (v: V, k: K) => Promise<U>): Promise<Collection.Keyed<K, U>>;
export declare function mapSync<V, U>(coll: Collection.Set<V>, f: (v: V, k: V) => Promise<U>): Promise<Collection.Set<U>>;
export declare function mapSync<V, U>(coll: Collection.Indexed<V>, f: (v: V, k: number) => Promise<U>): Promise<Collection.Indexed<U>>;
export declare function inflateBase64(encoded: string): string;
export declare function parseJSON(text: string, description: string, address?: string): any;
export declare function indentationString(level: number): string;
