import { Map, Set, OrderedSet, Collection } from "immutable";
import { Type } from "./Type";
import { SeparatedNamedTypes } from "./TypeUtils";
import { TypeRef, TypeBuilder, StringTypeMapping } from "./TypeBuilder";
import { GraphRewriteBuilder } from "./GraphRewriting";
import { Graph } from "./Graph";
import { TypeAttributeKind, TypeAttributes } from "./TypeAttributes";
export declare class TypeAttributeStore {
    private readonly _typeGraph;
    private _values;
    private _topLevelValues;
    constructor(_typeGraph: TypeGraph, _values: (TypeAttributes | undefined)[]);
    private getTypeIndex(t);
    attributesForType(t: Type): TypeAttributes;
    attributesForTopLevel(name: string): TypeAttributes;
    private setInMap<T>(attributes, kind, value);
    set<T>(kind: TypeAttributeKind<T>, t: Type, value: T): void;
    setForTopLevel<T>(kind: TypeAttributeKind<T>, topLevelName: string, value: T): void;
    private tryGetInMap<T>(attributes, kind);
    tryGet<T>(kind: TypeAttributeKind<T>, t: Type): T | undefined;
    tryGetForTopLevel<T>(kind: TypeAttributeKind<T>, topLevelName: string): T | undefined;
}
export declare class TypeAttributeStoreView<T> {
    private readonly _attributeStore;
    private readonly _definition;
    constructor(_attributeStore: TypeAttributeStore, _definition: TypeAttributeKind<T>);
    set(t: Type, value: T): void;
    setForTopLevel(name: string, value: T): void;
    tryGet(t: Type): T | undefined;
    get(t: Type): T;
    tryGetForTopLevel(name: string): T | undefined;
    getForTopLevel(name: string): T;
}
export declare class TypeGraph {
    private readonly _haveProvenanceAttributes;
    private _typeBuilder?;
    private _attributeStore;
    private _topLevels?;
    private _types?;
    private _parents;
    private _printOnRewrite;
    constructor(typeBuilder: TypeBuilder, _haveProvenanceAttributes: boolean);
    private readonly isFrozen;
    readonly attributeStore: TypeAttributeStore;
    freeze(topLevels: Map<string, TypeRef>, types: Type[], typeAttributes: (TypeAttributes | undefined)[]): void;
    readonly topLevels: Map<string, Type>;
    atIndex(index: number): [Type, TypeAttributes];
    filterTypes(predicate: ((t: Type) => boolean) | undefined, childrenOfType: ((t: Type) => Collection<any, Type>) | undefined, topDown: boolean): OrderedSet<Type>;
    allNamedTypes: (childrenOfType?: ((t: Type) => Collection<any, Type>) | undefined) => OrderedSet<Type>;
    allNamedTypesSeparated: (childrenOfType?: ((t: Type) => Collection<any, Type>) | undefined) => SeparatedNamedTypes;
    private allProvenance();
    setPrintOnRewrite(): void;
    private checkLostTypeAttributes(builder, newGraph);
    private printRewrite(title);
    rewrite<T extends Type>(title: string, stringTypeMapping: StringTypeMapping, alphabetizeProperties: boolean, replacementGroups: T[][], debugPrintReconstitution: boolean, replacer: (typesToReplace: Set<T>, builder: GraphRewriteBuilder<T>, forwardingRef: TypeRef) => TypeRef, force?: boolean): TypeGraph;
    remap(title: string, stringTypeMapping: StringTypeMapping, alphabetizeProperties: boolean, map: Map<Type, Type>, debugPrintRemapping: boolean): TypeGraph;
    garbageCollect(alphabetizeProperties: boolean, debugPrintReconstitution: boolean): TypeGraph;
    allTypesUnordered: () => Set<Type>;
    makeGraph(invertDirection: boolean, childrenOfType: (t: Type) => OrderedSet<Type>): Graph<Type>;
    getParentsOfType(t: Type): Set<Type>;
    printGraph(): void;
}
export declare function noneToAny(graph: TypeGraph, stringTypeMapping: StringTypeMapping, debugPrintReconstitution: boolean): TypeGraph;
export declare function optionalToNullable(graph: TypeGraph, stringTypeMapping: StringTypeMapping, debugPrintReconstitution: boolean): TypeGraph;
export declare function removeIndirectionIntersections(graph: TypeGraph, stringTypeMapping: StringTypeMapping, debugPrintRemapping: boolean): TypeGraph;
