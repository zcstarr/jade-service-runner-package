"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Support_1 = require("./Support");
var Namespace = /** @class */ (function () {
    function Namespace(name, parent, forbiddenNamespaces, additionalForbidden) {
        this._name = name;
        this.forbiddenNamespaces = forbiddenNamespaces;
        this.additionalForbidden = additionalForbidden;
        this._children = immutable_1.OrderedSet();
        this._members = immutable_1.OrderedSet();
        if (parent !== undefined) {
            this._parent = parent;
            parent.addChild(this);
        }
    }
    Namespace.prototype.addChild = function (child) {
        this._children = this._children.add(child);
    };
    Object.defineProperty(Namespace.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Namespace.prototype, "members", {
        get: function () {
            return this._members;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Namespace.prototype, "forbiddenNameds", {
        get: function () {
            // FIXME: cache
            return (_a = this.additionalForbidden).union.apply(_a, this.forbiddenNamespaces.map(function (ns) { return ns.members.toSet(); }).toArray());
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    Namespace.prototype.add = function (named) {
        this._members = this._members.add(named);
        return named;
    };
    Namespace.prototype.equals = function (other) {
        return this === other;
    };
    Namespace.prototype.hashCode = function () {
        var hashAccumulator = immutable_1.hash(this._name);
        if (this._parent !== undefined) {
            hashAccumulator += this._parent.hashCode();
        }
        return hashAccumulator | 0;
    };
    return Namespace;
}());
exports.Namespace = Namespace;
// `Namer`s are invoked to figure out what names to assign non-fixed `Name`s,
// and in particular to resolve conflicts.  Those arise under two circumstances,
// which can also combine:
//
// 1. A proposed name is the same as an already assigned name that's forbidden
//    for the name to be assigned.
// 2. There is more than one `Name` about to be assigned a name that all have
//    the same proposed name.
//
// The namer is invoked with the set of all assigned, forbidden names,
// the requested name, and the `Name`s to assign names to.
//
// `Namer` is a class so that we can compare namers and put them into immutable
// collections.
var Namer = /** @class */ (function () {
    function Namer(name, nameStyle, prefixes) {
        this.name = name;
        this.nameStyle = nameStyle;
        this._prefixes = immutable_1.OrderedSet(prefixes);
    }
    Namer.prototype.assignNames = function (names, forbiddenNames, namesToAssign) {
        Support_1.assert(!namesToAssign.isEmpty(), "Number of names can't be less than 1");
        var allAssignedNames = immutable_1.Map();
        var remainingNamesToAssign = namesToAssign;
        var namesToPrefix = immutable_1.List();
        var _loop_1 = function () {
            var name = remainingNamesToAssign.first();
            if (name === undefined)
                return "break";
            remainingNamesToAssign = remainingNamesToAssign.rest();
            var proposedNames = name.proposeUnstyledNames(names);
            var namingFunction = name.namingFunction;
            // Find the first proposed name that isn't proposed by
            // any of the other names and that isn't already forbidden.
            var maybeUniqueName = proposedNames.find(function (proposed) {
                return !forbiddenNames.has(namingFunction.nameStyle(proposed)) &&
                    namesToAssign.every(function (n) { return n === name || !n.proposeUnstyledNames(names).contains(proposed); });
            });
            if (maybeUniqueName !== undefined) {
                var styledName = namingFunction.nameStyle(maybeUniqueName);
                var assigned = name.nameAssignments(forbiddenNames, styledName);
                if (assigned) {
                    allAssignedNames = allAssignedNames.merge(assigned);
                    forbiddenNames = forbiddenNames.union(assigned.toSet());
                    return "continue";
                }
            }
            // There's no unique name, or it couldn't be assigned, so
            // we need to prefix-name this one.
            namesToPrefix = namesToPrefix.push(name);
        };
        for (;;) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        var prefixes = this._prefixes;
        var suffixNumber = 1;
        for (;;) {
            var name = namesToPrefix.first();
            if (name === undefined)
                break;
            var originalName = Support_1.defined(name.proposeUnstyledNames(names).first());
            var nameToTry = void 0;
            var prefix = prefixes.first();
            if (prefix) {
                nameToTry = prefix + "_" + originalName;
                prefixes = prefixes.rest();
            }
            else {
                nameToTry = originalName + "_" + suffixNumber.toString();
                suffixNumber++;
            }
            var styledName = name.namingFunction.nameStyle(nameToTry);
            var assigned = name.nameAssignments(forbiddenNames, styledName);
            if (assigned === null)
                continue;
            allAssignedNames = allAssignedNames.merge(assigned);
            forbiddenNames = forbiddenNames.union(assigned.toSet());
            namesToPrefix = namesToPrefix.rest();
        }
        return allAssignedNames;
    };
    return Namer;
}());
exports.Namer = Namer;
var funPrefixes = [
    "Purple",
    "Fluffy",
    "Tentacled",
    "Sticky",
    "Indigo",
    "Indecent",
    "Hilarious",
    "Ambitious",
    "Cunning",
    "Magenta",
    "Frisky",
    "Mischievous",
    "Braggadocious"
];
function funPrefixNamer(name, nameStyle) {
    return new Namer(name, nameStyle, funPrefixes);
}
exports.funPrefixNamer = funPrefixNamer;
// FIXME: I think the type hierarchy is somewhat wrong here.  `FixedName`
// should be a `Name`, but the non-fixed names should probably have their
// own common superclass.  Most methods of `Name` make sense only either
// for `FixedName` or the non-fixed names.
var Name = /** @class */ (function () {
    // If a Named is fixed, the namingFunction is undefined.
    function Name(_namingFunction, order) {
        var _this = this;
        this._namingFunction = _namingFunction;
        this.order = order;
        this._associates = immutable_1.Set();
        this.firstProposedName = function (names) {
            return Support_1.defined(_this.proposeUnstyledNames(names).first());
        };
    }
    Name.prototype.equals = function (other) {
        return this === other;
    };
    Name.prototype.hashCode = function () {
        return 0;
    };
    Name.prototype.addAssociate = function (associate) {
        this._associates = this._associates.add(associate);
    };
    Name.prototype.isFixed = function () {
        return this instanceof FixedName;
    };
    Object.defineProperty(Name.prototype, "namingFunction", {
        get: function () {
            return Support_1.defined(this._namingFunction);
        },
        enumerable: true,
        configurable: true
    });
    Name.prototype.nameAssignments = function (forbiddenNames, assignedName) {
        if (forbiddenNames.has(assignedName))
            return null;
        var assignments = immutable_1.Map().set(this, assignedName);
        var success = true;
        this._associates.forEach(function (an) {
            var associatedAssignedName = an.getName(assignedName);
            if (forbiddenNames.has(associatedAssignedName)) {
                success = false;
                return false;
            }
            assignments = assignments.set(an, associatedAssignedName);
        });
        if (!success)
            return null;
        return assignments;
    };
    return Name;
}());
exports.Name = Name;
// FIXME: FixedNameds should optionally be user-configurable
var FixedName = /** @class */ (function (_super) {
    __extends(FixedName, _super);
    function FixedName(_fixedName) {
        var _this = _super.call(this, undefined, 0) || this;
        _this._fixedName = _fixedName;
        return _this;
    }
    Object.defineProperty(FixedName.prototype, "dependencies", {
        get: function () {
            return immutable_1.List();
        },
        enumerable: true,
        configurable: true
    });
    FixedName.prototype.addAssociate = function (_) {
        return Support_1.panic("Cannot add associates to fixed names");
    };
    Object.defineProperty(FixedName.prototype, "fixedName", {
        get: function () {
            return this._fixedName;
        },
        enumerable: true,
        configurable: true
    });
    FixedName.prototype.proposeUnstyledNames = function (_) {
        return Support_1.panic("Only fixedName should be called on FixedName.");
    };
    FixedName.prototype.hashCode = function () {
        return (_super.prototype.hashCode.call(this) + immutable_1.hash(this._fixedName)) | 0;
    };
    return FixedName;
}(Name));
exports.FixedName = FixedName;
var SimpleName = /** @class */ (function (_super) {
    __extends(SimpleName, _super);
    function SimpleName(_unstyledNames, namingFunction, order) {
        var _this = _super.call(this, namingFunction, order) || this;
        _this._unstyledNames = _unstyledNames;
        return _this;
    }
    Object.defineProperty(SimpleName.prototype, "dependencies", {
        get: function () {
            return immutable_1.List();
        },
        enumerable: true,
        configurable: true
    });
    SimpleName.prototype.proposeUnstyledNames = function (_) {
        return this._unstyledNames;
    };
    SimpleName.prototype.hashCode = function () {
        return (_super.prototype.hashCode.call(this) + this._unstyledNames.hashCode()) | 0;
    };
    return SimpleName;
}(Name));
exports.SimpleName = SimpleName;
var AssociatedName = /** @class */ (function (_super) {
    __extends(AssociatedName, _super);
    function AssociatedName(_sponsor, order, getName) {
        var _this = _super.call(this, undefined, order) || this;
        _this._sponsor = _sponsor;
        _this.getName = getName;
        return _this;
    }
    Object.defineProperty(AssociatedName.prototype, "dependencies", {
        get: function () {
            return immutable_1.List([this._sponsor]);
        },
        enumerable: true,
        configurable: true
    });
    AssociatedName.prototype.proposeUnstyledNames = function (_) {
        return Support_1.panic("AssociatedName must be assigned via its sponsor");
    };
    return AssociatedName;
}(Name));
exports.AssociatedName = AssociatedName;
var DependencyName = /** @class */ (function (_super) {
    __extends(DependencyName, _super);
    function DependencyName(namingFunction, order, _proposeUnstyledName) {
        var _this = _super.call(this, namingFunction, order) || this;
        _this._proposeUnstyledName = _proposeUnstyledName;
        var dependencies = [];
        _proposeUnstyledName(function (n) {
            dependencies.push(n);
            return "0xDEADBEEF";
        });
        _this._dependencies = immutable_1.OrderedSet(dependencies);
        return _this;
    }
    Object.defineProperty(DependencyName.prototype, "dependencies", {
        get: function () {
            return this._dependencies.toList();
        },
        enumerable: true,
        configurable: true
    });
    DependencyName.prototype.proposeUnstyledNames = function (names) {
        var _this = this;
        return immutable_1.OrderedSet([
            this._proposeUnstyledName(function (n) {
                Support_1.assert(_this._dependencies.has(n), "DependencyName proposer is not pure");
                return Support_1.defined(names.get(n));
            })
        ]);
    };
    DependencyName.prototype.hashCode = function () {
        return (_super.prototype.hashCode.call(this) + this._dependencies.hashCode()) | 0;
    };
    return DependencyName;
}(Name));
exports.DependencyName = DependencyName;
function keywordNamespace(name, keywords) {
    var ns = new Namespace(name, undefined, immutable_1.Set(), immutable_1.Set());
    for (var _i = 0, keywords_1 = keywords; _i < keywords_1.length; _i++) {
        var kw = keywords_1[_i];
        ns.add(new FixedName(kw));
    }
    return ns;
}
exports.keywordNamespace = keywordNamespace;
function allNamespacesRecursively(namespaces) {
    return namespaces.union.apply(namespaces, namespaces.map(function (ns) { return allNamespacesRecursively(ns.children); }).toArray());
}
var NamingContext = /** @class */ (function () {
    function NamingContext(rootNamespaces) {
        var _this = this;
        this.names = immutable_1.Map();
        this._namedsForName = immutable_1.Map();
        this.isReadyToBeNamed = function (named) {
            if (_this.names.has(named))
                return false;
            return named.dependencies.every(function (n) { return _this.names.has(n); });
        };
        this.areForbiddensFullyNamed = function (namespace) {
            return namespace.forbiddenNameds.every(function (n) { return _this.names.has(n); });
        };
        this.isConflicting = function (namedNamespace, proposed) {
            var namedsForProposed = _this._namedsForName.get(proposed);
            // If the name is not assigned at all, there is no conflict.
            if (namedsForProposed === undefined)
                return false;
            // The name is assigned, but it might still not be forbidden.
            var conflicting;
            namedsForProposed.forEach(function (n) {
                if (namedNamespace.members.contains(n) || namedNamespace.forbiddenNameds.contains(n)) {
                    conflicting = n;
                    return false;
                }
            });
            return conflicting !== undefined;
        };
        this.assign = function (named, namedNamespace, name) {
            Support_1.assert(!_this.names.has(named), "Named assigned twice");
            Support_1.assert(!_this.isConflicting(namedNamespace, name), "Assigned name conflicts");
            _this.names = _this.names.set(named, name);
            var namedsForName = _this._namedsForName.get(name);
            if (namedsForName === undefined) {
                namedsForName = immutable_1.Set();
                _this._namedsForName = _this._namedsForName.set(name, namedsForName);
            }
            _this._namedsForName.set(name, namedsForName.add(named));
        };
        this.namespaces = allNamespacesRecursively(rootNamespaces);
    }
    return NamingContext;
}());
// Naming algorithm
function assignNames(rootNamespaces) {
    var ctx = new NamingContext(rootNamespaces);
    // Assign all fixed names.
    ctx.namespaces.forEach(function (ns) {
        return ns.members.forEach(function (n) {
            if (!n.isFixed())
                return;
            ctx.assign(n, ns, n.fixedName);
        });
    });
    var _loop_2 = function () {
        // 1. Find a namespace whose forbiddens are all fully named, and which has
        //    at least one unnamed Named that has all its dependencies satisfied.
        //    If no such namespace exists we're either done, or there's an unallowed
        //    cycle.
        var unfinishedNamespaces = ctx.namespaces.filter(ctx.areForbiddensFullyNamed);
        var readyNamespace = unfinishedNamespaces.find(function (ns) { return ns.members.some(ctx.isReadyToBeNamed); });
        if (!readyNamespace) {
            return { value: ctx.names };
        }
        var forbiddenNames = readyNamespace.members
            .toSet()
            .union(readyNamespace.forbiddenNameds)
            .filter(function (n) { return ctx.names.has(n); })
            .map(function (n) { return Support_1.defined(ctx.names.get(n)); })
            .toSet();
        var _loop_3 = function () {
            var allReadyNames = readyNamespace.members.filter(ctx.isReadyToBeNamed);
            var minOrderName = allReadyNames.minBy(function (n) { return n.order; });
            if (minOrderName === undefined)
                return "break";
            var minOrder = minOrderName.order;
            var readyNames = allReadyNames.filter(function (n) { return n.order === minOrder; });
            // It would be nice if we had tuples, then we wouldn't have to do this in
            // two steps.
            var byNamingFunction = readyNames.groupBy(function (n) { return n.namingFunction; });
            byNamingFunction.forEach(function (namedsForNamingFunction, namer) {
                var byProposed = namedsForNamingFunction.groupBy(function (n) {
                    return n.namingFunction.nameStyle(n.firstProposedName(ctx.names));
                });
                byProposed.forEach(function (nameds, _) {
                    // 3. Use each set's naming function to name its members.
                    var names = namer.assignNames(ctx.names, forbiddenNames, nameds);
                    names.forEach(function (assigned, name) { return ctx.assign(name, readyNamespace, assigned); });
                    forbiddenNames = forbiddenNames.union(names.toSet());
                });
            });
        };
        // 2. From low order to high order, sort those names into sets where all
        //    members of a set propose the same name and have the same naming
        //    function.
        for (;;) {
            var state_2 = _loop_3();
            if (state_2 === "break")
                break;
        }
    };
    for (;;) {
        var state_3 = _loop_2();
        if (typeof state_3 === "object")
            return state_3.value;
    }
}
exports.assignNames = assignNames;
