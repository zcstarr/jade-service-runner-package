"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var handlebars = require("handlebars");
var Type_1 = require("./Type");
var TypeUtils_1 = require("./TypeUtils");
var Naming_1 = require("./Naming");
var Renderer_1 = require("./Renderer");
var Support_1 = require("./Support");
var Source_1 = require("./Source");
var lodash_1 = require("lodash");
var DeclarationIR_1 = require("./DeclarationIR");
var TypeGraph_1 = require("./TypeGraph");
var TypeAttributes_1 = require("./TypeAttributes");
var AccessorNames_1 = require("./AccessorNames");
var Transformers_1 = require("./Transformers");
var wordWrap = require("wordwrap")(90);
var topLevelNameOrder = 1;
var givenNameOrder = 10;
var inferredNameOrder = 30;
var classPropertyNameOrder = 20;
var assignedClassPropertyNameOrder = 10;
var enumCaseNameOrder = 20;
var assignedEnumCaseNameOrder = 10;
var unionMemberNameOrder = 40;
function splitDescription(descriptions) {
    if (descriptions === undefined)
        return undefined;
    var description = descriptions.join("\n\n").trim();
    if (description === "")
        return undefined;
    return wordWrap(description)
        .split("\n")
        .map(function (l) { return l.trim(); });
}
var assignedNameAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedName");
var assignedPropertyNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedPropertyNames");
var assignedMemberNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedMemberNames");
var assignedCaseNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedCaseNames");
var ConvenienceRenderer = /** @class */ (function (_super) {
    __extends(ConvenienceRenderer, _super);
    function ConvenienceRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._alphabetizeProperties = false;
        _this.addDependenciesForNamedType = function (type, named) {
            var dependencyNames = _this.makeNamedTypeDependencyNames(type, named);
            for (var _i = 0, dependencyNames_1 = dependencyNames; _i < dependencyNames_1.length; _i++) {
                var dn = dependencyNames_1[_i];
                _this.globalNamespace.add(dn);
            }
        };
        _this.addNameForTopLevel = function (type, givenName) {
            var maybeNamedType = _this.namedTypeToNameForTopLevel(type);
            var name = _this.makeNameForTopLevel(type, givenName, maybeNamedType);
            _this.globalNamespace.add(name);
            var dependencyNames = _this.makeTopLevelDependencyNames(type, name);
            for (var _i = 0, dependencyNames_2 = dependencyNames; _i < dependencyNames_2.length; _i++) {
                var dn = dependencyNames_2[_i];
                _this.globalNamespace.add(dn);
            }
            if (maybeNamedType !== undefined) {
                _this.addDependenciesForNamedType(maybeNamedType, name);
                _this.nameStoreView.set(maybeNamedType, name);
            }
            return name;
        };
        _this.addNameForNamedType = function (type) {
            var existing = _this.nameStoreView.tryGet(type);
            if (existing !== undefined)
                return existing;
            var name = _this.globalNamespace.add(_this.makeNameForNamedType(type));
            _this.addDependenciesForNamedType(type, name);
            _this.nameStoreView.set(type, name);
            return name;
        };
        _this.addPropertyNames = function (o, className) {
            var _a = _this.processForbiddenWordsInfo(_this.forbiddenForObjectProperties(o, className), "forbidden-for-properties"), forbiddenNames = _a.forbiddenNames, forbiddenNamespaces = _a.forbiddenNamespaces;
            var ns;
            var accessorNames = AccessorNames_1.objectPropertyNames(o, _this.targetLanguage.name);
            var names = o
                .getSortedProperties()
                .map(function (p, jsonName) {
                var _a = AccessorNames_1.getAccessorName(accessorNames, jsonName), assignedName = _a[0], isFixed = _a[1];
                var name;
                if (isFixed) {
                    name = new Naming_1.FixedName(Support_1.defined(assignedName));
                }
                else {
                    name = _this.makeNameForProperty(o, className, p, jsonName, assignedName);
                }
                if (name === undefined)
                    return undefined;
                if (ns === undefined) {
                    ns = new Naming_1.Namespace(o.getCombinedName(), _this.globalNamespace, forbiddenNamespaces, forbiddenNames);
                }
                ns.add(name);
                for (var _i = 0, _b = _this.makePropertyDependencyNames(o, className, p, jsonName, name); _i < _b.length; _i++) {
                    var depName = _b[_i];
                    ns.add(depName);
                }
                return name;
            })
                .filter(function (v) { return v !== undefined; });
            Support_1.defined(_this._propertyNamesStoreView).set(o, names);
        };
        _this.addUnionMemberNames = function (u, unionName) {
            var memberNamer = _this._unionMemberNamer;
            if (memberNamer === null)
                return;
            var _a = _this.processForbiddenWordsInfo(_this.forbiddenForUnionMembers(u, unionName), "forbidden-for-union-members"), forbiddenNames = _a.forbiddenNames, forbiddenNamespaces = _a.forbiddenNamespaces;
            var ns;
            if (_this.unionMembersInGlobalNamespace) {
                ns = _this.globalNamespace;
            }
            else {
                ns = new Naming_1.Namespace(u.getCombinedName(), _this.globalNamespace, forbiddenNamespaces, forbiddenNames);
            }
            var names = immutable_1.Map();
            u.members.forEach(function (t) {
                var name = _this.makeNameForUnionMember(u, unionName, Transformers_1.followTargetType(t));
                names = names.set(t, ns.add(name));
            });
            Support_1.defined(_this._memberNamesStoreView).set(u, names);
        };
        // FIXME: this is very similar to addPropertyNameds and addUnionMemberNames
        _this.addEnumCaseNames = function (e, enumName) {
            if (_this._enumCaseNamer === null)
                return;
            var _a = _this.processForbiddenWordsInfo(_this.forbiddenForEnumCases(e, enumName), "forbidden-for-enum-cases"), forbiddenNames = _a.forbiddenNames, forbiddenNamespaces = _a.forbiddenNamespaces;
            var ns;
            if (_this.enumCasesInGlobalNamespace) {
                ns = _this.globalNamespace;
            }
            else {
                ns = new Naming_1.Namespace(e.getCombinedName(), _this.globalNamespace, forbiddenNamespaces, forbiddenNames);
            }
            var names = immutable_1.Map();
            var accessorNames = AccessorNames_1.enumCaseNames(e, _this.targetLanguage.name);
            e.cases.forEach(function (caseName) {
                var _a = AccessorNames_1.getAccessorName(accessorNames, caseName), assignedName = _a[0], isFixed = _a[1];
                var name;
                if (isFixed) {
                    name = new Naming_1.FixedName(Support_1.defined(assignedName));
                }
                else {
                    name = _this.makeNameForEnumCase(e, enumName, caseName, assignedName);
                }
                names = names.set(caseName, ns.add(name));
            });
            Support_1.defined(_this._caseNamesStoreView).set(e, names);
        };
        _this.childrenOfType = function (t) {
            var names = _this.names;
            if (t instanceof Type_1.ClassType) {
                var propertyNameds_1 = Support_1.defined(_this._propertyNamesStoreView).get(t);
                var sortedMap = t
                    .getProperties()
                    .filter(function (_, n) { return propertyNameds_1.get(n) !== undefined; })
                    .map(function (p) { return p.type; })
                    .sortBy(function (_, n) { return Support_1.defined(names.get(Support_1.defined(propertyNameds_1.get(n)))); });
                return sortedMap.toOrderedSet();
            }
            return t.getChildren().toOrderedSet();
        };
        _this.proposedUnionMemberNameForTypeKind = function (_kind) {
            return null;
        };
        _this.nameForNamedType = function (t) {
            return _this.nameStoreView.get(t);
        };
        _this.forEachTopLevel = function (blankLocations, f, predicate) {
            var topLevels;
            if (predicate !== undefined) {
                topLevels = _this.topLevels.filter(predicate);
            }
            else {
                topLevels = _this.topLevels;
            }
            _this.forEachWithBlankLines(topLevels, blankLocations, function (t, name) {
                return f(t, _this.nameStoreView.getForTopLevel(name));
            });
        };
        _this.setAlphabetizeProperties = function (value) {
            _this._alphabetizeProperties = value;
        };
        _this.forEachClassProperty = function (o, blankLocations, f) {
            var propertyNames = Support_1.defined(_this._propertyNamesStoreView).get(o);
            if (_this._alphabetizeProperties) {
                var alphabetizedPropertyNames = propertyNames.sortBy(function (n) { return _this.names.get(n); }).toOrderedMap();
                _this.forEachWithBlankLines(alphabetizedPropertyNames, blankLocations, function (name, jsonName) {
                    var p = Support_1.defined(o.getProperties().get(jsonName));
                    f(name, jsonName, p);
                });
            }
            else {
                _this.forEachWithBlankLines(o.getProperties(), blankLocations, function (p, jsonName) {
                    var name = Support_1.defined(propertyNames.get(jsonName));
                    f(name, jsonName, p);
                });
            }
        };
        _this.nameForUnionMember = function (u, t) {
            return Support_1.defined(Support_1.defined(_this._memberNamesStoreView)
                .get(u)
                .get(t));
        };
        _this.forEachUnionMember = function (u, members, blankLocations, sortOrder, f) {
            var iterateMembers = members === null ? u.members : members;
            if (sortOrder === null) {
                sortOrder = function (n) { return Support_1.defined(_this.names.get(n)); };
            }
            var memberNames = Support_1.defined(_this._memberNamesStoreView)
                .get(u)
                .filter(function (_, t) { return iterateMembers.has(t); });
            var sortedMemberNames = memberNames.sortBy(sortOrder).toOrderedMap();
            _this.forEachWithBlankLines(sortedMemberNames, blankLocations, f);
        };
        _this.forEachEnumCase = function (e, blankLocations, f) {
            var caseNames = Support_1.defined(_this._caseNamesStoreView).get(e);
            var sortedCaseNames = caseNames.sortBy(function (n) { return _this.names.get(n); }).toOrderedMap();
            _this.forEachWithBlankLines(sortedCaseNames, blankLocations, f);
        };
        _this.forEachEnum = function (blankLocations, f) {
            _this.forEachSpecificNamedType(blankLocations, _this.enums, f);
        };
        _this.forEachUnion = function (blankLocations, f) {
            _this.forEachSpecificNamedType(blankLocations, _this.namedUnions, f);
        };
        _this.forEachNamedType = function (blankLocations, objectFunc, enumFunc, unionFunc) {
            _this.forEachWithBlankLines(Support_1.defined(_this._namedTypes), blankLocations, function (t) {
                if (t instanceof Type_1.ObjectType) {
                    // FIXME: This is ugly.  We can't runtime check that the function
                    // takes full object types if we have them.
                    _this.callForNamedType(t, objectFunc);
                }
                else if (t instanceof Type_1.EnumType) {
                    _this.callForNamedType(t, enumFunc);
                }
                else if (t instanceof Type_1.UnionType) {
                    _this.callForNamedType(t, unionFunc);
                }
                else {
                    return Support_1.panic("Named type that's neither a class nor union");
                }
            });
        };
        // You should never have to use this to produce parts of your generated
        // code.  If you need to modify a Name, for example to change its casing,
        // use `modifySource`.
        _this.sourcelikeToString = function (src) {
            return Source_1.serializeRenderResult(Source_1.sourcelikeToSource(src), _this.names, "").lines.join("\n");
        };
        return _this;
    }
    Object.defineProperty(ConvenienceRenderer.prototype, "topLevels", {
        get: function () {
            return this.typeGraph.topLevels;
        },
        enumerable: true,
        configurable: true
    });
    ConvenienceRenderer.prototype.forbiddenNamesForGlobalNamespace = function () {
        return [];
    };
    ConvenienceRenderer.prototype.forbiddenForObjectProperties = function (_o, _className) {
        return { names: [], includeGlobalForbidden: false };
    };
    ConvenienceRenderer.prototype.forbiddenForUnionMembers = function (_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
    };
    ConvenienceRenderer.prototype.forbiddenForEnumCases = function (_e, _enumName) {
        return { names: [], includeGlobalForbidden: false };
    };
    ConvenienceRenderer.prototype.makeTopLevelDependencyNames = function (_t, _topLevelName) {
        return [];
    };
    ConvenienceRenderer.prototype.makeNamedTypeDependencyNames = function (_t, _name) {
        return [];
    };
    ConvenienceRenderer.prototype.makeNameForTransformation = function (_t, _typeName) {
        return undefined;
    };
    ConvenienceRenderer.prototype.namedTypeToNameForTopLevel = function (type) {
        if (TypeUtils_1.isNamedType(type)) {
            return type;
        }
        return undefined;
    };
    Object.defineProperty(ConvenienceRenderer.prototype, "unionMembersInGlobalNamespace", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "enumCasesInGlobalNamespace", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "needsTypeDeclarationBeforeUse", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    ConvenienceRenderer.prototype.canBeForwardDeclared = function (_t) {
        return Support_1.panic("If needsTypeDeclarationBeforeUse returns true, canBeForwardDeclared must be implemented");
    };
    ConvenienceRenderer.prototype.unionNeedsName = function (u) {
        return TypeUtils_1.nullableFromUnion(u) === null;
    };
    Object.defineProperty(ConvenienceRenderer.prototype, "globalNamespace", {
        get: function () {
            return Support_1.defined(this._globalNamespace);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "nameStoreView", {
        get: function () {
            return Support_1.defined(this._nameStoreView);
        },
        enumerable: true,
        configurable: true
    });
    ConvenienceRenderer.prototype.descriptionForType = function (t) {
        var description = this.typeGraph.attributeStore.tryGet(TypeAttributes_1.descriptionTypeAttributeKind, t);
        return splitDescription(description);
    };
    ConvenienceRenderer.prototype.descriptionForClassProperty = function (c, name) {
        var descriptions = this.typeGraph.attributeStore.tryGet(TypeAttributes_1.propertyDescriptionsTypeAttributeKind, c);
        if (descriptions === undefined)
            return undefined;
        return splitDescription(descriptions.get(name));
    };
    ConvenienceRenderer.prototype.setUpNaming = function () {
        var _this = this;
        this._nameStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedNameAttributeKind);
        this._propertyNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedPropertyNamesAttributeKind);
        this._memberNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedMemberNamesAttributeKind);
        this._caseNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedCaseNamesAttributeKind);
        this._namesForTransformations = immutable_1.OrderedMap();
        this._namedTypeNamer = this.makeNamedTypeNamer();
        this._unionMemberNamer = this.makeUnionMemberNamer();
        this._enumCaseNamer = this.makeEnumCaseNamer();
        this._globalForbiddenNamespace = Naming_1.keywordNamespace("forbidden", this.forbiddenNamesForGlobalNamespace());
        this._otherForbiddenNamespaces = immutable_1.Map();
        this._globalNamespace = new Naming_1.Namespace("global", undefined, immutable_1.Set([this._globalForbiddenNamespace]), immutable_1.Set());
        var _a = this.typeGraph.allNamedTypesSeparated(), objects = _a.objects, enums = _a.enums, unions = _a.unions;
        var namedUnions = unions.filter(function (u) { return _this.unionNeedsName(u); }).toOrderedSet();
        this.topLevels.forEach(function (t, name) {
            _this.nameStoreView.setForTopLevel(name, _this.addNameForTopLevel(t, name));
        });
        objects.forEach(function (o) {
            var name = _this.addNameForNamedType(o);
            _this.addPropertyNames(o, name);
        });
        enums.forEach(function (e) {
            var name = _this.addNameForNamedType(e);
            _this.addEnumCaseNames(e, name);
        });
        namedUnions.forEach(function (u) {
            var name = _this.addNameForNamedType(u);
            _this.addUnionMemberNames(u, name);
        });
        this.typeGraph.allTypesUnordered().forEach(function (t) { return _this.addNameForTransformation(t); });
        return immutable_1.OrderedSet([this._globalForbiddenNamespace, this._globalNamespace]).union(this._otherForbiddenNamespaces.valueSeq());
    };
    ConvenienceRenderer.prototype.makeNameForTopLevel = function (_t, givenName, _maybeNamedType) {
        return new Naming_1.SimpleName(immutable_1.OrderedSet([givenName]), Support_1.defined(this._namedTypeNamer), topLevelNameOrder);
    };
    ConvenienceRenderer.prototype.makeNameForType = function (t, namer, givenOrder, inferredOrder) {
        var names = t.getNames();
        var order = names.areInferred ? inferredOrder : givenOrder;
        return new Naming_1.SimpleName(names.proposedNames, namer, order);
    };
    ConvenienceRenderer.prototype.makeNameForNamedType = function (t) {
        return this.makeNameForType(t, Support_1.defined(this._namedTypeNamer), givenNameOrder, inferredNameOrder);
    };
    Object.defineProperty(ConvenienceRenderer.prototype, "typesWithNamedTransformations", {
        get: function () {
            return Support_1.defined(this._namesForTransformations);
        },
        enumerable: true,
        configurable: true
    });
    ConvenienceRenderer.prototype.nameForTransformation = function (t) {
        var xf = Transformers_1.transformationForType(t);
        if (xf === undefined)
            return undefined;
        var name = Support_1.defined(this._namesForTransformations).get(t);
        if (name === undefined) {
            return Support_1.panic("No name for transformation");
        }
        return name;
    };
    ConvenienceRenderer.prototype.addNameForTransformation = function (t) {
        var xf = Transformers_1.transformationForType(t);
        if (xf === undefined)
            return;
        Support_1.assert(Support_1.defined(this._namesForTransformations).get(t) === undefined, "Tried to give two names to the same transformation");
        var name = this.makeNameForTransformation(xf.targetType, this.nameStoreView.tryGet(xf.targetType));
        if (name === undefined)
            return;
        this.globalNamespace.add(name);
        this._namesForTransformations = Support_1.defined(this._namesForTransformations).set(t, name);
    };
    ConvenienceRenderer.prototype.processForbiddenWordsInfo = function (info, namespaceName) {
        var forbiddenNames = [];
        var forbiddenStrings = [];
        for (var _i = 0, _a = info.names; _i < _a.length; _i++) {
            var nameOrString = _a[_i];
            if (typeof nameOrString === "string") {
                forbiddenStrings.push(nameOrString);
            }
            else {
                forbiddenNames.push(nameOrString);
            }
        }
        var namespace = Support_1.defined(this._otherForbiddenNamespaces).get(namespaceName);
        if (forbiddenStrings.length > 0 && namespace === undefined) {
            namespace = Naming_1.keywordNamespace(namespaceName, forbiddenStrings);
            this._otherForbiddenNamespaces = Support_1.defined(this._otherForbiddenNamespaces).set(namespaceName, namespace);
        }
        var forbiddenNamespaces = immutable_1.Set();
        if (info.includeGlobalForbidden) {
            forbiddenNamespaces = forbiddenNamespaces.add(Support_1.defined(this._globalForbiddenNamespace));
        }
        if (namespace !== undefined) {
            forbiddenNamespaces = forbiddenNamespaces.add(namespace);
        }
        return { forbiddenNames: immutable_1.Set(forbiddenNames), forbiddenNamespaces: forbiddenNamespaces };
    };
    ConvenienceRenderer.prototype.makeNameForProperty = function (o, _className, p, jsonName, assignedName) {
        var namer = this.namerForObjectProperty(o, p);
        if (namer === null)
            return undefined;
        // FIXME: This alternative should really depend on what the
        // actual name of the class ends up being.  We can do this
        // with a DependencyName.
        // Also, we currently don't have any languages where properties
        // are global, so collisions here could only occur where two
        // properties of the same class have the same name, in which case
        // the alternative would also be the same, i.e. useless.  But
        // maybe we'll need global properties for some weird language at
        // some point.
        var alternative = o.getCombinedName() + "_" + jsonName;
        var order = assignedName === undefined ? classPropertyNameOrder : assignedClassPropertyNameOrder;
        var names = assignedName === undefined ? [jsonName, alternative] : [assignedName];
        return new Naming_1.SimpleName(immutable_1.OrderedSet(names), namer, order);
    };
    ConvenienceRenderer.prototype.makePropertyDependencyNames = function (_o, _className, _p, _jsonName, _name) {
        return [];
    };
    ConvenienceRenderer.prototype.makeNameForUnionMember = function (u, unionName, t) {
        var _this = this;
        var _a = AccessorNames_1.unionMemberName(u, t, this.targetLanguage.name), assignedName = _a[0], isFixed = _a[1];
        if (isFixed) {
            return new Naming_1.FixedName(Support_1.defined(assignedName));
        }
        return new Naming_1.DependencyName(Support_1.nonNull(this._unionMemberNamer), unionMemberNameOrder, function (lookup) {
            if (assignedName !== undefined)
                return assignedName;
            return _this.proposeUnionMemberName(u, unionName, t, lookup);
        });
    };
    ConvenienceRenderer.prototype.makeNameForEnumCase = function (e, _enumName, caseName, assignedName) {
        // FIXME: See the FIXME in `makeNameForProperty`.  We do have global
        // enum cases, though (in Go), so this is actually useful already.
        var alternative = e.getCombinedName() + "_" + caseName;
        var order = assignedName === undefined ? enumCaseNameOrder : assignedEnumCaseNameOrder;
        var names = assignedName === undefined ? [caseName, alternative] : [assignedName];
        return new Naming_1.SimpleName(immutable_1.OrderedSet(names), Support_1.nonNull(this._enumCaseNamer), order);
    };
    Object.defineProperty(ConvenienceRenderer.prototype, "namedUnions", {
        get: function () {
            return Support_1.defined(this._namedUnions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "haveNamedUnions", {
        get: function () {
            return !this.namedUnions.isEmpty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "haveNamedTypes", {
        get: function () {
            return !Support_1.defined(this._namedTypes).isEmpty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "haveUnions", {
        get: function () {
            return Support_1.defined(this._haveUnions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "haveMaps", {
        get: function () {
            return Support_1.defined(this._haveMaps);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "haveOptionalProperties", {
        get: function () {
            return Support_1.defined(this._haveOptionalProperties);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "enums", {
        // FIXME: Inconsistently named, though technically correct.  Right now all enums are named,
        // but this should really be called `namedEnums`.
        get: function () {
            return Support_1.defined(this._namedEnums);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConvenienceRenderer.prototype, "haveEnums", {
        get: function () {
            return !this.enums.isEmpty();
        },
        enumerable: true,
        configurable: true
    });
    ConvenienceRenderer.prototype.proposeUnionMemberName = function (_u, _unionName, fieldType, lookup) {
        var _this = this;
        var simpleName = this.proposedUnionMemberNameForTypeKind(fieldType.kind);
        if (simpleName !== null) {
            return simpleName;
        }
        var typeNameForUnionMember = function (t) {
            return TypeUtils_1.matchTypeExhaustive(t, function (_noneType) {
                return Support_1.panic("None type should have been replaced");
            }, function (_anyType) { return "anything"; }, function (_nullType) { return "null"; }, function (_boolType) { return "bool"; }, function (_integerType) { return "integer"; }, function (_doubleType) { return "double"; }, function (_stringType) { return "string"; }, function (arrayType) { return typeNameForUnionMember(arrayType.items) + "_array"; }, function (classType) { return lookup(_this.nameForNamedType(classType)); }, function (mapType) { return typeNameForUnionMember(mapType.values) + "_map"; }, function (objectType) {
                Support_1.assert(_this.targetLanguage.supportsFullObjectType, "Object type should have been replaced in `replaceObjectType`");
                return lookup(_this.nameForNamedType(objectType));
            }, function (_enumType) { return "enum"; }, function (_unionType) { return "union"; }, function (_dateType) { return "date"; }, function (_timeType) { return "time"; }, function (_dateTimeType) { return "date_time"; });
        };
        return typeNameForUnionMember(fieldType);
    };
    ConvenienceRenderer.prototype.isForwardDeclaredType = function (t) {
        return Support_1.defined(this._declarationIR).forwardedTypes.has(t);
    };
    ConvenienceRenderer.prototype.isImplicitCycleBreaker = function (_t) {
        return Support_1.panic("A renderer that invokes isCycleBreakerType must implement canBeCycleBreakerType");
    };
    ConvenienceRenderer.prototype.canBreakCycles = function (_t) {
        return true;
    };
    ConvenienceRenderer.prototype.isCycleBreakerType = function (t) {
        var _this = this;
        if (this._cycleBreakerTypes === undefined) {
            this._cycleBreakerTypes = DeclarationIR_1.cycleBreakerTypesForGraph(this.typeGraph, function (s) { return _this.isImplicitCycleBreaker(s); }, function (s) { return _this.canBreakCycles(s); });
        }
        return this._cycleBreakerTypes.has(t);
    };
    ConvenienceRenderer.prototype.forEachDeclaration = function (blankLocations, f) {
        this.forEachWithBlankLines(Support_1.defined(this._declarationIR).declarations, blankLocations, f);
    };
    ConvenienceRenderer.prototype.nameForEnumCase = function (e, caseName) {
        var caseNames = Support_1.defined(this._caseNamesStoreView).get(e);
        return Support_1.defined(caseNames.get(caseName));
    };
    ConvenienceRenderer.prototype.forEachTransformation = function (blankLocations, f) {
        this.forEachWithBlankLines(Support_1.defined(this._namesForTransformations), blankLocations, f);
    };
    ConvenienceRenderer.prototype.callForNamedType = function (t, f) {
        f(t, this.nameForNamedType(t));
    };
    ConvenienceRenderer.prototype.forEachSpecificNamedType = function (blankLocations, types, f) {
        var _this = this;
        this.forEachWithBlankLines(types, blankLocations, function (t) {
            _this.callForNamedType(t, f);
        });
    };
    ConvenienceRenderer.prototype.forEachObject = function (blankLocations, f) {
        // FIXME: This is ugly.
        this.forEachSpecificNamedType(blankLocations, Support_1.defined(this._namedObjects), f);
    };
    ConvenienceRenderer.prototype.forEachUniqueUnion = function (blankLocations, uniqueValue, f) {
        var firstUnionByValue = immutable_1.OrderedMap();
        this.namedUnions.forEach(function (u) {
            var v = uniqueValue(u);
            if (!firstUnionByValue.has(v)) {
                firstUnionByValue = firstUnionByValue.set(v, u);
            }
        });
        this.forEachWithBlankLines(firstUnionByValue, blankLocations, f);
    };
    Object.defineProperty(ConvenienceRenderer.prototype, "commentLineStart", {
        get: function () {
            return "// ";
        },
        enumerable: true,
        configurable: true
    });
    ConvenienceRenderer.prototype.emitCommentLines = function (lines, lineStart, beforeLine, afterLine, firstLineStart) {
        if (lineStart === undefined) {
            lineStart = this.commentLineStart;
        }
        if (firstLineStart === undefined) {
            firstLineStart = lineStart;
        }
        if (beforeLine !== undefined) {
            this.emitLine(beforeLine);
        }
        var first = true;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            var start = first ? firstLineStart : lineStart;
            if (line === "") {
                start = lodash_1.trimEnd(start);
            }
            this.emitLine(start, lodash_1.trimEnd(line));
            first = false;
        }
        if (afterLine !== undefined) {
            this.emitLine(afterLine);
        }
    };
    ConvenienceRenderer.prototype.emitDescription = function (description) {
        if (description === undefined)
            return;
        // FIXME: word-wrap
        this.emitDescriptionBlock(description);
    };
    ConvenienceRenderer.prototype.emitDescriptionBlock = function (lines) {
        this.emitCommentLines(lines);
    };
    ConvenienceRenderer.prototype.emitPropertyTable = function (c, makePropertyRow) {
        var _this = this;
        var table = [];
        var emitTable = function () {
            if (table.length === 0)
                return;
            _this.emitTable(table);
            table = [];
        };
        this.forEachClassProperty(c, "none", function (name, jsonName, p) {
            var description = _this.descriptionForClassProperty(c, jsonName);
            if (description !== undefined) {
                emitTable();
                _this.emitDescription(description);
            }
            table.push(makePropertyRow(name, jsonName, p));
        });
        emitTable();
    };
    ConvenienceRenderer.prototype.processGraph = function () {
        var _this = this;
        this._declarationIR = DeclarationIR_1.declarationsForGraph(this.typeGraph, this.needsTypeDeclarationBeforeUse ? function (t) { return _this.canBeForwardDeclared(t); } : undefined, this.childrenOfType, function (t) {
            if (t instanceof Type_1.UnionType) {
                return _this.unionNeedsName(t);
            }
            return TypeUtils_1.isNamedType(t);
        });
        var types = this.typeGraph.allTypesUnordered();
        this._haveUnions = types.some(function (t) { return t instanceof Type_1.UnionType; });
        this._haveMaps = types.some(function (t) { return t instanceof Type_1.MapType; });
        this._haveOptionalProperties = types
            .filter(function (t) { return t instanceof Type_1.ClassType; })
            .some(function (c) { return c.getProperties().some(function (p) { return p.isOptional; }); });
        this._namedTypes = this._declarationIR.declarations.filter(function (d) { return d.kind === "define"; }).map(function (d) { return d.type; });
        var _a = TypeUtils_1.separateNamedTypes(this._namedTypes), objects = _a.objects, enums = _a.enums, unions = _a.unions;
        this._namedObjects = objects;
        this._namedEnums = enums;
        this._namedUnions = unions;
    };
    ConvenienceRenderer.prototype.emitSource = function (givenOutputFilename) {
        this.processGraph();
        this.emitSourceStructure(givenOutputFilename);
    };
    ConvenienceRenderer.prototype.makeHandlebarsContextForUnionMember = function (t, name) {
        var value = this.makeHandlebarsContextForType(t);
        value.assignedName = Support_1.defined(this.names.get(name));
        return value;
    };
    ConvenienceRenderer.prototype.makeHandlebarsContextForType = function (t) {
        var value = { type: { kind: t.kind, index: t.typeRef.index } };
        var maybeName = this.nameStoreView.tryGet(t);
        if (maybeName !== undefined) {
            value.assignedName = this.names.get(maybeName);
        }
        return value;
    };
    ConvenienceRenderer.prototype.makeHandlebarsContext = function () {
        var _this = this;
        this.processGraph();
        var allTypes = [];
        this.typeGraph.allTypesUnordered().forEach(function (t) {
            var value = _this.makeHandlebarsContextForType(t);
            if (t instanceof Type_1.ClassType) {
                var properties_1 = {};
                _this.forEachClassProperty(t, "none", function (name, jsonName, p) {
                    var propertyValue = _this.makeHandlebarsContextForType(p.type);
                    propertyValue.isOptional = p.isOptional;
                    propertyValue.assignedName = Support_1.defined(_this.names.get(name));
                    properties_1[jsonName] = propertyValue;
                });
                value.properties = properties_1;
            }
            else if (t instanceof Type_1.EnumType) {
                var cases_1 = {};
                _this.forEachEnumCase(t, "none", function (name, jsonName) {
                    cases_1[jsonName] = { assignedName: Support_1.defined(_this.names.get(name)) };
                });
                value.cases = cases_1;
            }
            else if (t instanceof Type_1.UnionType) {
                var members_1 = [];
                // FIXME: It's a bit ugly to have these two cases.
                if (Support_1.defined(_this._memberNamesStoreView).tryGet(t) === undefined) {
                    t.members.forEach(function (m) {
                        members_1.push(_this.makeHandlebarsContextForType(m));
                    });
                }
                else {
                    _this.forEachUnionMember(t, null, "none", null, function (name, m) {
                        members_1.push(_this.makeHandlebarsContextForUnionMember(m, name));
                    });
                }
                value.members = members_1;
            }
            var index = t.typeRef.index;
            while (allTypes.length <= index) {
                allTypes.push(undefined);
            }
            allTypes[index] = value;
        });
        var namedTypes = [];
        var addNamedType = function (t) {
            namedTypes.push(allTypes[t.typeRef.index]);
        };
        this.forEachNamedType("none", addNamedType, addNamedType, addNamedType);
        var topLevels = {};
        this.topLevels.forEach(function (t, name) {
            var value = allTypes[t.typeRef.index];
            value.assignedTopLevelName = _this.names.get(_this.nameStoreView.getForTopLevel(name));
            topLevels[name] = value;
        });
        return { allTypes: allTypes, topLevels: topLevels, namedTypes: namedTypes };
    };
    ConvenienceRenderer.prototype.registerHandlebarsHelpers = function (context) {
        _super.prototype.registerHandlebarsHelpers.call(this, context);
        handlebars.registerHelper("with_type", function (t, options) {
            return options.fn(context.allTypes[t.index]);
        });
    };
    ConvenienceRenderer.prototype.forEachType = function (process) {
        var visitedTypes = immutable_1.Set();
        var processed = immutable_1.Set();
        var queue = this.typeGraph.topLevels.valueSeq().toArray();
        function visit(t) {
            if (visitedTypes.has(t))
                return;
            queue.push.apply(queue, t.getChildren().toArray());
            visitedTypes = visitedTypes.add(t);
            processed = processed.add(process(t));
        }
        for (;;) {
            var maybeType = queue.pop();
            if (maybeType === undefined) {
                break;
            }
            visit(maybeType);
        }
        return processed;
    };
    return ConvenienceRenderer;
}(Renderer_1.Renderer));
exports.ConvenienceRenderer = ConvenienceRenderer;
