"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("../Type");
var TypeUtils_1 = require("../TypeUtils");
var Support_1 = require("../Support");
var UnifyClasses_1 = require("../UnifyClasses");
var Messages_1 = require("../Messages");
var TypeAttributes_1 = require("../TypeAttributes");
function flattenUnions(graph, stringTypeMapping, conflateNumbers, makeObjectTypes, debugPrintReconstitution) {
    var needsRepeat = false;
    function replace(types, builder, forwardingRef) {
        var unionBuilder = new UnifyClasses_1.UnifyUnionBuilder(builder, makeObjectTypes, true, function (trefs) {
            Support_1.assert(trefs.length > 0, "Must have at least one type to build union");
            trefs = trefs.map(function (tref) { return builder.reconstituteType(tref.deref()[0]); });
            if (trefs.length === 1) {
                return trefs[0];
            }
            needsRepeat = true;
            return builder.getUnionType(TypeAttributes_1.emptyTypeAttributes, immutable_1.OrderedSet(trefs));
        });
        return UnifyClasses_1.unifyTypes(types, TypeAttributes_1.emptyTypeAttributes, builder, unionBuilder, conflateNumbers, forwardingRef);
    }
    var allUnions = graph.allTypesUnordered().filter(function (t) { return t instanceof Type_1.UnionType; });
    var nonCanonicalUnions = allUnions.filter(function (u) { return !u.isCanonical; });
    var foundIntersection = false;
    var groups = TypeUtils_1.makeGroupsToFlatten(nonCanonicalUnions, function (members) {
        Messages_1.messageAssert(!members.isEmpty(), "IRNoEmptyUnions", {});
        if (!members.some(function (m) { return m instanceof Type_1.IntersectionType; }))
            return true;
        // FIXME: This is stupid.  `flattenUnions` returns true when no more union
        // flattening is necessary, but `resolveIntersections` can introduce new
        // unions that might require flattening, so now `flattenUnions` needs to take
        // that into account.  Either change `resolveIntersections` such that it
        // doesn't introduce non-canonical unions (by using `unifyTypes`), or have
        // some other way to tell whether more work is needed that doesn't require
        // the two passes to know about each other.
        foundIntersection = true;
        return false;
    });
    graph = graph.rewrite("flatten unions", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
    // console.log(`flattened ${nonCanonicalUnions.size} of ${unions.size} unions`);
    return [graph, !needsRepeat && !foundIntersection];
}
exports.flattenUnions = flattenUnions;
