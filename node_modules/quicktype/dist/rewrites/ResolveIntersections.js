"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var UnionBuilder_1 = require("../UnionBuilder");
var Type_1 = require("../Type");
var TypeUtils_1 = require("../TypeUtils");
var Support_1 = require("../Support");
var TypeAttributes_1 = require("../TypeAttributes");
function canResolve(t) {
    var members = TypeUtils_1.setOperationMembersRecursively(t, undefined)[0];
    if (members.size <= 1)
        return true;
    return members.every(function (m) { return !(m instanceof Type_1.UnionType) || m.isCanonical; });
}
function attributesForTypes(types) {
    return types
        .toMap()
        .map(function (t) { return t.getAttributes(); })
        .mapKeys(function (t) { return t.kind; });
}
var IntersectionAccumulator = /** @class */ (function () {
    function IntersectionAccumulator() {
        this._primitiveAttributes = immutable_1.OrderedMap();
        this._arrayAttributes = TypeAttributes_1.emptyTypeAttributes;
        // We start out with all object types allowed, which means
        // _additionalPropertyTypes is empty - no restrictions - and
        // _classProperties is empty - no defined properties so far.
        //
        // If _additionalPropertyTypes is undefined, no additional
        // properties are allowed anymore.  If _classProperties is
        // undefined, no object types are allowed, in which case
        // _additionalPropertyTypes must also be undefined;
        this._objectProperties = immutable_1.OrderedMap();
        this._objectAttributes = TypeAttributes_1.emptyTypeAttributes;
        this._additionalPropertyTypes = immutable_1.OrderedSet();
        this._lostTypeAttributes = false;
    }
    IntersectionAccumulator.prototype.updatePrimitiveTypes = function (members) {
        var types = members.filter(function (t) { return Type_1.isPrimitiveTypeKind(t.kind); });
        var attributes = attributesForTypes(types);
        this._primitiveAttributes = this._primitiveAttributes.mergeWith(function (a, b) { return TypeAttributes_1.combineTypeAttributes("intersect", a, b); }, attributes);
        var kinds = types.map(function (t) { return t.kind; });
        if (this._primitiveTypes === undefined) {
            this._primitiveTypes = kinds;
            return;
        }
        var haveNumber = this._primitiveTypes.find(Type_1.isNumberTypeKind) !== undefined && kinds.find(Type_1.isNumberTypeKind) !== undefined;
        this._primitiveTypes = this._primitiveTypes.intersect(kinds);
        if (haveNumber && this._primitiveTypes.find(Type_1.isNumberTypeKind) === undefined) {
            // One set has integer, the other has double.  The intersection
            // of that is integer.
            this._primitiveTypes = this._primitiveTypes.add("integer");
        }
    };
    IntersectionAccumulator.prototype.updateArrayItemTypes = function (members) {
        var maybeArray = members.find(function (t) { return t instanceof Type_1.ArrayType; });
        if (maybeArray === undefined) {
            this._arrayItemTypes = false;
            return;
        }
        this._arrayAttributes = TypeAttributes_1.combineTypeAttributes("intersect", this._arrayAttributes, maybeArray.getAttributes());
        if (this._arrayItemTypes === undefined) {
            this._arrayItemTypes = immutable_1.OrderedSet();
        }
        else if (this._arrayItemTypes !== false) {
            this._arrayItemTypes = this._arrayItemTypes.add(maybeArray.items);
        }
    };
    IntersectionAccumulator.prototype.updateObjectProperties = function (members) {
        var _this = this;
        var maybeObject = members.find(function (t) { return t instanceof Type_1.ObjectType; });
        if (maybeObject === undefined) {
            this._objectProperties = undefined;
            this._additionalPropertyTypes = undefined;
            return;
        }
        this._objectAttributes = TypeAttributes_1.combineTypeAttributes("intersect", this._objectAttributes, maybeObject.getAttributes());
        var objectAdditionalProperties = maybeObject.getAdditionalProperties();
        if (this._objectProperties === undefined) {
            Support_1.assert(this._additionalPropertyTypes === undefined);
            return;
        }
        var allPropertyNames = this._objectProperties
            .keySeq()
            .toOrderedSet()
            .union(maybeObject.getProperties().keySeq());
        allPropertyNames.forEach(function (name) {
            var existing = Support_1.defined(_this._objectProperties).get(name);
            var newProperty = maybeObject.getProperties().get(name);
            if (existing !== undefined && newProperty !== undefined) {
                var cp = new Type_1.GenericClassProperty(existing.typeData.add(newProperty.type), existing.isOptional && newProperty.isOptional);
                _this._objectProperties = Support_1.defined(_this._objectProperties).set(name, cp);
            }
            else if (existing !== undefined && objectAdditionalProperties !== undefined) {
                var cp = new Type_1.GenericClassProperty(existing.typeData.add(objectAdditionalProperties), existing.isOptional);
                _this._objectProperties = Support_1.defined(_this._objectProperties).set(name, cp);
            }
            else if (existing !== undefined) {
                _this._objectProperties = Support_1.defined(_this._objectProperties).remove(name);
            }
            else if (newProperty !== undefined && _this._additionalPropertyTypes !== undefined) {
                var types = _this._additionalPropertyTypes.add(newProperty.type);
                _this._objectProperties = Support_1.defined(_this._objectProperties).set(name, new Type_1.GenericClassProperty(types, newProperty.isOptional));
            }
            else if (newProperty !== undefined) {
                _this._objectProperties = Support_1.defined(_this._objectProperties).remove(name);
            }
            else {
                return Support_1.mustNotHappen();
            }
        });
        if (this._additionalPropertyTypes !== undefined && objectAdditionalProperties !== undefined) {
            this._additionalPropertyTypes = this._additionalPropertyTypes.add(objectAdditionalProperties);
        }
        else if (this._additionalPropertyTypes !== undefined || objectAdditionalProperties !== undefined) {
            this._additionalPropertyTypes = undefined;
            this._lostTypeAttributes = true;
        }
    };
    IntersectionAccumulator.prototype.addUnionSet = function (members) {
        this.updatePrimitiveTypes(members);
        this.updateArrayItemTypes(members);
        this.updateObjectProperties(members);
    };
    IntersectionAccumulator.prototype.addType = function (t) {
        var _this = this;
        var attributes = t.getAttributes();
        TypeUtils_1.matchTypeExhaustive(t, function (_noneType) {
            return Support_1.panic("There shouldn't be a none type");
        }, function (_anyType) {
            return Support_1.panic("The any type should have been filtered out in setOperationMembersRecursively");
        }, function (nullType) { return _this.addUnionSet(immutable_1.OrderedSet([nullType])); }, function (boolType) { return _this.addUnionSet(immutable_1.OrderedSet([boolType])); }, function (integerType) { return _this.addUnionSet(immutable_1.OrderedSet([integerType])); }, function (doubleType) { return _this.addUnionSet(immutable_1.OrderedSet([doubleType])); }, function (stringType) { return _this.addUnionSet(immutable_1.OrderedSet([stringType])); }, function (arrayType) { return _this.addUnionSet(immutable_1.OrderedSet([arrayType])); }, function (_classType) { return Support_1.panic("We should never see class types in intersections"); }, function (_mapType) { return Support_1.panic("We should never see map types in intersections"); }, function (objectType) { return _this.addUnionSet(immutable_1.OrderedSet([objectType])); }, function (_enumType) { return Support_1.panic("We should never see enum types in intersections"); }, function (unionType) {
            attributes = TypeAttributes_1.combineTypeAttributes("intersect", [attributes].concat(unionType.members.toArray().map(function (m) { return m.getAttributes(); })));
            _this.addUnionSet(unionType.members);
        }, function (dateType) { return _this.addUnionSet(immutable_1.OrderedSet([dateType])); }, function (timeType) { return _this.addUnionSet(immutable_1.OrderedSet([timeType])); }, function (dateTimeType) { return _this.addUnionSet(immutable_1.OrderedSet([dateTimeType])); });
        return TypeAttributes_1.makeTypeAttributesInferred(attributes);
    };
    Object.defineProperty(IntersectionAccumulator.prototype, "arrayData", {
        get: function () {
            if (this._arrayItemTypes === undefined || this._arrayItemTypes === false) {
                return Support_1.panic("This should not be called if the type can't be an array");
            }
            return this._arrayItemTypes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IntersectionAccumulator.prototype, "objectData", {
        get: function () {
            if (this._objectProperties === undefined) {
                Support_1.assert(this._additionalPropertyTypes === undefined);
                return undefined;
            }
            return [this._objectProperties, this._additionalPropertyTypes];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IntersectionAccumulator.prototype, "enumCases", {
        get: function () {
            return Support_1.panic("We don't support enums in intersections");
        },
        enumerable: true,
        configurable: true
    });
    IntersectionAccumulator.prototype.getMemberKinds = function () {
        var _this = this;
        var kinds = Support_1.defined(this._primitiveTypes)
            .toOrderedMap()
            .map(function (k) { return Support_1.defined(_this._primitiveAttributes.get(k)); });
        var maybeDoubleAttributes = this._primitiveAttributes.get("double");
        // If double was eliminated, add its attributes to integer
        if (maybeDoubleAttributes !== undefined && !kinds.has("double")) {
            kinds = kinds.map(function (a, k) {
                if (k !== "integer")
                    return a;
                return TypeAttributes_1.combineTypeAttributes("intersect", a, maybeDoubleAttributes);
            });
        }
        if (immutable_1.OrderedSet.isOrderedSet(this._arrayItemTypes)) {
            kinds = kinds.set("array", this._arrayAttributes);
        }
        else if (!this._arrayAttributes.isEmpty()) {
            this._lostTypeAttributes = true;
        }
        if (this._objectProperties !== undefined) {
            kinds = kinds.set("object", this._objectAttributes);
        }
        else if (!this._objectAttributes.isEmpty()) {
            this._lostTypeAttributes = true;
        }
        return kinds;
    };
    Object.defineProperty(IntersectionAccumulator.prototype, "lostTypeAttributes", {
        get: function () {
            return this._lostTypeAttributes;
        },
        enumerable: true,
        configurable: true
    });
    return IntersectionAccumulator;
}());
var IntersectionUnionBuilder = /** @class */ (function (_super) {
    __extends(IntersectionUnionBuilder, _super);
    function IntersectionUnionBuilder() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._createdNewIntersections = false;
        return _this;
    }
    IntersectionUnionBuilder.prototype.makeIntersection = function (members, attributes) {
        var _this = this;
        var reconstitutedMembers = members.map(function (t) { return _this.typeBuilder.reconstituteTypeRef(t.typeRef); });
        var first = Support_1.defined(reconstitutedMembers.first());
        if (reconstitutedMembers.size === 1) {
            this.typeBuilder.addAttributes(first, attributes);
            return first;
        }
        this._createdNewIntersections = true;
        return this.typeBuilder.getUniqueIntersectionType(attributes, reconstitutedMembers);
    };
    Object.defineProperty(IntersectionUnionBuilder.prototype, "createdNewIntersections", {
        get: function () {
            return this._createdNewIntersections;
        },
        enumerable: true,
        configurable: true
    });
    IntersectionUnionBuilder.prototype.makeObject = function (maybeData, typeAttributes, forwardingRef) {
        var _this = this;
        if (maybeData === undefined) {
            return Support_1.panic("Either properties or additional properties must be given to make an object type");
        }
        var propertyTypes = maybeData[0], maybeAdditionalProperties = maybeData[1];
        var properties = propertyTypes.map(function (cp) { return new Type_1.ClassProperty(_this.makeIntersection(cp.typeData, immutable_1.Map()), cp.isOptional); });
        var additionalProperties = maybeAdditionalProperties === undefined
            ? undefined
            : this.makeIntersection(maybeAdditionalProperties, TypeAttributes_1.emptyTypeAttributes);
        return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
    };
    IntersectionUnionBuilder.prototype.makeArray = function (arrays, typeAttributes, forwardingRef) {
        // FIXME: attributes
        var itemsType = this.makeIntersection(arrays, immutable_1.Map());
        var tref = this.typeBuilder.getArrayType(itemsType, forwardingRef);
        this.typeBuilder.addAttributes(tref, typeAttributes);
        return tref;
    };
    return IntersectionUnionBuilder;
}(UnionBuilder_1.UnionBuilder));
function resolveIntersections(graph, stringTypeMapping, debugPrintReconstitution) {
    var needsRepeat = false;
    function replace(types, builder, forwardingRef) {
        var intersections = types.filter(function (t) { return t instanceof Type_1.IntersectionType; });
        var _a = TypeUtils_1.setOperationMembersRecursively(intersections.toArray(), "intersect"), members = _a[0], intersectionAttributes = _a[1];
        if (members.isEmpty()) {
            var t = builder.getPrimitiveType("any", intersectionAttributes, forwardingRef);
            return t;
        }
        if (members.size === 1) {
            return builder.reconstituteType(Support_1.defined(members.first()), intersectionAttributes, forwardingRef);
        }
        var accumulator = new IntersectionAccumulator();
        var extraAttributes = TypeAttributes_1.makeTypeAttributesInferred(TypeAttributes_1.combineTypeAttributes("intersect", members.toArray().map(function (t) { return accumulator.addType(t); })));
        var attributes = TypeAttributes_1.combineTypeAttributes("intersect", intersectionAttributes, extraAttributes);
        var unionBuilder = new IntersectionUnionBuilder(builder);
        var tref = unionBuilder.buildUnion(accumulator, true, attributes, forwardingRef);
        if (unionBuilder.createdNewIntersections) {
            needsRepeat = true;
        }
        return tref;
    }
    // FIXME: We need to handle intersections that resolve to the same set of types.
    // See for example the intersections-nested.schema example.
    var allIntersections = graph.allTypesUnordered().filter(function (t) { return t instanceof Type_1.IntersectionType; });
    var resolvableIntersections = allIntersections.filter(canResolve);
    var groups = TypeUtils_1.makeGroupsToFlatten(resolvableIntersections, undefined);
    graph = graph.rewrite("resolve intersections", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
    // console.log(`resolved ${resolvableIntersections.size} of ${intersections.size} intersections`);
    return [graph, !needsRepeat && allIntersections.size === resolvableIntersections.size];
}
exports.resolveIntersections = resolveIntersections;
