"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Type_1 = require("../Type");
var TypeUtils_1 = require("../TypeUtils");
var Support_1 = require("../Support");
var UnifyClasses_1 = require("../UnifyClasses");
var REQUIRED_OVERLAP = 3 / 4;
// FIXME: Allow some type combinations to unify, like different enums,
// enums with strings, integers with doubles, maps with objects of
// the correct type.
function typeSetsCanBeCombined(s1, s2) {
    return Type_1.setOperationCasesEqual(s1, s2, true, function (a, b) { return a.structurallyCompatible(b, true); });
}
function canBeCombined(c1, c2, onlyWithSameProperties) {
    var p1 = c1.getProperties();
    var p2 = c2.getProperties();
    if (onlyWithSameProperties) {
        if (p1.size !== p2.size) {
            return false;
        }
    }
    else {
        if (p1.size < p2.size * REQUIRED_OVERLAP || p2.size < p1.size * REQUIRED_OVERLAP) {
            return false;
        }
    }
    var larger;
    var smaller;
    if (p1.size > p2.size) {
        larger = p1;
        smaller = p2;
    }
    else {
        larger = p2;
        smaller = p1;
    }
    var maxFaults;
    if (onlyWithSameProperties) {
        maxFaults = 0;
    }
    else {
        var minOverlap = Math.ceil(larger.size * REQUIRED_OVERLAP);
        maxFaults = smaller.size - minOverlap;
    }
    Support_1.assert(maxFaults >= 0, "Max faults negative");
    var commonProperties = [];
    var faults = 0;
    smaller.forEach(function (_, name) {
        if (larger.has(name)) {
            commonProperties.push(name);
        }
        else {
            faults += 1;
            if (faults > maxFaults)
                return false;
        }
    });
    if (faults > maxFaults)
        return false;
    for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
        var name = commonProperties_1[_i];
        var ts = smaller.get(name);
        var tl = larger.get(name);
        if (ts === undefined || tl === undefined) {
            return Support_1.panic("Both classes should have property " + name);
        }
        var tsCases = TypeUtils_1.nonNullTypeCases(ts.type);
        var tlCases = TypeUtils_1.nonNullTypeCases(tl.type);
        if (!tsCases.isEmpty() && !tlCases.isEmpty() && !typeSetsCanBeCombined(tsCases, tlCases)) {
            return false;
        }
    }
    return true;
}
function tryAddToClique(c, clique, onlyWithSameProperties) {
    for (var _i = 0, _a = clique.prototypes; _i < _a.length; _i++) {
        var prototype = _a[_i];
        if (prototype.structurallyCompatible(c)) {
            clique.members.push(c);
            return true;
        }
    }
    for (var _b = 0, _c = clique.prototypes; _b < _c.length; _b++) {
        var prototype = _c[_b];
        if (canBeCombined(prototype, c, onlyWithSameProperties)) {
            clique.prototypes.push(c);
            clique.members.push(c);
            return true;
        }
    }
    return false;
}
function findSimilarityCliques(graph, onlyWithSameProperties, includeFixedClasses) {
    var unprocessedClasses = graph
        .allNamedTypesSeparated()
        .objects.filter(function (o) { return o instanceof Type_1.ClassType && (includeFixedClasses || !o.isFixed); })
        .toArray();
    var cliques = [];
    // FIXME: Don't build cliques one by one.  Instead have a list of
    // cliques-in-progress and iterate over all classes.  Add the class
    // to the first clique that it's part of.  If there's none, make it
    // into a new clique.
    while (unprocessedClasses.length > 0) {
        var classesLeft = [];
        var clique = { members: [unprocessedClasses[0]], prototypes: [unprocessedClasses[0]] };
        for (var i = 1; i < unprocessedClasses.length; i++) {
            var c = unprocessedClasses[i];
            if (!tryAddToClique(c, clique, onlyWithSameProperties)) {
                classesLeft.push(c);
            }
        }
        if (clique.members.length > 1) {
            cliques.push(clique.members);
        }
        unprocessedClasses = classesLeft;
    }
    return cliques;
}
exports.findSimilarityCliques = findSimilarityCliques;
function combineClasses(graph, stringTypeMapping, alphabetizeProperties, conflateNumbers, onlyWithSameProperties, debugPrintReconstitution) {
    var cliques = findSimilarityCliques(graph, onlyWithSameProperties, false);
    function makeCliqueClass(clique, builder, forwardingRef) {
        Support_1.assert(clique.size > 0, "Clique can't be empty");
        var attributes = TypeUtils_1.combineTypeAttributesOfTypes("union", clique);
        return UnifyClasses_1.unifyTypes(clique, attributes, builder, UnifyClasses_1.unionBuilderForUnification(builder, false, false, conflateNumbers), conflateNumbers, forwardingRef);
    }
    return graph.rewrite("combine classes", stringTypeMapping, alphabetizeProperties, cliques, debugPrintReconstitution, makeCliqueClass);
}
exports.combineClasses = combineClasses;
