"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Type_1 = require("../Type");
var Support_1 = require("../Support");
var TypeAttributes_1 = require("../TypeAttributes");
function replaceObjectType(graph, stringTypeMapping, _conflateNumbers, leaveFullObjects, debugPrintReconstitution) {
    function replace(setOfOneType, builder, forwardingRef) {
        var o = Support_1.defined(setOfOneType.first());
        var attributes = o.getAttributes();
        var properties = o.getProperties();
        var additionalProperties = o.getAdditionalProperties();
        function reconstituteProperties() {
            return properties.map(function (cp) { return new Type_1.ClassProperty(builder.reconstituteTypeRef(cp.typeRef), cp.isOptional); });
        }
        function makeClass() {
            return builder.getUniqueClassType(attributes, true, reconstituteProperties(), forwardingRef);
        }
        function reconstituteAdditionalProperties() {
            return builder.reconstituteType(Support_1.defined(additionalProperties));
        }
        if (additionalProperties === undefined) {
            return makeClass();
        }
        if (properties.isEmpty()) {
            return builder.getMapType(attributes, reconstituteAdditionalProperties(), forwardingRef);
        }
        if (additionalProperties.kind === "any") {
            // FIXME: Warn that we're losing additional property semantics.
            builder.setLostTypeAttributes();
            return makeClass();
        }
        // FIXME: Warn that we're losing class semantics.
        var propertyTypes = properties
            .map(function (cp) { return cp.type; })
            .toOrderedSet()
            .add(additionalProperties);
        var union = builder.lookupTypeRefs(propertyTypes.toArray().map(function (t) { return t.typeRef; }));
        if (union === undefined) {
            var reconstitutedTypes = propertyTypes.map(function (t) { return builder.reconstituteType(t); });
            union = builder.getUniqueUnionType(TypeAttributes_1.emptyTypeAttributes, reconstitutedTypes);
            // This is the direct unification alternative.  Weirdly enough, it is a tiny
            // bit slower.  It gives the same results.
            /*
            union = unifyTypes(
                propertyTypes,
                combineTypeAttributes(propertyTypes.toArray().map(t => t.getAttributes())),
                builder,
                unionBuilderForUnification(builder, false, false, false, conflateNumbers),
                conflateNumbers
            );
            */
        }
        return builder.getMapType(attributes, union, forwardingRef);
    }
    var allObjectTypes = graph.allTypesUnordered().filter(function (t) { return t.kind === "object"; });
    var objectTypesToReplace = leaveFullObjects
        ? allObjectTypes.filter(function (o) { return o.getProperties().isEmpty() || o.getAdditionalProperties() === undefined; })
        : allObjectTypes;
    var groups = objectTypesToReplace.toArray().map(function (t) { return [t]; });
    return graph.rewrite("replace object type", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
}
exports.replaceObjectType = replaceObjectType;
