"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var TypeUtils_1 = require("../TypeUtils");
var Support_1 = require("../Support");
var TypeAttributes_1 = require("../TypeAttributes");
var StringTypes_1 = require("../StringTypes");
var MIN_LENGTH_FOR_ENUM = 10;
function shouldBeEnum(enumCases) {
    Support_1.assert(enumCases.size > 0, "How did we end up with zero enum cases?");
    var someCaseIsNotNumber = enumCases.keySeq().some(function (key) { return /^(\-|\+)?[0-9]+(\.[0-9]+)?$/.test(key) === false; });
    var numValues = enumCases.map(function (n) { return n; }).reduce(function (a, b) { return a + b; });
    return numValues >= MIN_LENGTH_FOR_ENUM && enumCases.size < Math.sqrt(numValues) && someCaseIsNotNumber;
}
function expandStrings(graph, stringTypeMapping, inference, debugPrintReconstitution) {
    function replaceString(group, builder, forwardingRef) {
        Support_1.assert(group.size === 1);
        var t = Support_1.defined(group.first());
        var stringTypes = TypeUtils_1.stringTypesForType(t);
        var attributes = t.getAttributes().filterNot(function (a) { return a === stringTypes; });
        var mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted) {
            return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
        }
        var types = [];
        var cases = Support_1.defined(mappedStringTypes.cases);
        if (cases.size > 0) {
            if (inference === "all" || (inference === "infer" && shouldBeEnum(cases))) {
                types.push(builder.getEnumType(TypeAttributes_1.emptyTypeAttributes, cases.keySeq().toOrderedSet()));
            }
            else {
                return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
            }
        }
        if (mappedStringTypes.allowDate) {
            types.push(builder.getPrimitiveType("date"));
        }
        if (mappedStringTypes.allowTime) {
            types.push(builder.getPrimitiveType("time"));
        }
        if (mappedStringTypes.allowDateTime) {
            types.push(builder.getPrimitiveType("date-time"));
        }
        Support_1.assert(types.length > 0, "We got an empty string type");
        return builder.getUnionType(attributes, immutable_1.OrderedSet(types), forwardingRef);
    }
    var allStrings = graph
        .allTypesUnordered()
        .filter(function (t) { return t.kind === "string" && TypeUtils_1.stringTypesForType(t).isRestricted; })
        .map(function (t) { return [t]; })
        .toArray();
    return graph.rewrite("expand strings", stringTypeMapping, false, allStrings, debugPrintReconstitution, replaceString);
}
exports.expandStrings = expandStrings;
