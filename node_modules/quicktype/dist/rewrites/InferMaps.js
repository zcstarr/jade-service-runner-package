"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("../Type");
var TypeUtils_1 = require("../TypeUtils");
var Support_1 = require("../Support");
var UnifyClasses_1 = require("../UnifyClasses");
var MarkovChain_1 = require("../MarkovChain");
var mapSizeThreshold = 20;
var markovChain = undefined;
function nameProbability(name) {
    if (markovChain === undefined) {
        markovChain = MarkovChain_1.load();
    }
    return MarkovChain_1.evaluate(markovChain, name);
}
function shouldBeMap(properties) {
    // Only classes with a certain number of properties are inferred
    // as maps.
    var numProperties = properties.size;
    if (numProperties < 2)
        return undefined;
    // If all property names are digit-only, we always make a map, no
    // questions asked.
    if (properties.keySeq().every(function (n) { return /^[0-9]+$/.test(n); })) {
        return properties
            .valueSeq()
            .map(function (cp) { return cp.type; })
            .toSet();
    }
    if (numProperties < mapSizeThreshold) {
        var names = properties.keySeq();
        var probabilities = names.map(nameProbability);
        var product = probabilities.reduce(function (a, b) { return a * b; }, 1);
        var probability = Math.pow(product, 1 / numProperties);
        // The idea behind this is to have a probability around 0.0004 for
        // n=1, up to around 1.0 for n=20.  I.e. when we only have a few
        // properties, they need to look really weird to infer a map, but
        // when we have more we'll accept more ordinary names.  The details
        // of the formula are immaterial because I pulled it out of my ass.
        var exponent = 5;
        var scale = Math.pow(22, exponent);
        var limit = Math.pow(numProperties + 2, exponent) / scale + (0.004 - Math.pow(3, exponent) / scale);
        if (probability > limit)
            return undefined;
        /*
        console.log(
            `limit for ${JSON.stringify(names.toArray())} - ${JSON.stringify(
                probabilities.toArray()
            )} is ${limit}, we are at ${probability}`
        );
        */
    }
    // FIXME: simplify this - it's no longer necessary with the new
    // class properties.
    // We need to handle three cases for maps (and the fourth case
    // where we leave the class as is):
    //
    // 1. All property types are null.
    // 2. Some property types are null or nullable.
    // 3. No property types are null or nullable.
    var firstNonNullCases = undefined;
    var allCases = immutable_1.Set();
    var canBeMap = true;
    // Check that all the property types are the same, modulo nullability.
    properties.forEach(function (p) {
        // The set of types first property can be, minus null.
        var nn = TypeUtils_1.removeNullFromType(p.type)[1];
        if (!nn.isEmpty()) {
            if (firstNonNullCases !== undefined) {
                // The set of non-null cases for all other properties must
                // be the the same, otherwise we won't infer a map.
                if (!Type_1.setOperationCasesEqual(nn, firstNonNullCases, true, function (a, b) { return a.structurallyCompatible(b, true); })) {
                    canBeMap = false;
                    return false;
                }
            }
            else {
                firstNonNullCases = nn;
            }
        }
        allCases = allCases.add(p.type);
    });
    if (!canBeMap) {
        return undefined;
    }
    return allCases;
}
function inferMaps(graph, stringTypeMapping, conflateNumbers, debugPrintReconstitution) {
    function replaceClass(setOfOneClass, builder, forwardingRef) {
        var c = Support_1.defined(setOfOneClass.first());
        var properties = c.getProperties();
        var shouldBe = shouldBeMap(properties);
        if (shouldBe === undefined) {
            return Support_1.panic("We shouldn't be replacing class " + c.getCombinedName() + " with a map");
        }
        // Now reconstitute all the types in the new graph.  TypeGraphs are
        // immutable, so any change in the graph actually means building a new
        // graph, and the types in the new graph are different objects.
        // Reconstituting a type means generating the "same" type in the new
        // type graph.  Except we don't get Type objects but TypeRef objects,
        // which is a type-to-be.
        return builder.getMapType(c.getAttributes(), UnifyClasses_1.unifyTypes(shouldBe, c.getAttributes(), builder, UnifyClasses_1.unionBuilderForUnification(builder, false, false, conflateNumbers), conflateNumbers), forwardingRef);
    }
    var allClasses = graph.allNamedTypesSeparated().objects.filter(function (o) { return o instanceof Type_1.ClassType; });
    var classesToReplace = allClasses
        .filter(function (c) { return !c.isFixed && shouldBeMap(c.getProperties()) !== undefined; })
        .toArray();
    return graph.rewrite("infer maps", stringTypeMapping, false, classesToReplace.map(function (c) { return [c]; }), debugPrintReconstitution, replaceClass);
}
exports.inferMaps = inferMaps;
