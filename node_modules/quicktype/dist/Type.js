"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Support_1 = require("./Support");
var TypeNames_1 = require("./TypeNames");
var Messages_1 = require("./Messages");
function isPrimitiveStringTypeKind(kind) {
    return kind === "string" || kind === "date" || kind === "time" || kind === "date-time";
}
exports.isPrimitiveStringTypeKind = isPrimitiveStringTypeKind;
function isNumberTypeKind(kind) {
    return kind === "integer" || kind === "double";
}
exports.isNumberTypeKind = isNumberTypeKind;
function isPrimitiveTypeKind(kind) {
    if (isPrimitiveStringTypeKind(kind))
        return true;
    if (isNumberTypeKind(kind))
        return true;
    return kind === "none" || kind === "any" || kind === "null" || kind === "bool";
}
exports.isPrimitiveTypeKind = isPrimitiveTypeKind;
function triviallyStructurallyCompatible(x, y) {
    if (x.typeRef.index === y.typeRef.index)
        return true;
    if (x.kind === "none" || y.kind === "none")
        return true;
    return false;
}
var Type = /** @class */ (function () {
    function Type(typeRef, kind) {
        this.typeRef = typeRef;
        this.kind = kind;
    }
    Type.prototype.getChildren = function () {
        var result = this.getNonAttributeChildren();
        this.getAttributes().forEach(function (v, k) {
            if (k.children === undefined)
                return;
            result = result.union(k.children(v));
        });
        return result;
    };
    Type.prototype.getAttributes = function () {
        return this.typeRef.deref()[1];
    };
    Object.defineProperty(Type.prototype, "hasNames", {
        get: function () {
            return TypeNames_1.namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()) !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Type.prototype.getNames = function () {
        return Support_1.defined(TypeNames_1.namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()));
    };
    Type.prototype.getCombinedName = function () {
        return this.getNames().combinedName;
    };
    Object.defineProperty(Type.prototype, "debugPrintKind", {
        get: function () {
            return this.kind;
        },
        enumerable: true,
        configurable: true
    });
    Type.prototype.equals = function (other) {
        if (!(other instanceof Type))
            return false;
        return this.typeRef.equals(other.typeRef);
    };
    Type.prototype.hashCode = function () {
        return this.typeRef.hashCode();
    };
    Type.prototype.structurallyCompatible = function (other, conflateNumbers) {
        if (conflateNumbers === void 0) { conflateNumbers = false; }
        function kindsCompatible(kind1, kind2) {
            if (kind1 === kind2)
                return true;
            if (!conflateNumbers)
                return false;
            if (kind1 === "integer")
                return kind2 === "double";
            if (kind1 === "double")
                return kind2 === "integer";
            return false;
        }
        if (triviallyStructurallyCompatible(this, other))
            return true;
        if (!kindsCompatible(this.kind, other.kind))
            return false;
        var workList = [[this, other]];
        // This contains a set of pairs which are the type pairs
        // we have already determined to be equal.  We can't just
        // do comparison recursively because types can have cycles.
        var done = [];
        var failed;
        var queue = function (x, y) {
            if (triviallyStructurallyCompatible(x, y))
                return true;
            if (!kindsCompatible(x.kind, y.kind)) {
                failed = true;
                return false;
            }
            workList.push([x, y]);
            return true;
        };
        while (workList.length > 0) {
            var _a = Support_1.defined(workList.pop()), a = _a[0], b = _a[1];
            if (a.typeRef.index > b.typeRef.index) {
                _b = [b, a], a = _b[0], b = _b[1];
            }
            if (!a.isPrimitive()) {
                var ai = a.typeRef.index;
                var bi = b.typeRef.index;
                var found = false;
                for (var _i = 0, done_1 = done; _i < done_1.length; _i++) {
                    var _c = done_1[_i], dai = _c[0], dbi = _c[1];
                    if (dai === ai && dbi === bi) {
                        found = true;
                        break;
                    }
                }
                if (found)
                    continue;
                done.push([ai, bi]);
            }
            failed = false;
            if (!a.structuralEqualityStep(b, conflateNumbers, queue))
                return false;
            if (failed)
                return false;
        }
        return true;
        var _b;
    };
    Type.prototype.getParentTypes = function () {
        return this.typeRef.graph.getParentsOfType(this);
    };
    Type.prototype.getAncestorsNotInSet = function (set) {
        var workList = [this];
        var processed = immutable_1.Set();
        var ancestors = immutable_1.Set();
        for (;;) {
            var t = workList.pop();
            if (t === undefined)
                break;
            var parents = t.getParentTypes();
            console.log(parents.size + " parents");
            parents.forEach(function (p) {
                if (processed.has(p))
                    return;
                processed = processed.add(p);
                if (set.has(p.typeRef)) {
                    console.log("adding " + p.kind);
                    workList.push(p);
                }
                else {
                    console.log("found " + p.kind);
                    ancestors = ancestors.add(p);
                }
            });
        }
        return ancestors;
    };
    return Type;
}());
exports.Type = Type;
function hasUniqueIdentityAttributes(attributes) {
    return attributes.some(function (v, ta) { return ta.requiresUniqueIdentity(v); });
}
function identityAttributes(attributes) {
    return attributes.filter(function (_, kind) { return kind.inIdentity; });
}
function primitiveTypeIdentity(kind, attributes) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return immutable_1.List([kind, identityAttributes(attributes)]);
}
exports.primitiveTypeIdentity = primitiveTypeIdentity;
var PrimitiveType = /** @class */ (function (_super) {
    __extends(PrimitiveType, _super);
    function PrimitiveType() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PrimitiveType.prototype, "isNullable", {
        get: function () {
            return this.kind === "null" || this.kind === "any" || this.kind === "none";
        },
        enumerable: true,
        configurable: true
    });
    PrimitiveType.prototype.isPrimitive = function () {
        return true;
    };
    PrimitiveType.prototype.getNonAttributeChildren = function () {
        return immutable_1.OrderedSet();
    };
    Object.defineProperty(PrimitiveType.prototype, "identity", {
        get: function () {
            return primitiveTypeIdentity(this.kind, this.getAttributes());
        },
        enumerable: true,
        configurable: true
    });
    PrimitiveType.prototype.reconstitute = function (builder) {
        builder.getPrimitiveType(this.kind);
    };
    PrimitiveType.prototype.structuralEqualityStep = function (_other, _conflateNumbers, _queue) {
        return true;
    };
    return PrimitiveType;
}(Type));
exports.PrimitiveType = PrimitiveType;
function arrayTypeIdentity(attributes, itemsRef) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return immutable_1.List(["array", identityAttributes(attributes), itemsRef]);
}
exports.arrayTypeIdentity = arrayTypeIdentity;
var ArrayType = /** @class */ (function (_super) {
    __extends(ArrayType, _super);
    function ArrayType(typeRef, _itemsRef) {
        var _this = _super.call(this, typeRef, "array") || this;
        _this._itemsRef = _itemsRef;
        return _this;
    }
    ArrayType.prototype.setItems = function (itemsRef) {
        if (this._itemsRef !== undefined) {
            return Support_1.panic("Can only set array items once");
        }
        this._itemsRef = itemsRef;
    };
    ArrayType.prototype.getItemsRef = function () {
        if (this._itemsRef === undefined) {
            return Support_1.panic("Array items accessed before they were set");
        }
        return this._itemsRef;
    };
    Object.defineProperty(ArrayType.prototype, "items", {
        get: function () {
            return this.getItemsRef().deref()[0];
        },
        enumerable: true,
        configurable: true
    });
    ArrayType.prototype.getNonAttributeChildren = function () {
        return immutable_1.OrderedSet([this.items]);
    };
    Object.defineProperty(ArrayType.prototype, "isNullable", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    ArrayType.prototype.isPrimitive = function () {
        return false;
    };
    Object.defineProperty(ArrayType.prototype, "identity", {
        get: function () {
            return arrayTypeIdentity(this.getAttributes(), this.getItemsRef());
        },
        enumerable: true,
        configurable: true
    });
    ArrayType.prototype.reconstitute = function (builder) {
        var itemsRef = this.getItemsRef();
        var maybeItems = builder.lookup(itemsRef);
        if (maybeItems === undefined) {
            builder.getUniqueArrayType();
            builder.setArrayItems(builder.reconstitute(this.getItemsRef()));
        }
        else {
            builder.getArrayType(maybeItems);
        }
    };
    ArrayType.prototype.structuralEqualityStep = function (other, _conflateNumbers, queue) {
        return queue(this.items, other.items);
    };
    return ArrayType;
}(Type));
exports.ArrayType = ArrayType;
var GenericClassProperty = /** @class */ (function () {
    function GenericClassProperty(typeData, isOptional) {
        this.typeData = typeData;
        this.isOptional = isOptional;
    }
    GenericClassProperty.prototype.equals = function (other) {
        if (!(other instanceof GenericClassProperty)) {
            return false;
        }
        return immutable_1.is(this.typeData, other.typeData) && this.isOptional === other.isOptional;
    };
    GenericClassProperty.prototype.hashCode = function () {
        return immutable_1.hash(this.typeData) + (this.isOptional ? 17 : 23);
    };
    return GenericClassProperty;
}());
exports.GenericClassProperty = GenericClassProperty;
var ClassProperty = /** @class */ (function (_super) {
    __extends(ClassProperty, _super);
    function ClassProperty(typeRef, isOptional) {
        return _super.call(this, typeRef, isOptional) || this;
    }
    Object.defineProperty(ClassProperty.prototype, "typeRef", {
        get: function () {
            return this.typeData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClassProperty.prototype, "type", {
        get: function () {
            return this.typeRef.deref()[0];
        },
        enumerable: true,
        configurable: true
    });
    return ClassProperty;
}(GenericClassProperty));
exports.ClassProperty = ClassProperty;
function objectTypeIdentify(kind, attributes, properties, additionalPropertiesRef) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return immutable_1.List([kind, identityAttributes(attributes), properties.toMap(), additionalPropertiesRef]);
}
function classTypeIdentity(attributes, properties) {
    return objectTypeIdentify("class", attributes, properties, undefined);
}
exports.classTypeIdentity = classTypeIdentity;
function mapTypeIdentify(attributes, additionalPropertiesRef) {
    return objectTypeIdentify("map", attributes, immutable_1.OrderedMap(), additionalPropertiesRef);
}
exports.mapTypeIdentify = mapTypeIdentify;
var ObjectType = /** @class */ (function (_super) {
    __extends(ObjectType, _super);
    function ObjectType(typeRef, kind, isFixed, _properties, _additionalPropertiesRef) {
        var _this = _super.call(this, typeRef, kind) || this;
        _this.isFixed = isFixed;
        _this._properties = _properties;
        _this._additionalPropertiesRef = _additionalPropertiesRef;
        if (kind === "map") {
            if (_properties !== undefined) {
                Support_1.assert(_properties.isEmpty());
            }
            Support_1.assert(!isFixed);
        }
        else if (kind === "class") {
            Support_1.assert(_additionalPropertiesRef === undefined);
        }
        else {
            Support_1.assert(isFixed);
        }
        return _this;
    }
    ObjectType.prototype.setProperties = function (properties, additionalPropertiesRef) {
        Support_1.assert(this._properties === undefined, "Tried to set object properties twice");
        if (this instanceof MapType) {
            Support_1.assert(properties.isEmpty(), "Cannot set properties on map type");
        }
        if (this instanceof ClassType) {
            Support_1.assert(additionalPropertiesRef === undefined, "Cannot set additional properties of class type");
        }
        this._properties = properties;
        this._additionalPropertiesRef = additionalPropertiesRef;
    };
    ObjectType.prototype.getProperties = function () {
        return Support_1.defined(this._properties);
    };
    ObjectType.prototype.getSortedProperties = function () {
        var properties = this.getProperties();
        var sortedKeys = properties.keySeq().sort();
        var props = sortedKeys.map(function (k) { return [k, Support_1.defined(properties.get(k))]; });
        return immutable_1.OrderedMap(props);
    };
    ObjectType.prototype.getAdditionalPropertiesRef = function () {
        Support_1.assert(this._properties !== undefined, "Properties are not set yet");
        return this._additionalPropertiesRef;
    };
    ObjectType.prototype.getAdditionalProperties = function () {
        var tref = this.getAdditionalPropertiesRef();
        if (tref === undefined)
            return undefined;
        return tref.deref()[0];
    };
    ObjectType.prototype.getNonAttributeChildren = function () {
        var children = this.getSortedProperties()
            .map(function (p) { return p.type; })
            .toOrderedSet();
        var additionalProperties = this.getAdditionalProperties();
        if (additionalProperties !== undefined) {
            children = children.add(additionalProperties);
        }
        return children;
    };
    Object.defineProperty(ObjectType.prototype, "isNullable", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    ObjectType.prototype.isPrimitive = function () {
        return false;
    };
    Object.defineProperty(ObjectType.prototype, "identity", {
        get: function () {
            if (this.isFixed)
                return undefined;
            return objectTypeIdentify(this.kind, this.getAttributes(), this.getProperties(), this.getAdditionalPropertiesRef());
        },
        enumerable: true,
        configurable: true
    });
    ObjectType.prototype.reconstitute = function (builder, canonicalOrder) {
        var sortedProperties = this.getProperties().sortBy(function (_, n) { return n; });
        var propertiesInNewOrder = canonicalOrder ? sortedProperties : this.getProperties();
        var maybePropertyTypes = builder.lookup(sortedProperties.map(function (cp) { return cp.typeRef; }));
        var maybeAdditionalProperties = Support_1.mapOptional(function (r) { return builder.lookup(r); }, this._additionalPropertiesRef);
        if (maybePropertyTypes !== undefined &&
            (maybeAdditionalProperties !== undefined || this._additionalPropertiesRef === undefined)) {
            var properties = propertiesInNewOrder.map(function (cp, n) { return new ClassProperty(Support_1.defined(maybePropertyTypes.get(n)), cp.isOptional); });
            switch (this.kind) {
                case "object":
                    Support_1.assert(this.isFixed);
                    builder.getObjectType(properties, maybeAdditionalProperties);
                    break;
                case "map":
                    builder.getMapType(Support_1.defined(maybeAdditionalProperties));
                    break;
                case "class":
                    if (this.isFixed) {
                        builder.getUniqueClassType(true, properties);
                    }
                    else {
                        builder.getClassType(properties);
                    }
                    break;
                default:
                    return Support_1.panic("Invalid object type kind " + this.kind);
            }
        }
        else {
            switch (this.kind) {
                case "object":
                    Support_1.assert(this.isFixed);
                    builder.getUniqueObjectType(undefined, undefined);
                    break;
                case "map":
                    builder.getUniqueMapType();
                    break;
                case "class":
                    builder.getUniqueClassType(this.isFixed, undefined);
                    break;
                default:
                    return Support_1.panic("Invalid object type kind " + this.kind);
            }
            var reconstitutedTypes_1 = sortedProperties.map(function (cp) { return builder.reconstitute(cp.typeRef); });
            var properties = propertiesInNewOrder.map(function (cp, n) { return new ClassProperty(Support_1.defined(reconstitutedTypes_1.get(n)), cp.isOptional); });
            var additionalProperties = Support_1.mapOptional(function (r) { return builder.reconstitute(r); }, this._additionalPropertiesRef);
            builder.setObjectProperties(properties, additionalProperties);
        }
    };
    ObjectType.prototype.structuralEqualityStep = function (other, _conflateNumbers, queue) {
        var pa = this.getProperties();
        var pb = other.getProperties();
        if (pa.size !== pb.size)
            return false;
        var failed = false;
        pa.forEach(function (cpa, name) {
            var cpb = pb.get(name);
            if (cpb === undefined || cpa.isOptional !== cpb.isOptional || !queue(cpa.type, cpb.type)) {
                failed = true;
                return false;
            }
        });
        if (failed)
            return false;
        var thisAdditionalProperties = this.getAdditionalProperties();
        var otherAdditionalProperties = other.getAdditionalProperties();
        if ((thisAdditionalProperties === undefined) !== (otherAdditionalProperties === undefined))
            return false;
        if (thisAdditionalProperties === undefined || otherAdditionalProperties === undefined)
            return true;
        return queue(thisAdditionalProperties, otherAdditionalProperties);
    };
    return ObjectType;
}(Type));
exports.ObjectType = ObjectType;
var ClassType = /** @class */ (function (_super) {
    __extends(ClassType, _super);
    function ClassType(typeRef, isFixed, properties) {
        return _super.call(this, typeRef, "class", isFixed, properties, undefined) || this;
    }
    return ClassType;
}(ObjectType));
exports.ClassType = ClassType;
var MapType = /** @class */ (function (_super) {
    __extends(MapType, _super);
    function MapType(typeRef, valuesRef) {
        return _super.call(this, typeRef, "map", false, Support_1.mapOptional(function () { return immutable_1.OrderedMap(); }, valuesRef), valuesRef) || this;
    }
    Object.defineProperty(MapType.prototype, "values", {
        // FIXME: Remove and use `getAdditionalProperties()` instead.
        get: function () {
            return Support_1.defined(this.getAdditionalProperties());
        },
        enumerable: true,
        configurable: true
    });
    return MapType;
}(ObjectType));
exports.MapType = MapType;
function enumTypeIdentity(attributes, cases) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return immutable_1.List(["enum", identityAttributes(attributes), cases.toSet()]);
}
exports.enumTypeIdentity = enumTypeIdentity;
var EnumType = /** @class */ (function (_super) {
    __extends(EnumType, _super);
    function EnumType(typeRef, cases) {
        var _this = _super.call(this, typeRef, "enum") || this;
        _this.cases = cases;
        return _this;
    }
    Object.defineProperty(EnumType.prototype, "isNullable", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    EnumType.prototype.isPrimitive = function () {
        return false;
    };
    Object.defineProperty(EnumType.prototype, "identity", {
        get: function () {
            return enumTypeIdentity(this.getAttributes(), this.cases);
        },
        enumerable: true,
        configurable: true
    });
    EnumType.prototype.getNonAttributeChildren = function () {
        return immutable_1.OrderedSet();
    };
    EnumType.prototype.reconstitute = function (builder) {
        builder.getEnumType(this.cases);
    };
    EnumType.prototype.structuralEqualityStep = function (other, _conflateNumbers, _queue) {
        return this.cases.toSet().equals(other.cases.toSet());
    };
    return EnumType;
}(Type));
exports.EnumType = EnumType;
function setOperationCasesEqual(ma, mb, conflateNumbers, membersEqual) {
    if (ma.size !== mb.size)
        return false;
    return ma.every(function (ta) {
        var tb = mb.find(function (t) { return t.kind === ta.kind; });
        if (tb !== undefined) {
            if (membersEqual(ta, tb))
                return true;
        }
        if (conflateNumbers) {
            if (ta.kind === "integer" && mb.some(function (t) { return t.kind === "double"; }))
                return true;
            if (ta.kind === "double" && mb.some(function (t) { return t.kind === "integer"; }))
                return true;
        }
        return false;
    });
}
exports.setOperationCasesEqual = setOperationCasesEqual;
function setOperationTypeIdentity(kind, attributes, memberRefs) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return immutable_1.List([kind, identityAttributes(attributes), memberRefs.toSet()]);
}
exports.setOperationTypeIdentity = setOperationTypeIdentity;
function unionTypeIdentity(attributes, memberRefs) {
    return setOperationTypeIdentity("union", attributes, memberRefs);
}
exports.unionTypeIdentity = unionTypeIdentity;
function intersectionTypeIdentity(attributes, memberRefs) {
    return setOperationTypeIdentity("intersection", attributes, memberRefs);
}
exports.intersectionTypeIdentity = intersectionTypeIdentity;
var SetOperationType = /** @class */ (function (_super) {
    __extends(SetOperationType, _super);
    function SetOperationType(typeRef, kind, _memberRefs) {
        var _this = _super.call(this, typeRef, kind) || this;
        _this._memberRefs = _memberRefs;
        return _this;
    }
    SetOperationType.prototype.setMembers = function (memberRefs) {
        if (this._memberRefs !== undefined) {
            return Support_1.panic("Can only set map members once");
        }
        this._memberRefs = memberRefs;
    };
    SetOperationType.prototype.getMemberRefs = function () {
        if (this._memberRefs === undefined) {
            return Support_1.panic("Map members accessed before they were set");
        }
        return this._memberRefs;
    };
    Object.defineProperty(SetOperationType.prototype, "members", {
        get: function () {
            return this.getMemberRefs().map(function (tref) { return tref.deref()[0]; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SetOperationType.prototype, "sortedMembers", {
        get: function () {
            // FIXME: We're assuming no two members of the same kind.
            return this.members.sortBy(function (t) { return t.kind; });
        },
        enumerable: true,
        configurable: true
    });
    SetOperationType.prototype.getNonAttributeChildren = function () {
        return this.sortedMembers;
    };
    SetOperationType.prototype.isPrimitive = function () {
        return false;
    };
    Object.defineProperty(SetOperationType.prototype, "identity", {
        get: function () {
            return setOperationTypeIdentity(this.kind, this.getAttributes(), this.getMemberRefs());
        },
        enumerable: true,
        configurable: true
    });
    SetOperationType.prototype.reconstituteSetOperation = function (builder, canonicalOrder, getType) {
        var sortedMemberRefs = this.sortedMembers.toOrderedMap().map(function (t) { return t.typeRef; });
        var membersInOrder = canonicalOrder ? this.sortedMembers : this.members;
        var maybeMembers = builder.lookup(sortedMemberRefs);
        if (maybeMembers === undefined) {
            getType(undefined);
            var reconstituted_1 = builder.reconstitute(sortedMemberRefs);
            builder.setSetOperationMembers(membersInOrder.map(function (t) { return Support_1.defined(reconstituted_1.get(t)); }));
        }
        else {
            getType(membersInOrder.map(function (t) { return Support_1.defined(maybeMembers.get(t)); }));
        }
    };
    SetOperationType.prototype.structuralEqualityStep = function (other, conflateNumbers, queue) {
        return setOperationCasesEqual(this.members, other.members, conflateNumbers, queue);
    };
    return SetOperationType;
}(Type));
exports.SetOperationType = SetOperationType;
var IntersectionType = /** @class */ (function (_super) {
    __extends(IntersectionType, _super);
    function IntersectionType(typeRef, memberRefs) {
        return _super.call(this, typeRef, "intersection", memberRefs) || this;
    }
    Object.defineProperty(IntersectionType.prototype, "isNullable", {
        get: function () {
            return Support_1.panic("isNullable not implemented for IntersectionType");
        },
        enumerable: true,
        configurable: true
    });
    IntersectionType.prototype.reconstitute = function (builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, function (members) {
            if (members === undefined) {
                builder.getUniqueIntersectionType();
            }
            else {
                builder.getIntersectionType(members);
            }
        });
    };
    return IntersectionType;
}(SetOperationType));
exports.IntersectionType = IntersectionType;
var UnionType = /** @class */ (function (_super) {
    __extends(UnionType, _super);
    function UnionType(typeRef, memberRefs) {
        var _this = _super.call(this, typeRef, "union", memberRefs) || this;
        if (memberRefs !== undefined) {
            Messages_1.messageAssert(!memberRefs.isEmpty(), "IRNoEmptyUnions", {});
        }
        return _this;
    }
    UnionType.prototype.setMembers = function (memberRefs) {
        Messages_1.messageAssert(!memberRefs.isEmpty(), "IRNoEmptyUnions", {});
        _super.prototype.setMembers.call(this, memberRefs);
    };
    Object.defineProperty(UnionType.prototype, "stringTypeMembers", {
        get: function () {
            return this.members.filter(function (t) { return ["string", "date", "time", "date-time", "enum"].indexOf(t.kind) >= 0; });
        },
        enumerable: true,
        configurable: true
    });
    UnionType.prototype.findMember = function (kind) {
        return this.members.find(function (t) { return t.kind === kind; });
    };
    Object.defineProperty(UnionType.prototype, "isNullable", {
        get: function () {
            return this.findMember("null") !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnionType.prototype, "isCanonical", {
        get: function () {
            var members = this.members;
            if (members.size <= 1)
                return false;
            var kinds = members.map(function (t) { return t.kind; });
            if (kinds.size < members.size)
                return false;
            if (kinds.has("union") || kinds.has("intersection"))
                return false;
            if (kinds.has("none") || kinds.has("any"))
                return false;
            if (kinds.has("string") && kinds.has("enum"))
                return false;
            var numObjectTypes = 0;
            if (kinds.has("class"))
                numObjectTypes += 1;
            if (kinds.has("map"))
                numObjectTypes += 1;
            if (kinds.has("object"))
                numObjectTypes += 1;
            if (numObjectTypes > 1)
                return false;
            return true;
        },
        enumerable: true,
        configurable: true
    });
    UnionType.prototype.reconstitute = function (builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, function (members) {
            if (members === undefined) {
                builder.getUniqueUnionType();
            }
            else {
                builder.getUnionType(members);
            }
        });
    };
    return UnionType;
}(SetOperationType));
exports.UnionType = UnionType;
