#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var _ = require("lodash");
var __1 = require("..");
var defaultTargetLanguages = require("../language/All");
var URLGrammar_1 = require("./URLGrammar");
var Annotation_1 = require("../Annotation");
var Support_1 = require("../Support");
var GraphQLIntrospection_1 = require("../GraphQLIntrospection");
var index_1 = require("../get-stream/index");
var MarkovChain_1 = require("../MarkovChain");
var PostmanCollection_1 = require("./PostmanCollection");
var NodeIO_1 = require("./NodeIO");
var telemetry = require("./telemetry");
var Messages_1 = require("../Messages");
var commandLineArgs = require("command-line-args");
var getUsage = require("command-line-usage");
var chalk = require("chalk");
var wordWrap = require("wordwrap")(90);
var packageJSON = require("../../package.json");
var defaultDefaultTargetLanguageName = "go";
function sourceFromFileOrUrlArray(name, filesOrUrls) {
    return __awaiter(this, void 0, void 0, function () {
        var samples;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Promise.all(filesOrUrls.map(NodeIO_1.readableFromFileOrURL))];
                case 1:
                    samples = _a.sent();
                    return [2 /*return*/, { kind: "json", name: name, samples: samples }];
            }
        });
    });
}
function typeNameFromFilename(filename) {
    var name = path.basename(filename);
    return name.substr(0, name.lastIndexOf("."));
}
function samplesFromDirectory(dataDir) {
    return __awaiter(this, void 0, void 0, function () {
        function readFilesOrURLsInDirectory(d) {
            return __awaiter(this, void 0, void 0, function () {
                var files, sourcesInDir, graphQLSources, graphQLSchema, graphQLSchemaFileName, _i, files_1, file, name, fileOrUrl, _a, _b, _c, _d, _e, _f, schema, _g, _h, graphQLSources_1, source;
                return __generator(this, function (_j) {
                    switch (_j.label) {
                        case 0:
                            files = fs
                                .readdirSync(d)
                                .map(function (x) { return path.join(d, x); })
                                .filter(function (x) { return fs.lstatSync(x).isFile(); });
                            sourcesInDir = [];
                            graphQLSources = [];
                            graphQLSchema = undefined;
                            graphQLSchemaFileName = undefined;
                            _i = 0, files_1 = files;
                            _j.label = 1;
                        case 1:
                            if (!(_i < files_1.length)) return [3 /*break*/, 9];
                            file = files_1[_i];
                            name = typeNameFromFilename(file);
                            fileOrUrl = file;
                            file = file.toLowerCase();
                            // If file is a URL string, download it
                            if (file.endsWith(".url")) {
                                fileOrUrl = fs.readFileSync(file, "utf8").trim();
                            }
                            if (!(file.endsWith(".url") || file.endsWith(".json"))) return [3 /*break*/, 3];
                            _b = (_a = sourcesInDir).push;
                            _c = {
                                kind: "json",
                                name: name
                            };
                            return [4 /*yield*/, NodeIO_1.readableFromFileOrURL(fileOrUrl)];
                        case 2:
                            _b.apply(_a, [(_c.samples = [_j.sent()],
                                    _c)]);
                            return [3 /*break*/, 8];
                        case 3:
                            if (!file.endsWith(".schema")) return [3 /*break*/, 4];
                            sourcesInDir.push({
                                kind: "schema",
                                name: name,
                                uris: [fileOrUrl]
                            });
                            return [3 /*break*/, 8];
                        case 4:
                            if (!file.endsWith(".gqlschema")) return [3 /*break*/, 6];
                            Messages_1.messageAssert(graphQLSchema === undefined, "DriverMoreThanOneGraphQLSchemaInDir", {
                                dir: dataDir
                            });
                            return [4 /*yield*/, NodeIO_1.readableFromFileOrURL(fileOrUrl)];
                        case 5:
                            graphQLSchema = _j.sent();
                            graphQLSchemaFileName = fileOrUrl;
                            return [3 /*break*/, 8];
                        case 6:
                            if (!file.endsWith(".graphql")) return [3 /*break*/, 8];
                            _e = (_d = graphQLSources).push;
                            _f = {
                                kind: "graphql",
                                name: name,
                                schema: undefined
                            };
                            return [4 /*yield*/, NodeIO_1.readableFromFileOrURL(fileOrUrl)];
                        case 7:
                            _e.apply(_d, [(_f.query = _j.sent(),
                                    _f)]);
                            _j.label = 8;
                        case 8:
                            _i++;
                            return [3 /*break*/, 1];
                        case 9:
                            if (!(graphQLSources.length > 0)) return [3 /*break*/, 11];
                            if (graphQLSchema === undefined) {
                                return [2 /*return*/, Messages_1.messageError("DriverNoGraphQLSchemaInDir", { dir: dataDir })];
                            }
                            _g = Support_1.parseJSON;
                            return [4 /*yield*/, index_1.getStream(graphQLSchema)];
                        case 10:
                            schema = _g.apply(void 0, [_j.sent(), "GraphQL schema", graphQLSchemaFileName]);
                            for (_h = 0, graphQLSources_1 = graphQLSources; _h < graphQLSources_1.length; _h++) {
                                source = graphQLSources_1[_h];
                                source.schema = schema;
                                sourcesInDir.push(source);
                            }
                            _j.label = 11;
                        case 11: return [2 /*return*/, sourcesInDir];
                    }
                });
            });
        }
        var contents, directories, sources, _i, directories_1, dir, jsonSamples, schemaSources, graphQLSources, typeScriptSources, _a, _b, source, oneUnlessEmpty;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    contents = fs.readdirSync(dataDir).map(function (x) { return path.join(dataDir, x); });
                    directories = contents.filter(function (x) { return fs.lstatSync(x).isDirectory(); });
                    return [4 /*yield*/, readFilesOrURLsInDirectory(dataDir)];
                case 1:
                    sources = _c.sent();
                    _i = 0, directories_1 = directories;
                    _c.label = 2;
                case 2:
                    if (!(_i < directories_1.length)) return [3 /*break*/, 8];
                    dir = directories_1[_i];
                    jsonSamples = [];
                    schemaSources = [];
                    graphQLSources = [];
                    typeScriptSources = [];
                    _a = 0;
                    return [4 /*yield*/, readFilesOrURLsInDirectory(dir)];
                case 3:
                    _b = _c.sent();
                    _c.label = 4;
                case 4:
                    if (!(_a < _b.length)) return [3 /*break*/, 6];
                    source = _b[_a];
                    switch (source.kind) {
                        case "json":
                            jsonSamples = jsonSamples.concat(source.samples);
                            break;
                        case "schema":
                            schemaSources.push(source);
                            break;
                        case "graphql":
                            graphQLSources.push(source);
                            break;
                        case "typescript":
                            typeScriptSources.push(source);
                            break;
                        default:
                            return [2 /*return*/, Support_1.assertNever(source)];
                    }
                    _c.label = 5;
                case 5:
                    _a++;
                    return [3 /*break*/, 4];
                case 6:
                    if (jsonSamples.length > 0 && schemaSources.length + graphQLSources.length + typeScriptSources.length > 0) {
                        return [2 /*return*/, Messages_1.messageError("DriverCannotMixJSONWithOtherSamples", { dir: dir })];
                    }
                    oneUnlessEmpty = function (xs) { return Math.sign(xs.length); };
                    if (oneUnlessEmpty(schemaSources) + oneUnlessEmpty(graphQLSources) + oneUnlessEmpty(typeScriptSources) > 1) {
                        return [2 /*return*/, Messages_1.messageError("DriverCannotMixNonJSONInputs", { dir: dir })];
                    }
                    if (jsonSamples.length > 0) {
                        sources.push({
                            kind: "json",
                            name: path.basename(dir),
                            samples: jsonSamples
                        });
                    }
                    sources = sources.concat(schemaSources);
                    sources = sources.concat(graphQLSources);
                    _c.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 2];
                case 8: return [2 /*return*/, sources];
            }
        });
    });
}
function inferLang(options, defaultLanguage) {
    // Output file extension determines the language if language is undefined
    if (options.out !== undefined) {
        var extension = path.extname(options.out);
        if (extension === "") {
            return Messages_1.messageError("DriverNoLanguageOrExtension", {});
        }
        return extension.substr(1);
    }
    return defaultLanguage;
}
function inferTopLevel(options) {
    // Output file name determines the top-level if undefined
    if (options.out !== undefined) {
        var extension = path.extname(options.out);
        var without = path.basename(options.out).replace(extension, "");
        return without;
    }
    // Source determines the top-level if undefined
    if (options.src !== undefined && options.src.length === 1) {
        var src = options.src[0];
        var extension = path.extname(src);
        var without = path.basename(src).replace(extension, "");
        return without;
    }
    return "TopLevel";
}
function inferCLIOptions(opts, targetLanguage) {
    var srcLang = opts.srcLang;
    if (opts.graphqlSchema !== undefined || opts.graphqlIntrospect !== undefined) {
        Messages_1.messageAssert(srcLang === undefined || srcLang === "graphql", "DriverSourceLangMustBeGraphQL", {});
        srcLang = "graphql";
    }
    else if (opts.src !== undefined && opts.src.length > 0 && opts.src.every(function (file) { return _.endsWith(file, ".ts"); })) {
        srcLang = "typescript";
    }
    else {
        Messages_1.messageAssert(srcLang !== "graphql", "DriverGraphQLSchemaNeeded", {});
        srcLang = Support_1.withDefault(srcLang, "json");
    }
    var language;
    if (targetLanguage !== undefined) {
        language = targetLanguage;
    }
    else {
        var languageName = opts.lang !== undefined ? opts.lang : inferLang(opts, defaultDefaultTargetLanguageName);
        var maybeLanguage = __1.languageNamed(languageName);
        if (maybeLanguage === undefined) {
            return Messages_1.messageError("DriverUnknownOutputLanguage", { lang: languageName });
        }
        language = maybeLanguage;
    }
    /* tslint:disable:strict-boolean-expressions */
    return {
        src: opts.src || [],
        srcLang: srcLang,
        lang: language.displayName,
        topLevel: opts.topLevel || inferTopLevel(opts),
        noMaps: !!opts.noMaps,
        noEnums: !!opts.noEnums,
        noDateTimes: !!opts.noDateTimes,
        noCombineClasses: !!opts.noCombineClasses,
        noRender: !!opts.noRender,
        alphabetizeProperties: !!opts.alphabetizeProperties,
        allPropertiesOptional: !!opts.allPropertiesOptional,
        rendererOptions: opts.rendererOptions || {},
        help: opts.help || false,
        quiet: opts.quiet || false,
        version: opts.version || false,
        out: opts.out,
        buildMarkovChain: opts.buildMarkovChain,
        findSimilarClassesSchema: opts.findSimilarClassesSchema,
        graphqlSchema: opts.graphqlSchema,
        graphqlIntrospect: opts.graphqlIntrospect,
        graphqlServerHeader: opts.graphqlServerHeader,
        template: opts.template,
        debug: opts.debug,
        telemetry: opts.telemetry
    };
    /* tslint:enable */
}
function makeLangTypeLabel(targetLanguages) {
    Support_1.assert(targetLanguages.length > 0, "Must have at least one target language");
    return targetLanguages.map(function (r) { return _.minBy(r.names, function (s) { return s.length; }); }).join("|");
}
function makeOptionDefinitions(targetLanguages) {
    var beforeLang = [
        {
            name: "out",
            alias: "o",
            type: String,
            typeLabel: "FILE",
            description: "The output file. Determines --lang and --top-level."
        },
        {
            name: "top-level",
            alias: "t",
            type: String,
            typeLabel: "NAME",
            description: "The name for the top level type."
        }
    ];
    var lang = targetLanguages.length < 2
        ? []
        : [
            {
                name: "lang",
                alias: "l",
                type: String,
                typeLabel: makeLangTypeLabel(targetLanguages),
                description: "The target language."
            }
        ];
    var afterLang = [
        {
            name: "src-lang",
            alias: "s",
            type: String,
            defaultValue: undefined,
            typeLabel: "json|schema|graphql|postman|typescript",
            description: "The source language (default is json)."
        },
        {
            name: "src",
            type: String,
            multiple: true,
            defaultOption: true,
            typeLabel: "FILE|URL|DIRECTORY",
            description: "The file, url, or data directory to type."
        },
        {
            name: "src-urls",
            type: String,
            typeLabel: "FILE",
            description: "Tracery grammar describing URLs to crawl."
        },
        {
            name: "no-combine-classes",
            type: Boolean,
            description: "Don't combine similar classes."
        },
        {
            name: "graphql-schema",
            type: String,
            typeLabel: "FILE",
            description: "GraphQL introspection file."
        },
        {
            name: "graphql-introspect",
            type: String,
            typeLabel: "URL",
            description: "Introspect GraphQL schema from a server."
        },
        {
            name: "graphql-server-header",
            type: String,
            multiple: true,
            typeLabel: "HEADER",
            description: "HTTP header for the GraphQL introspection query."
        },
        {
            name: "template",
            type: String,
            typeLabel: "FILE",
            description: "Handlebars template file."
        },
        {
            name: "no-maps",
            type: Boolean,
            description: "Don't infer maps, always use classes."
        },
        {
            name: "no-enums",
            type: Boolean,
            description: "Don't infer enums, always use strings."
        },
        {
            name: "no-date-times",
            type: Boolean,
            description: "Don't infer dates or times."
        },
        {
            name: "no-render",
            type: Boolean,
            description: "Don't render output."
        },
        {
            name: "alphabetize-properties",
            type: Boolean,
            description: "Alphabetize order of class properties."
        },
        {
            name: "all-properties-optional",
            type: Boolean,
            description: "Make all class properties optional."
        },
        {
            name: "build-markov-chain",
            type: String,
            typeLabel: "FILE",
            description: "Markov chain corpus filename."
        },
        {
            name: "find-similar-classes-schema",
            type: String,
            typeLabel: "FILE",
            description: "Base schema for finding similar classes"
        },
        {
            name: "quiet",
            type: Boolean,
            description: "Don't show issues in the generated code."
        },
        {
            name: "debug",
            type: String,
            typeLabel: "OPTIONS or all",
            description: "Comma separated debug options: print-graph, print-reconstitution, print-gather-names, print-transformations, provenance"
        },
        {
            name: "telemetry",
            type: String,
            typeLabel: "enable|disable",
            description: "Enable anonymous telemetry to help improve quicktype"
        },
        {
            name: "help",
            alias: "h",
            type: Boolean,
            description: "Get some help."
        },
        {
            name: "version",
            alias: "v",
            type: Boolean,
            description: "Display the version of quicktype"
        }
    ];
    return beforeLang.concat(lang, afterLang);
}
function makeSectionsBeforeRenderers(targetLanguages) {
    var langsString;
    if (targetLanguages.length < 2) {
        langsString = "";
    }
    else {
        var langs = makeLangTypeLabel(targetLanguages);
        langsString = " [[bold]{--lang} " + langs + "]";
    }
    var langDisplayNames = targetLanguages.map(function (r) { return r.displayName; }).join(", ");
    return [
        {
            header: "Synopsis",
            content: "$ quicktype" + langsString + " FILE|URL ..."
        },
        {
            header: "Description",
            content: "Given JSON sample data, quicktype outputs code for working with that data in " + langDisplayNames + "."
        },
        {
            header: "Options",
            optionList: makeOptionDefinitions(targetLanguages),
            hide: ["no-render", "build-markov-chain", "find-similar-classes-schema"]
        }
    ];
}
var sectionsAfterRenderers = [
    {
        header: "Examples",
        content: [
            chalk.dim("Generate C# to parse a Bitcoin API"),
            "$ quicktype -o LatestBlock.cs https://blockchain.info/latestblock",
            "",
            chalk.dim("Generate Go code from a directory of samples containing:"),
            chalk.dim("  - Foo.json\n  + Bar\n    - bar-sample-1.json\n    - bar-sample-2.json\n  - Baz.url"),
            "$ quicktype -l go samples",
            "",
            chalk.dim("Generate JSON Schema, then TypeScript"),
            "$ quicktype -o schema.json https://blockchain.info/latestblock",
            "$ quicktype -o bitcoin.ts --src-lang schema schema.json"
        ]
    },
    {
        content: "Learn more at [bold]{quicktype.io}"
    }
];
function parseCLIOptions(argv, targetLanguage) {
    if (argv.length === 0) {
        return inferCLIOptions({ help: true }, targetLanguage);
    }
    var targetLanguages = targetLanguage === undefined ? defaultTargetLanguages.all : [targetLanguage];
    var optionDefinitions = makeOptionDefinitions(targetLanguages);
    // We can only fully parse the options once we know which renderer is selected,
    // because there are renderer-specific options.  But we only know which renderer
    // is selected after we've parsed the options.  Hence, we parse the options
    // twice.  This is the first parse to get the renderer:
    var incompleteOptions = inferCLIOptions(parseOptions(optionDefinitions, argv, true), targetLanguage);
    if (targetLanguage === undefined) {
        targetLanguage = __1.getTargetLanguage(incompleteOptions.lang);
    }
    var rendererOptionDefinitions = targetLanguage.cliOptionDefinitions.actual;
    // Use the global options as well as the renderer options from now on:
    var allOptionDefinitions = _.concat(optionDefinitions, rendererOptionDefinitions);
    // This is the parse that counts:
    return inferCLIOptions(parseOptions(allOptionDefinitions, argv, false), targetLanguage);
}
exports.parseCLIOptions = parseCLIOptions;
// Parse the options in argv and split them into global options and renderer options,
// according to each option definition's `renderer` field.  If `partial` is false this
// will throw if it encounters an unknown option.
function parseOptions(definitions, argv, partial) {
    var opts;
    try {
        opts = commandLineArgs(definitions, { argv: argv, partial: partial });
    }
    catch (e) {
        Support_1.assert(!partial, "Partial option parsing should not have failed");
        return Messages_1.messageError("DriverCLIOptionParsingFailed", { message: e.message });
    }
    var options = { rendererOptions: {} };
    definitions.forEach(function (o) {
        if (!(o.name in opts))
            return;
        var v = opts[o.name];
        if (o.renderer !== undefined)
            options.rendererOptions[o.name] = v;
        else {
            var k = _.lowerFirst(o.name
                .split("-")
                .map(_.upperFirst)
                .join(""));
            options[k] = v;
        }
    });
    return options;
}
function usage(targetLanguages) {
    var rendererSections = [];
    _.forEach(targetLanguages, function (language) {
        var definitions = language.cliOptionDefinitions.display;
        if (definitions.length === 0)
            return;
        rendererSections.push({
            header: "Options for " + language.displayName,
            optionList: definitions
        });
    });
    var sections = _.concat(makeSectionsBeforeRenderers(targetLanguages), rendererSections, sectionsAfterRenderers);
    console.log(getUsage(sections));
}
// Returns an array of [name, sourceURIs] pairs.
function getSourceURIs(options) {
    return __awaiter(this, void 0, void 0, function () {
        var json, _a, jsonMap_1, topLevels;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(options.srcUrls !== undefined)) return [3 /*break*/, 2];
                    _a = Support_1.parseJSON;
                    return [4 /*yield*/, NodeIO_1.readFromFileOrURL(options.srcUrls)];
                case 1:
                    json = _a.apply(void 0, [_b.sent(), "URL grammar", options.srcUrls]);
                    jsonMap_1 = URLGrammar_1.urlsFromURLGrammar(json);
                    topLevels = Object.getOwnPropertyNames(jsonMap_1);
                    return [2 /*return*/, topLevels.map(function (name) { return [name, jsonMap_1[name]]; })];
                case 2:
                    if (options.src.length === 0) {
                        return [2 /*return*/, [[options.topLevel, ["-"]]]];
                    }
                    else {
                        return [2 /*return*/, []];
                    }
                    _b.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    });
}
function typeSourcesForURIs(name, uris, options) {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = options.srcLang;
                    switch (_a) {
                        case "json": return [3 /*break*/, 1];
                        case "schema": return [3 /*break*/, 3];
                    }
                    return [3 /*break*/, 4];
                case 1: return [4 /*yield*/, sourceFromFileOrUrlArray(name, uris)];
                case 2: return [2 /*return*/, [_b.sent()]];
                case 3: return [2 /*return*/, uris.map(function (uri) { return ({ kind: "schema", name: name, uris: [uri] }); })];
                case 4: return [2 /*return*/, Support_1.panic("typeSourceForURIs must not be called for source language " + options.srcLang)];
            }
        });
    });
}
function getSources(options) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        var sourceURIs, sourceArrays, sources, exists, directories, _i, directories_2, dataDir, _a, _b, filesOrUrls, _c, _d, _e, _f;
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0: return [4 /*yield*/, getSourceURIs(options)];
                case 1:
                    sourceURIs = _g.sent();
                    return [4 /*yield*/, Promise.all(sourceURIs.map(function (_a) {
                            var name = _a[0], uris = _a[1];
                            return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, typeSourcesForURIs(name, uris, options)];
                                    case 1: return [2 /*return*/, _b.sent()];
                                }
                            }); });
                        }))];
                case 2:
                    sourceArrays = _g.sent();
                    sources = (_f = []).concat.apply(_f, sourceArrays);
                    exists = options.src.filter(fs.existsSync);
                    directories = exists.filter(function (x) { return fs.lstatSync(x).isDirectory(); });
                    _i = 0, directories_2 = directories;
                    _g.label = 3;
                case 3:
                    if (!(_i < directories_2.length)) return [3 /*break*/, 6];
                    dataDir = directories_2[_i];
                    _b = (_a = sources).concat;
                    return [4 /*yield*/, samplesFromDirectory(dataDir)];
                case 4:
                    sources = _b.apply(_a, [_g.sent()]);
                    _g.label = 5;
                case 5:
                    _i++;
                    return [3 /*break*/, 3];
                case 6:
                    filesOrUrls = options.src.filter(function (x) { return !_.includes(directories, x); });
                    if (!!_.isEmpty(filesOrUrls)) return [3 /*break*/, 8];
                    _d = (_c = sources.push).apply;
                    _e = [sources];
                    return [4 /*yield*/, typeSourcesForURIs(options.topLevel, filesOrUrls, options)];
                case 7:
                    _d.apply(_c, _e.concat([(_g.sent())]));
                    _g.label = 8;
                case 8: return [2 /*return*/, sources];
            }
        });
    });
}
function makeTypeScriptSource(fileNames) {
    var sources = {};
    for (var _i = 0, fileNames_1 = fileNames; _i < fileNames_1.length; _i++) {
        var fileName = fileNames_1[_i];
        var baseName = path.basename(fileName);
        sources[baseName] = Support_1.defined(fs.readFileSync(fileName, "utf8"));
    }
    return { kind: "typescript", sources: sources };
}
function makeQuicktypeOptions(options, targetLanguages) {
    return __awaiter(this, void 0, void 0, function () {
        var contents, lines, mc, sources, leadingComments, fixedTopLevels, _a, schemaString, wroteSchemaToFile, numSources, gqlSources, _i, _b, queryFile, schemaFileName, schema, query, name, _c, _d, collectionFile, collectionJSON, _e, postmanSources, description, _f, postmanSources_1, src, handlebarsTemplate, components, debugAll, debugPrintGraph, checkProvenance, debugPrintReconstitution, debugPrintGatherNames, debugPrintTransformations, _g, components_1, component, lang;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    if (options.help) {
                        usage(targetLanguages === undefined ? defaultTargetLanguages.all : targetLanguages);
                        return [2 /*return*/, undefined];
                    }
                    if (options.version) {
                        console.log("quicktype version " + packageJSON.version);
                        console.log("Visit quicktype.io for more info.");
                        return [2 /*return*/, undefined];
                    }
                    if (options.buildMarkovChain !== undefined) {
                        contents = fs.readFileSync(options.buildMarkovChain).toString();
                        lines = contents.split("\n");
                        mc = MarkovChain_1.train(lines, 3);
                        console.log(JSON.stringify(mc));
                        return [2 /*return*/, undefined];
                    }
                    sources = [];
                    leadingComments = undefined;
                    fixedTopLevels = false;
                    _a = options.srcLang;
                    switch (_a) {
                        case "graphql": return [3 /*break*/, 1];
                        case "json": return [3 /*break*/, 8];
                        case "schema": return [3 /*break*/, 8];
                        case "typescript": return [3 /*break*/, 10];
                        case "postman": return [3 /*break*/, 11];
                    }
                    return [3 /*break*/, 12];
                case 1:
                    schemaString = undefined;
                    wroteSchemaToFile = false;
                    if (!(options.graphqlIntrospect !== undefined)) return [3 /*break*/, 3];
                    return [4 /*yield*/, GraphQLIntrospection_1.introspectServer(options.graphqlIntrospect, Support_1.withDefault(options.graphqlServerHeader, []))];
                case 2:
                    schemaString = _h.sent();
                    if (options.graphqlSchema !== undefined) {
                        fs.writeFileSync(options.graphqlSchema, schemaString);
                        wroteSchemaToFile = true;
                    }
                    _h.label = 3;
                case 3:
                    numSources = options.src.length;
                    if (numSources !== 1) {
                        if (wroteSchemaToFile) {
                            // We're done.
                            return [2 /*return*/, undefined];
                        }
                        if (numSources === 0) {
                            return [2 /*return*/, Messages_1.messageError("DriverNoGraphQLQueryGiven", {})];
                        }
                    }
                    gqlSources = [];
                    _i = 0, _b = options.src;
                    _h.label = 4;
                case 4:
                    if (!(_i < _b.length)) return [3 /*break*/, 7];
                    queryFile = _b[_i];
                    schemaFileName = undefined;
                    if (schemaString === undefined) {
                        schemaFileName = Support_1.defined(options.graphqlSchema);
                        schemaString = fs.readFileSync(schemaFileName, "utf8");
                    }
                    schema = Support_1.parseJSON(schemaString, "GraphQL schema", schemaFileName);
                    return [4 /*yield*/, NodeIO_1.readableFromFileOrURL(queryFile)];
                case 5:
                    query = _h.sent();
                    name = numSources === 1 ? options.topLevel : typeNameFromFilename(queryFile);
                    gqlSources.push({ kind: "graphql", name: name, schema: schema, query: query });
                    _h.label = 6;
                case 6:
                    _i++;
                    return [3 /*break*/, 4];
                case 7:
                    sources = gqlSources;
                    return [3 /*break*/, 13];
                case 8: return [4 /*yield*/, getSources(options)];
                case 9:
                    sources = _h.sent();
                    return [3 /*break*/, 13];
                case 10:
                    sources = [makeTypeScriptSource(options.src)];
                    return [3 /*break*/, 13];
                case 11:
                    for (_c = 0, _d = options.src; _c < _d.length; _c++) {
                        collectionFile = _d[_c];
                        collectionJSON = fs.readFileSync(collectionFile, "utf8");
                        _e = PostmanCollection_1.sourcesFromPostmanCollection(collectionJSON, collectionFile), postmanSources = _e.sources, description = _e.description;
                        for (_f = 0, postmanSources_1 = postmanSources; _f < postmanSources_1.length; _f++) {
                            src = postmanSources_1[_f];
                            sources.push(src);
                        }
                        if (postmanSources.length > 1) {
                            fixedTopLevels = true;
                        }
                        if (description !== undefined) {
                            leadingComments = wordWrap(description).split("\n");
                        }
                    }
                    return [3 /*break*/, 13];
                case 12: return [2 /*return*/, Messages_1.messageError("DriverUnknownSourceLanguage", { lang: options.srcLang })];
                case 13:
                    handlebarsTemplate = undefined;
                    if (options.template !== undefined) {
                        handlebarsTemplate = fs.readFileSync(options.template, "utf8");
                    }
                    components = Support_1.mapOptional(function (d) { return d.split(","); }, options.debug);
                    debugAll = components !== undefined && components.indexOf("all") >= 0;
                    debugPrintGraph = debugAll;
                    checkProvenance = debugAll;
                    debugPrintReconstitution = debugAll;
                    debugPrintGatherNames = debugAll;
                    debugPrintTransformations = debugAll;
                    if (components !== undefined) {
                        for (_g = 0, components_1 = components; _g < components_1.length; _g++) {
                            component = components_1[_g];
                            component = component.trim();
                            if (component === "print-graph") {
                                debugPrintGraph = true;
                            }
                            else if (component === "print-reconstitution") {
                                debugPrintReconstitution = true;
                            }
                            else if (component === "print-gather-names") {
                                debugPrintGatherNames = true;
                            }
                            else if (component === "print-transformations") {
                                debugPrintTransformations = true;
                            }
                            else if (component === "provenance") {
                                checkProvenance = true;
                            }
                            else if (component !== "all") {
                                return [2 /*return*/, Messages_1.messageError("DriverUnknownDebugOption", { option: component })];
                            }
                        }
                    }
                    if (telemetry.state() === "none") {
                        leadingComments = leadingComments !== undefined ? leadingComments : [];
                        leadingComments = telemetry.TELEMETRY_HEADER.split("\n").concat(leadingComments);
                    }
                    lang = __1.languageNamed(options.lang, targetLanguages);
                    if (lang === undefined) {
                        return [2 /*return*/, Messages_1.messageError("DriverUnknownOutputLanguage", { lang: options.lang })];
                    }
                    return [2 /*return*/, {
                            lang: lang,
                            sources: sources,
                            inferMaps: !options.noMaps,
                            inferEnums: !options.noEnums,
                            inferDates: !options.noDateTimes,
                            alphabetizeProperties: options.alphabetizeProperties,
                            allPropertiesOptional: options.allPropertiesOptional,
                            combineClasses: !options.noCombineClasses,
                            fixedTopLevels: fixedTopLevels,
                            noRender: options.noRender,
                            rendererOptions: options.rendererOptions,
                            leadingComments: leadingComments,
                            handlebarsTemplate: handlebarsTemplate,
                            findSimilarClassesSchemaURI: options.findSimilarClassesSchema,
                            outputFilename: Support_1.mapOptional(path.basename, options.out),
                            schemaStore: new NodeIO_1.FetchingJSONSchemaStore(),
                            debugPrintGraph: debugPrintGraph,
                            checkProvenance: checkProvenance,
                            debugPrintReconstitution: debugPrintReconstitution,
                            debugPrintGatherNames: debugPrintGatherNames,
                            debugPrintTransformations: debugPrintTransformations
                        }];
            }
        });
    });
}
exports.makeQuicktypeOptions = makeQuicktypeOptions;
function writeOutput(cliOptions, resultsByFilename) {
    var onFirst = true;
    resultsByFilename.forEach(function (_a, filename) {
        var lines = _a.lines, annotations = _a.annotations;
        var output = lines.join("\n");
        if (cliOptions.out !== undefined) {
            fs.writeFileSync(path.join(path.dirname(cliOptions.out), filename), output);
        }
        else {
            if (!onFirst) {
                process.stdout.write("\n");
            }
            process.stdout.write(output);
        }
        if (cliOptions.quiet) {
            return;
        }
        annotations.forEach(function (sa) {
            var annotation = sa.annotation;
            if (!(annotation instanceof Annotation_1.IssueAnnotationData))
                return;
            var lineNumber = sa.span.start.line;
            var humanLineNumber = lineNumber + 1;
            console.error("\nIssue in line " + humanLineNumber + ": " + annotation.message);
            console.error(humanLineNumber + ": " + lines[lineNumber]);
        });
        onFirst = false;
    });
}
exports.writeOutput = writeOutput;
function main(args) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        var cliOptions, quicktypeOptions, resultsByFilename;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, telemetry.init()];
                case 1:
                    _a.sent();
                    telemetry.pageview("/");
                    if (Array.isArray(args)) {
                        cliOptions = parseCLIOptions(args);
                    }
                    else {
                        cliOptions = inferCLIOptions(args, undefined);
                    }
                    if (cliOptions.telemetry !== undefined) {
                        switch (cliOptions.telemetry) {
                            case "enable":
                                telemetry.enable();
                                break;
                            case "disable":
                                telemetry.disable();
                                break;
                            default:
                                console.error(chalk.red("telemetry must be 'enable' or 'disable'"));
                                return [2 /*return*/];
                        }
                        if (Array.isArray(args) && args.length === 2) {
                            // This was merely a CLI run to set telemetry and we should not proceed
                            return [2 /*return*/];
                        }
                    }
                    return [4 /*yield*/, makeQuicktypeOptions(cliOptions)];
                case 2:
                    quicktypeOptions = _a.sent();
                    if (quicktypeOptions === undefined)
                        return [2 /*return*/];
                    telemetry.event("default", "quicktype", cliOptions.lang);
                    return [4 /*yield*/, telemetry.timeAsync("run", function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, __1.quicktypeMultiFile(quicktypeOptions)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); })];
                case 3:
                    resultsByFilename = _a.sent();
                    writeOutput(cliOptions, resultsByFilename);
                    return [2 /*return*/];
            }
        });
    });
}
exports.main = main;
if (require.main === module) {
    main(process.argv.slice(2)).catch(function (e) {
        if (e instanceof Error) {
            console.error("Error: " + e.message + ".");
        }
        else {
            console.error(e);
        }
        process.exit(1);
    });
}
