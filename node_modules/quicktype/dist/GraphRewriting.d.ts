import { Map, OrderedMap, OrderedSet, Set, Collection, List } from "immutable";
import { PrimitiveTypeKind, Type, ClassProperty } from "./Type";
import { TypeGraph } from "./TypeGraph";
import { TypeAttributes } from "./TypeAttributes";
import { TypeRef, TypeBuilder, StringTypeMapping } from "./TypeBuilder";
export interface TypeLookerUp {
    lookupTypeRefs(typeRefs: TypeRef[], forwardingRef?: TypeRef): TypeRef | undefined;
    reconstituteTypeRef(typeRef: TypeRef, attributes?: TypeAttributes, forwardingRef?: TypeRef): TypeRef;
}
export declare class TypeReconstituter<TBuilder extends BaseGraphRewriteBuilder> {
    private readonly _typeBuilder;
    private readonly _makeClassUnique;
    private readonly _typeAttributes;
    private readonly _forwardingRef;
    private readonly _register;
    private _wasUsed;
    private _typeRef;
    constructor(_typeBuilder: TBuilder, _makeClassUnique: boolean, _typeAttributes: TypeAttributes, _forwardingRef: TypeRef | undefined, _register: (tref: TypeRef) => void);
    private builderForNewType();
    private builderForSetting();
    getResult(): TypeRef;
    private register(tref);
    private registerAndAddAttributes(tref);
    lookup(tref: TypeRef): TypeRef | undefined;
    lookup<C extends Collection<any, TypeRef>>(trefs: C): C | undefined;
    reconstitute(tref: TypeRef): TypeRef;
    reconstitute<C extends Collection<any, TypeRef>>(trefs: C): C;
    getPrimitiveType(kind: PrimitiveTypeKind): void;
    getEnumType(cases: OrderedSet<string>): void;
    getUniqueMapType(): void;
    getMapType(values: TypeRef): void;
    getUniqueArrayType(): void;
    getArrayType(items: TypeRef): void;
    setArrayItems(items: TypeRef): void;
    getObjectType(properties: OrderedMap<string, ClassProperty>, additionalProperties: TypeRef | undefined): void;
    getUniqueObjectType(properties: OrderedMap<string, ClassProperty> | undefined, additionalProperties: TypeRef | undefined): void;
    getClassType(properties: OrderedMap<string, ClassProperty>): void;
    getUniqueClassType(isFixed: boolean, properties: OrderedMap<string, ClassProperty> | undefined): void;
    setObjectProperties(properties: OrderedMap<string, ClassProperty>, additionalProperties: TypeRef | undefined): void;
    getUnionType(members: OrderedSet<TypeRef>): void;
    getUniqueUnionType(): void;
    getIntersectionType(members: OrderedSet<TypeRef>): void;
    getUniqueIntersectionType(members?: OrderedSet<TypeRef>): void;
    setSetOperationMembers(members: OrderedSet<TypeRef>): void;
}
export declare abstract class BaseGraphRewriteBuilder extends TypeBuilder implements TypeLookerUp {
    protected readonly originalGraph: TypeGraph;
    protected readonly debugPrint: boolean;
    protected reconstitutedTypes: Map<number, TypeRef>;
    private _lostTypeAttributes;
    private _printIndent;
    constructor(originalGraph: TypeGraph, stringTypeMapping: StringTypeMapping, alphabetizeProperties: boolean, graphHasProvenanceAttributes: boolean, debugPrint: boolean);
    withForwardingRef(maybeForwardingRef: TypeRef | undefined, typeCreator: (forwardingRef: TypeRef) => TypeRef): TypeRef;
    reconstituteType(t: Type, attributes?: TypeAttributes, forwardingRef?: TypeRef): TypeRef;
    abstract lookupTypeRefs(typeRefs: TypeRef[], forwardingRef?: TypeRef, replaceSet?: boolean): TypeRef | undefined;
    protected abstract forceReconstituteTypeRef(originalRef: TypeRef, attributes?: TypeAttributes, maybeForwardingRef?: TypeRef): TypeRef;
    reconstituteTypeRef(originalRef: TypeRef, attributes?: TypeAttributes, maybeForwardingRef?: TypeRef): TypeRef;
    reconstituteTypeAttributes(attributes: TypeAttributes): TypeAttributes;
    protected assertTypeRefsToReconstitute(typeRefs: TypeRef[], forwardingRef?: TypeRef): void;
    protected changeDebugPrintIndent(delta: number): void;
    protected readonly debugPrintIndentation: string;
    finish(): TypeGraph;
    setLostTypeAttributes(): void;
    readonly lostTypeAttributes: boolean;
}
export declare class GraphRemapBuilder extends BaseGraphRewriteBuilder {
    private readonly _map;
    private _attributeSources;
    constructor(originalGraph: TypeGraph, stringTypeMapping: StringTypeMapping, alphabetizeProperties: boolean, graphHasProvenanceAttributes: boolean, _map: Map<Type, Type>, debugPrintRemapping: boolean);
    protected makeIdentity(_maker: () => List<any> | undefined): List<any> | undefined;
    private getMapTarget(tref);
    protected addForwardingIntersection(_forwardingRef: TypeRef, _tref: TypeRef): TypeRef;
    lookupTypeRefs(typeRefs: TypeRef[], forwardingRef?: TypeRef): TypeRef | undefined;
    protected forceReconstituteTypeRef(originalRef: TypeRef, attributes?: TypeAttributes, maybeForwardingRef?: TypeRef): TypeRef;
}
export declare class GraphRewriteBuilder<T extends Type> extends BaseGraphRewriteBuilder {
    private readonly _replacer;
    private _setsToReplaceByMember;
    private _reconstitutedUnions;
    constructor(originalGraph: TypeGraph, stringTypeMapping: StringTypeMapping, alphabetizeProperties: boolean, graphHasProvenanceAttributes: boolean, setsToReplace: T[][], debugPrintReconstitution: boolean, _replacer: (typesToReplace: Set<T>, builder: GraphRewriteBuilder<T>, forwardingRef: TypeRef) => TypeRef);
    registerUnion(typeRefs: TypeRef[], reconstituted: TypeRef): void;
    private replaceSet(typesToReplace, maybeForwardingRef);
    protected forceReconstituteTypeRef(originalRef: TypeRef, attributes?: TypeAttributes, maybeForwardingRef?: TypeRef): TypeRef;
    lookupTypeRefs(typeRefs: TypeRef[], forwardingRef?: TypeRef, replaceSet?: boolean): TypeRef | undefined;
}
