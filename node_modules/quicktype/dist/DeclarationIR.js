"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Support_1 = require("./Support");
var Graph_1 = require("./Graph");
var Messages_1 = require("./Messages");
var Declaration = /** @class */ (function () {
    function Declaration(kind, type) {
        this.kind = kind;
        this.type = type;
    }
    Declaration.prototype.equals = function (other) {
        if (!(other instanceof Declaration))
            return false;
        return this.kind === other.kind && this.type.equals(other.type);
    };
    Declaration.prototype.hashCode = function () {
        return (immutable_1.hash(this.kind) + this.type.hashCode()) | 0;
    };
    return Declaration;
}());
exports.Declaration = Declaration;
var DeclarationIR = /** @class */ (function () {
    function DeclarationIR(declarations, forwardedTypes) {
        this.declarations = declarations;
        this.forwardedTypes = forwardedTypes;
    }
    return DeclarationIR;
}());
exports.DeclarationIR = DeclarationIR;
function findBreaker(t, path, canBreak) {
    var index = path.indexOf(t);
    if (index < 0)
        return undefined;
    if (canBreak === undefined) {
        return path.get(index);
    }
    var potentialBreakers = path.take(index + 1).reverse();
    var maybeBreaker = potentialBreakers.find(canBreak);
    if (maybeBreaker === undefined) {
        return Support_1.panic("Found a cycle that cannot be broken");
    }
    return maybeBreaker;
}
function cycleBreakerTypesForGraph(graph, isImplicitCycleBreaker, canBreakCycles) {
    var visitedTypes = immutable_1.Set();
    var cycleBreakerTypes = immutable_1.Set();
    var queue = graph.topLevels.valueSeq().toArray();
    function visit(t, path) {
        if (visitedTypes.has(t))
            return;
        if (isImplicitCycleBreaker(t)) {
            queue.push.apply(queue, t.getChildren().toArray());
        }
        else {
            var maybeBreaker = findBreaker(t, path, canBreakCycles);
            if (maybeBreaker !== undefined) {
                cycleBreakerTypes = cycleBreakerTypes.add(maybeBreaker);
                return;
            }
            var pathForChildren_1 = path.unshift(t);
            t.getChildren().forEach(function (c) { return visit(c, pathForChildren_1); });
        }
        visitedTypes = visitedTypes.add(t);
    }
    for (;;) {
        var maybeType = queue.pop();
        if (maybeType === undefined)
            break;
        visit(maybeType, immutable_1.List());
    }
    return cycleBreakerTypes;
}
exports.cycleBreakerTypesForGraph = cycleBreakerTypesForGraph;
function declarationsForGraph(typeGraph, canBeForwardDeclared, childrenOfType, needsDeclaration) {
    /*
    function nodeTitle(t: Type): string {
        const indexAndKind = `${t.typeRef.index} ${t.kind}`;
        if (t.hasNames) {
            return `${indexAndKind} ${t.getCombinedName()}`;
        } else {
            return indexAndKind;
        }
    }
    function componentName(c: OrderedSet<Type>): string {
        return c.map(nodeTitle).join(", ");
    }
    */
    var topDown = canBeForwardDeclared === undefined;
    var declarations = [];
    var forwardedTypes = immutable_1.Set();
    var visitedComponents = immutable_1.Set();
    function processGraph(graph, _writeComponents) {
        var componentsGraph = graph.stronglyConnectedComponents();
        function visitComponent(component) {
            if (visitedComponents.has(component))
                return;
            visitedComponents = visitedComponents.add(component);
            // console.log(`visiting component ${componentName(component)}`);
            var declarationNeeded = component.filter(needsDeclaration);
            // 1. Only one node in the cycle needs a declaration, in which
            // case it's the breaker, and no forward declaration is necessary.
            if (declarationNeeded.size === 1) {
                declarations.push(new Declaration("define", Support_1.defined(declarationNeeded.first())));
                return;
            }
            // 2. No node in the cycle needs a declaration, but it's also
            // the only node, so we don't actually need a declaration at all.
            if (declarationNeeded.isEmpty() && component.size === 1) {
                return;
            }
            // 3. No node in the cycle needs a declaration, but there's more.
            // than one node total.  We have to pick a node to make a
            // declaration, so we can pick any one. This is not a forward
            // declaration, either.
            if (declarationNeeded.isEmpty()) {
                declarations.push(new Declaration("define", Support_1.defined(component.first())));
                return;
            }
            // 4. More than one node needs a declaration, and we don't need
            // forward declarations.  Just declare all of them and be done
            // with it.
            if (canBeForwardDeclared === undefined) {
                declarationNeeded.forEach(function (t) {
                    declarations.push(new Declaration("define", t));
                });
                return;
            }
            // 5. More than one node needs a declaration, and we have
            // to make forward declarations.  We do the simple thing and first
            // forward-declare all forward-declarable types in the SCC.  If
            // there are none, we're stuck.  If there are, we take them out of
            // the component and try the whole thing again recursively.  Then
            // we declare the types we previously forward-declared.
            var forwardDeclarable = component.filter(canBeForwardDeclared);
            if (forwardDeclarable.isEmpty()) {
                return Messages_1.messageError("IRNoForwardDeclarableTypeInCycle", {});
            }
            forwardDeclarable.forEach(function (t) {
                declarations.push(new Declaration("forward", t));
            });
            forwardedTypes = forwardedTypes.union(forwardDeclarable);
            var rest = component.subtract(forwardDeclarable);
            var restGraph = new Graph_1.Graph(rest.toArray(), true, function (t) { return childrenOfType(t).intersect(rest); });
            processGraph(restGraph, false);
            forwardDeclarable.forEach(function (t) {
                declarations.push(new Declaration("define", t));
            });
            return;
        }
        /*
        if (_writeComponents) {
            componentsGraph.nodes.forEach(types => {
                console.log(
                    `scc: ${types
                        .filter(t => t instanceof ClassType)
                        .map(t => t.getCombinedName())
                        .join(", ")}`
                );
            });
        }
        */
        var rootsUnordered = componentsGraph.findRoots();
        var roots = rootsUnordered;
        roots.forEach(function (component) {
            componentsGraph.dfsTraversal(component, topDown, visitComponent);
        });
    }
    var fullGraph = typeGraph.makeGraph(false, childrenOfType);
    // fs.writeFileSync("graph.dot", fullGraph.makeDot(t => !(t instanceof PrimitiveType), nodeTitle));
    processGraph(fullGraph, true);
    return new DeclarationIR(immutable_1.List(declarations), forwardedTypes);
}
exports.declarationsForGraph = declarationsForGraph;
