"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("./Type");
var TypeUtils_1 = require("./TypeUtils");
var UnionBuilder_1 = require("./UnionBuilder");
var Support_1 = require("./Support");
var TypeAttributes_1 = require("./TypeAttributes");
function getCliqueProperties(clique, makePropertyType) {
    var lostTypeAttributes = false;
    var propertyNames = immutable_1.OrderedSet();
    for (var _i = 0, clique_1 = clique; _i < clique_1.length; _i++) {
        var o = clique_1[_i];
        propertyNames = propertyNames.union(o.getProperties().keySeq());
    }
    var properties = propertyNames
        .toArray()
        .map(function (name) { return [name, immutable_1.OrderedSet(), false]; });
    var additionalProperties = undefined;
    for (var _a = 0, clique_2 = clique; _a < clique_2.length; _a++) {
        var o = clique_2[_a];
        var additional = o.getAdditionalProperties();
        if (additional !== undefined) {
            if (additionalProperties === undefined) {
                additionalProperties = immutable_1.OrderedSet();
            }
            if (additional !== undefined) {
                additionalProperties = additionalProperties.add(additional);
            }
        }
        for (var i = 0; i < properties.length; i++) {
            var _b = properties[i], name = _b[0], types = _b[1], isOptional = _b[2];
            var maybeProperty = o.getProperties().get(name);
            if (maybeProperty === undefined) {
                isOptional = true;
                if (additional !== undefined && additional.kind !== "any") {
                    types = types.add(additional);
                }
            }
            else {
                if (maybeProperty.isOptional) {
                    isOptional = true;
                }
                types = types.add(maybeProperty.type);
            }
            properties[i][1] = types;
            properties[i][2] = isOptional;
        }
    }
    var unifiedAdditionalProperties = additionalProperties === undefined ? undefined : makePropertyType(additionalProperties);
    var unifiedPropertiesArray = properties.map(function (_a) {
        var name = _a[0], types = _a[1], isOptional = _a[2];
        return [name, new Type_1.ClassProperty(makePropertyType(types), isOptional)];
    });
    var unifiedProperties = immutable_1.OrderedMap(unifiedPropertiesArray);
    return [unifiedProperties, unifiedAdditionalProperties, lostTypeAttributes];
}
function countProperties(clique) {
    var hasProperties = false;
    var hasAdditionalProperties = false;
    var hasNonAnyAdditionalProperties = false;
    for (var _i = 0, clique_3 = clique; _i < clique_3.length; _i++) {
        var o = clique_3[_i];
        if (!o.getProperties().isEmpty()) {
            hasProperties = true;
        }
        var additional = o.getAdditionalProperties();
        if (additional !== undefined) {
            hasAdditionalProperties = true;
            if (additional.kind !== "any") {
                hasNonAnyAdditionalProperties = true;
            }
        }
    }
    return { hasProperties: hasProperties, hasAdditionalProperties: hasAdditionalProperties, hasNonAnyAdditionalProperties: hasNonAnyAdditionalProperties };
}
var UnifyUnionBuilder = /** @class */ (function (_super) {
    __extends(UnifyUnionBuilder, _super);
    function UnifyUnionBuilder(typeBuilder, _makeObjectTypes, _makeClassesFixed, _unifyTypes) {
        var _this = _super.call(this, typeBuilder) || this;
        _this._makeObjectTypes = _makeObjectTypes;
        _this._makeClassesFixed = _makeClassesFixed;
        _this._unifyTypes = _unifyTypes;
        return _this;
    }
    UnifyUnionBuilder.prototype.makeObject = function (objectRefs, typeAttributes, forwardingRef) {
        var _this = this;
        var maybeTypeRef = this.typeBuilder.lookupTypeRefs(objectRefs, forwardingRef);
        if (maybeTypeRef !== undefined) {
            Support_1.assert(forwardingRef === undefined || maybeTypeRef === forwardingRef, "The forwarding ref must be consumed");
            this.typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
            return maybeTypeRef;
        }
        var objectTypes = objectRefs.map(function (r) { return TypeUtils_1.assertIsObject(r.deref()[0]); });
        var _a = countProperties(objectTypes), hasProperties = _a.hasProperties, hasAdditionalProperties = _a.hasAdditionalProperties, hasNonAnyAdditionalProperties = _a.hasNonAnyAdditionalProperties;
        if (!this._makeObjectTypes && (hasNonAnyAdditionalProperties || (!hasProperties && hasAdditionalProperties))) {
            var propertyTypes = Support_1.unionOfSets(objectTypes.map(function (o) {
                return o
                    .getProperties()
                    .map(function (cp) { return cp.typeRef; })
                    .toOrderedSet();
            }));
            var additionalPropertyTypes = immutable_1.OrderedSet(objectTypes
                .filter(function (o) { return o.getAdditionalProperties() !== undefined; })
                .map(function (o) { return Support_1.defined(o.getAdditionalProperties()).typeRef; }));
            var allPropertyTypes = propertyTypes.union(additionalPropertyTypes).toArray();
            return this.typeBuilder.getMapType(typeAttributes, this._unifyTypes(allPropertyTypes));
        }
        else {
            var _b = getCliqueProperties(objectTypes, function (types) {
                Support_1.assert(types.size > 0, "Property has no type");
                return _this._unifyTypes(types.map(function (t) { return t.typeRef; }).toArray());
            }), properties = _b[0], additionalProperties = _b[1], lostTypeAttributes = _b[2];
            if (lostTypeAttributes) {
                this.typeBuilder.setLostTypeAttributes();
            }
            if (this._makeObjectTypes) {
                return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
            }
            else {
                Support_1.assert(additionalProperties === undefined, "We have additional properties but want to make a class");
                return this.typeBuilder.getUniqueClassType(typeAttributes, this._makeClassesFixed, properties, forwardingRef);
            }
        }
    };
    UnifyUnionBuilder.prototype.makeArray = function (arrays, typeAttributes, forwardingRef) {
        var ref = this.typeBuilder.getArrayType(this._unifyTypes(arrays), forwardingRef);
        this.typeBuilder.addAttributes(ref, typeAttributes);
        return ref;
    };
    return UnifyUnionBuilder;
}(UnionBuilder_1.UnionBuilder));
exports.UnifyUnionBuilder = UnifyUnionBuilder;
function unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers) {
    return new UnifyUnionBuilder(typeBuilder, makeObjectTypes, makeClassesFixed, function (trefs) {
        return unifyTypes(immutable_1.Set(trefs.map(function (tref) { return tref.deref()[0]; })), TypeAttributes_1.emptyTypeAttributes, typeBuilder, unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers), conflateNumbers);
    });
}
exports.unionBuilderForUnification = unionBuilderForUnification;
// FIXME: The UnionBuilder might end up not being used.
function unifyTypes(types, typeAttributes, typeBuilder, unionBuilder, conflateNumbers, maybeForwardingRef) {
    if (types.isEmpty()) {
        return Support_1.panic("Cannot unify empty set of types");
    }
    else if (types.count() === 1) {
        var first = Support_1.defined(types.first());
        if (!(first instanceof Type_1.UnionType)) {
            return typeBuilder.reconstituteTypeRef(first.typeRef, typeAttributes, maybeForwardingRef);
        }
    }
    var typeRefs = types.toArray().map(function (t) { return t.typeRef; });
    var maybeTypeRef = typeBuilder.lookupTypeRefs(typeRefs, maybeForwardingRef);
    if (maybeTypeRef !== undefined) {
        typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
        return maybeTypeRef;
    }
    var accumulator = new UnionBuilder_1.TypeRefUnionAccumulator(conflateNumbers);
    var nestedAttributes = accumulator.addTypes(types);
    typeAttributes = TypeAttributes_1.combineTypeAttributes("union", typeAttributes, nestedAttributes);
    return typeBuilder.withForwardingRef(maybeForwardingRef, function (forwardingRef) {
        typeBuilder.registerUnion(typeRefs, forwardingRef);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
    });
}
exports.unifyTypes = unifyTypes;
