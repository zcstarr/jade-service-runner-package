"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var immutable_1 = require("immutable");
var Naming_1 = require("./Naming");
var Support_1 = require("./Support");
function newline() {
    // We're returning a new object instead of using a singleton
    // here because `Renderer` will modify `indentationChange`.
    return { kind: "newline", indentationChange: 0 };
}
exports.newline = newline;
function sourcelikeToSource(sl) {
    if (sl instanceof Array) {
        return {
            kind: "sequence",
            sequence: immutable_1.List(sl.map(sourcelikeToSource))
        };
    }
    if (typeof sl === "string") {
        var lines = sl.split("\n");
        if (lines.length === 1) {
            return { kind: "text", text: sl };
        }
        return {
            kind: "sequence",
            sequence: Support_1.intercalate(newline(), immutable_1.List(lines).map(function (l) { return ({ kind: "text", text: l }); })).toList()
        };
    }
    if (sl instanceof Naming_1.Name) {
        return { kind: "name", named: sl };
    }
    return sl;
}
exports.sourcelikeToSource = sourcelikeToSource;
function annotated(annotation, sl) {
    return {
        kind: "annotated",
        annotation: annotation,
        source: sourcelikeToSource(sl)
    };
}
exports.annotated = annotated;
function maybeAnnotated(doAnnotate, annotation, sl) {
    if (!doAnnotate) {
        return sl;
    }
    return annotated(annotation, sl);
}
exports.maybeAnnotated = maybeAnnotated;
function modifySource(modifier, sl) {
    return {
        kind: "modified",
        modifier: modifier,
        source: sourcelikeToSource(sl)
    };
}
exports.modifySource = modifySource;
function sourceLineLength(source, names) {
    switch (source.kind) {
        case "text":
            return source.text.length;
        case "newline":
            return Support_1.panic("Newline must not occur within a line.");
        case "sequence":
            return source.sequence
                .map(function (s) { return sourceLineLength(s, names); })
                .reduce(function (a, b) { return a + b; }, 0);
        case "table":
            return Support_1.panic("Table must not occur within a  line.");
        case "annotated":
            return sourceLineLength(source.source, names);
        case "name":
            return Support_1.defined(names.get(source.named)).length;
        case "modified":
            return serializeRenderResult(source, names, "").lines.join("\n").length;
        default:
            return Support_1.assertNever(source);
    }
}
function serializeRenderResult(rootSource, names, indentation) {
    var indent = 0;
    var indentNeeded = 0;
    var lines = [];
    var currentLine = [];
    var annotations = [];
    function indentIfNeeded() {
        if (indentNeeded === 0)
            return;
        currentLine.push(_.repeat(indentation, indentNeeded));
        indentNeeded = 0;
    }
    function flattenCurrentLine() {
        var str = currentLine.join("");
        currentLine = [str];
        return str;
    }
    function currentLocation() {
        return { line: lines.length, column: flattenCurrentLine().length };
    }
    function finishLine() {
        lines.push(flattenCurrentLine());
        currentLine = [];
    }
    function serializeToStringArray(source) {
        switch (source.kind) {
            case "text":
                indentIfNeeded();
                currentLine.push(source.text);
                break;
            case "newline":
                finishLine();
                indent += source.indentationChange;
                indentNeeded = indent;
                break;
            case "sequence":
                source.sequence.forEach(function (s) { return serializeToStringArray(s); });
                break;
            case "table":
                var t = source.table;
                var widths_1 = t.map(function (l) { return l.map(function (s) { return sourceLineLength(s, names); }).toList(); }).toList();
                var numRows = t.size;
                if (numRows === 0)
                    break;
                var numColumns = Support_1.defined(t.map(function (l) { return l.size; }).max());
                if (numColumns === 0)
                    break;
                var columnWidths = Support_1.defined(immutable_1.Range(0, numColumns).map(function (i) { return widths_1.map(function (l) { return Support_1.withDefault(l.get(i), 0); }).max(); }));
                for (var y = 0; y < numRows; y++) {
                    indentIfNeeded();
                    var row = Support_1.defined(t.get(y));
                    var rowWidths = Support_1.defined(widths_1.get(y));
                    for (var x = 0; x < numColumns; x++) {
                        var colWidth = Support_1.defined(columnWidths.get(x));
                        var src = Support_1.withDefault(row.get(x), { kind: "text", text: "" });
                        var srcWidth = Support_1.withDefault(rowWidths.get(x), 0);
                        serializeToStringArray(src);
                        if (x < numColumns - 1 && srcWidth < colWidth) {
                            currentLine.push(_.repeat(" ", colWidth - srcWidth));
                        }
                    }
                    if (y < numRows - 1) {
                        finishLine();
                        indentNeeded = indent;
                    }
                }
                break;
            case "annotated":
                var start = currentLocation();
                serializeToStringArray(source.source);
                var end = currentLocation();
                annotations.push({ annotation: source.annotation, span: { start: start, end: end } });
                break;
            case "name":
                Support_1.assert(names.has(source.named), "No name for Named");
                indentIfNeeded();
                currentLine.push(Support_1.defined(names.get(source.named)));
                break;
            case "modified":
                indentIfNeeded();
                var serialized = serializeRenderResult(source.source, names, indentation).lines;
                Support_1.assert(serialized.length === 1, "Cannot modify more than one line.");
                currentLine.push(source.modifier(serialized[0]));
                break;
            default:
                return Support_1.assertNever(source);
        }
    }
    serializeToStringArray(rootSource);
    finishLine();
    return { lines: lines, annotations: immutable_1.List(annotations) };
}
exports.serializeRenderResult = serializeRenderResult;
function singleWord(source) {
    return { source: source, needsParens: false };
}
exports.singleWord = singleWord;
function multiWord(separator) {
    var words = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        words[_i - 1] = arguments[_i];
    }
    Support_1.assert(words.length > 0, "Zero words is not multiple");
    if (words.length === 1) {
        return singleWord(words[0]);
    }
    var items = [];
    for (var i = 0; i < words.length; i++) {
        if (i > 0)
            items.push(separator);
        items.push(words[i]);
    }
    return { source: items, needsParens: true };
}
exports.multiWord = multiWord;
function parenIfNeeded(_a) {
    var source = _a.source, needsParens = _a.needsParens;
    if (needsParens) {
        return ["(", source, ")"];
    }
    return source;
}
exports.parenIfNeeded = parenIfNeeded;
