import { OrderedMap } from "immutable";
import { TypeGraph } from "./TypeGraph";
import { Renderer } from "./Renderer";
import { OptionDefinition, Option } from "./RendererOptions";
import { SerializedRenderResult } from "./Source";
import { StringTypeMapping } from "./TypeBuilder";
import { UnionType } from "./Type";
export declare abstract class TargetLanguage {
    readonly displayName: string;
    readonly names: string[];
    readonly extension: string;
    constructor(displayName: string, names: string[], extension: string);
    protected abstract getOptions(): Option<any>[];
    readonly optionDefinitions: OptionDefinition[];
    readonly cliOptionDefinitions: {
        display: OptionDefinition[];
        actual: OptionDefinition[];
    };
    readonly name: string;
    protected readonly abstract rendererClass: new (targetLanguage: TargetLanguage, graph: TypeGraph, leadingComments: string[] | undefined, ...optionValues: any[]) => Renderer;
    private makeRenderer(graph, leadingComments, rendererOptions);
    renderGraphAndSerialize(graph: TypeGraph, givenOutputFilename: string, alphabetizeProperties: boolean, leadingComments: string[] | undefined, rendererOptions: {
        [name: string]: any;
    }, indentation?: string): OrderedMap<string, SerializedRenderResult>;
    processHandlebarsTemplate(graph: TypeGraph, rendererOptions: {
        [name: string]: any;
    }, template: string): SerializedRenderResult;
    protected readonly defaultIndentation: string;
    protected readonly partialStringTypeMapping: Partial<StringTypeMapping>;
    readonly stringTypeMapping: StringTypeMapping;
    readonly supportsOptionalClassProperties: boolean;
    readonly supportsUnionsWithBothNumberTypes: boolean;
    readonly supportsFullObjectType: boolean;
    needsTransformerForUnion(_u: UnionType): boolean;
    readonly needsTransformerForEnums: boolean;
    readonly needsTransformersForDateTime: boolean;
}
