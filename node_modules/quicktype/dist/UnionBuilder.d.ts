import { Set, OrderedMap, OrderedSet } from "immutable";
import { TypeKind, PrimitiveStringTypeKind, Type } from "./Type";
import { TypeAttributes } from "./TypeAttributes";
import { TypeRef, TypeBuilder } from "./TypeBuilder";
import { StringTypes } from "./StringTypes";
export interface UnionTypeProvider<TArrayData, TObjectData> {
    readonly arrayData: TArrayData;
    readonly objectData: TObjectData;
    readonly enumCases: OrderedSet<string>;
    getMemberKinds(): TypeAttributeMap<TypeKind>;
    readonly lostTypeAttributes: boolean;
}
export declare type TypeAttributeMap<T extends TypeKind> = OrderedMap<T, TypeAttributes>;
export declare class UnionAccumulator<TArray, TObject> implements UnionTypeProvider<TArray[], TObject[]> {
    private readonly _conflateNumbers;
    private _nonStringTypeAttributes;
    private _stringTypeAttributes;
    readonly arrayData: TArray[];
    readonly objectData: TObject[];
    private _enumCases;
    private _lostTypeAttributes;
    constructor(_conflateNumbers: boolean);
    private have(kind);
    addNone(_attributes: TypeAttributes): void;
    addAny(attributes: TypeAttributes): void;
    addNull(attributes: TypeAttributes): void;
    addBool(attributes: TypeAttributes): void;
    addInteger(attributes: TypeAttributes): void;
    addDouble(attributes: TypeAttributes): void;
    protected addFullStringType(attributes: TypeAttributes, stringTypes: StringTypes | undefined): void;
    addStringType(kind: PrimitiveStringTypeKind, attributes: TypeAttributes, stringTypes?: StringTypes): void;
    addArray(t: TArray, attributes: TypeAttributes): void;
    addObject(t: TObject, attributes: TypeAttributes): void;
    addEnum(cases: OrderedSet<string>, attributes: TypeAttributes): void;
    addStringCases(cases: string[], attributes: TypeAttributes): void;
    addStringCase(s: string, count: number, attributes: TypeAttributes): void;
    readonly enumCases: OrderedSet<string>;
    getMemberKinds(): TypeAttributeMap<TypeKind>;
    readonly lostTypeAttributes: boolean;
}
export declare class TypeRefUnionAccumulator extends UnionAccumulator<TypeRef, TypeRef> {
    private addType(t, attributes);
    addTypes(types: Set<Type>): TypeAttributes;
}
export declare abstract class UnionBuilder<TBuilder extends TypeBuilder, TArrayData, TObjectData> {
    protected readonly typeBuilder: TBuilder;
    constructor(typeBuilder: TBuilder);
    protected abstract makeObject(objects: TObjectData, typeAttributes: TypeAttributes, forwardingRef: TypeRef | undefined): TypeRef;
    protected abstract makeArray(arrays: TArrayData, typeAttributes: TypeAttributes, forwardingRef: TypeRef | undefined): TypeRef;
    private makeTypeOfKind(typeProvider, kind, typeAttributes, forwardingRef);
    buildUnion(typeProvider: UnionTypeProvider<TArrayData, TObjectData>, unique: boolean, typeAttributes: TypeAttributes, forwardingRef?: TypeRef): TypeRef;
}
