import { Map, Set, OrderedSet } from "immutable";
import { Type, ClassType, EnumType, UnionType, TypeKind, ClassProperty, ObjectType } from "./Type";
import { Namespace, Name, Namer, DependencyName } from "./Naming";
import { Renderer, BlankLineLocations } from "./Renderer";
import { StringMap } from "./Support";
import { Sourcelike } from "./Source";
import { Declaration } from "./DeclarationIR";
export declare type ForbiddenWordsInfo = {
    names: (Name | string)[];
    includeGlobalForbidden: boolean;
};
export declare abstract class ConvenienceRenderer extends Renderer {
    private _globalForbiddenNamespace;
    private _otherForbiddenNamespaces;
    private _globalNamespace;
    private _nameStoreView;
    private _propertyNamesStoreView;
    private _memberNamesStoreView;
    private _caseNamesStoreView;
    private _namesForTransformations;
    private _namedTypeNamer;
    private _unionMemberNamer;
    private _enumCaseNamer;
    private _declarationIR;
    private _namedTypes;
    private _namedObjects;
    private _namedEnums;
    private _namedUnions;
    private _haveUnions;
    private _haveMaps;
    private _haveOptionalProperties;
    private _cycleBreakerTypes?;
    private _alphabetizeProperties;
    readonly topLevels: Map<string, Type>;
    protected forbiddenNamesForGlobalNamespace(): string[];
    protected forbiddenForObjectProperties(_o: ObjectType, _className: Name): ForbiddenWordsInfo;
    protected forbiddenForUnionMembers(_u: UnionType, _unionName: Name): ForbiddenWordsInfo;
    protected forbiddenForEnumCases(_e: EnumType, _enumName: Name): ForbiddenWordsInfo;
    protected makeTopLevelDependencyNames(_t: Type, _topLevelName: Name): DependencyName[];
    protected makeNamedTypeDependencyNames(_t: Type, _name: Name): DependencyName[];
    protected abstract makeNamedTypeNamer(): Namer;
    protected abstract namerForObjectProperty(o: ObjectType, p: ClassProperty): Namer | null;
    protected abstract makeUnionMemberNamer(): Namer | null;
    protected abstract makeEnumCaseNamer(): Namer | null;
    protected abstract emitSourceStructure(givenOutputFilename: string): void;
    protected makeNameForTransformation(_t: Type, _typeName: Name | undefined): Name | undefined;
    protected namedTypeToNameForTopLevel(type: Type): Type | undefined;
    protected readonly unionMembersInGlobalNamespace: boolean;
    protected readonly enumCasesInGlobalNamespace: boolean;
    protected readonly needsTypeDeclarationBeforeUse: boolean;
    protected canBeForwardDeclared(_t: Type): boolean;
    protected unionNeedsName(u: UnionType): boolean;
    private readonly globalNamespace;
    private readonly nameStoreView;
    protected descriptionForType(t: Type): string[] | undefined;
    protected descriptionForClassProperty(c: ClassType, name: string): string[] | undefined;
    protected setUpNaming(): OrderedSet<Namespace>;
    private addDependenciesForNamedType;
    protected makeNameForTopLevel(_t: Type, givenName: string, _maybeNamedType: Type | undefined): Name;
    private addNameForTopLevel;
    private makeNameForType(t, namer, givenOrder, inferredOrder);
    protected makeNameForNamedType(t: Type): Name;
    private addNameForNamedType;
    protected readonly typesWithNamedTransformations: Map<Type, Name>;
    protected nameForTransformation(t: Type): Name | undefined;
    private addNameForTransformation(t);
    private processForbiddenWordsInfo(info, namespaceName);
    protected makeNameForProperty(o: ObjectType, _className: Name, p: ClassProperty, jsonName: string, assignedName: string | undefined): Name | undefined;
    protected makePropertyDependencyNames(_o: ObjectType, _className: Name, _p: ClassProperty, _jsonName: string, _name: Name): Name[];
    private addPropertyNames;
    protected makeNameForUnionMember(u: UnionType, unionName: Name, t: Type): Name;
    private addUnionMemberNames;
    protected makeNameForEnumCase(e: EnumType, _enumName: Name, caseName: string, assignedName: string | undefined): Name;
    private addEnumCaseNames;
    private childrenOfType;
    protected readonly namedUnions: OrderedSet<UnionType>;
    protected readonly haveNamedUnions: boolean;
    protected readonly haveNamedTypes: boolean;
    protected readonly haveUnions: boolean;
    protected readonly haveMaps: boolean;
    protected readonly haveOptionalProperties: boolean;
    protected readonly enums: OrderedSet<EnumType>;
    protected readonly haveEnums: boolean;
    protected proposedUnionMemberNameForTypeKind: (_kind: TypeKind) => string | null;
    protected proposeUnionMemberName(_u: UnionType, _unionName: Name, fieldType: Type, lookup: (n: Name) => string): string;
    protected nameForNamedType: (t: Type) => Name;
    protected isForwardDeclaredType(t: Type): boolean;
    protected isImplicitCycleBreaker(_t: Type): boolean;
    protected canBreakCycles(_t: Type): boolean;
    protected isCycleBreakerType(t: Type): boolean;
    protected forEachTopLevel: (blankLocations: BlankLineLocations, f: (t: Type, name: Name) => void, predicate?: ((t: Type) => boolean) | undefined) => void;
    protected forEachDeclaration(blankLocations: BlankLineLocations, f: (decl: Declaration) => void): void;
    setAlphabetizeProperties: (value: boolean) => void;
    protected forEachClassProperty: (o: ObjectType, blankLocations: BlankLineLocations, f: (name: Name, jsonName: string, p: ClassProperty) => void) => void;
    protected nameForUnionMember: (u: UnionType, t: Type) => Name;
    protected nameForEnumCase(e: EnumType, caseName: string): Name;
    protected forEachUnionMember: (u: UnionType, members: OrderedSet<Type> | null, blankLocations: BlankLineLocations, sortOrder: ((n: Name, t: Type) => string) | null, f: (name: Name, t: Type) => void) => void;
    protected forEachEnumCase: (e: EnumType, blankLocations: BlankLineLocations, f: (name: Name, jsonName: string) => void) => void;
    protected forEachTransformation(blankLocations: BlankLineLocations, f: (n: Name, t: Type) => void): void;
    protected callForNamedType<T extends Type>(t: T, f: (t: T, name: Name) => void): void;
    protected forEachSpecificNamedType<T extends Type>(blankLocations: BlankLineLocations, types: OrderedSet<T>, f: (t: T, name: Name) => void): void;
    protected forEachObject(blankLocations: BlankLineLocations, f: ((c: ClassType, className: Name) => void) | ((o: ObjectType, objectName: Name) => void)): void;
    protected forEachEnum: (blankLocations: BlankLineLocations, f: (u: EnumType, enumName: Name) => void) => void;
    protected forEachUnion: (blankLocations: BlankLineLocations, f: (u: UnionType, unionName: Name) => void) => void;
    protected forEachUniqueUnion<T>(blankLocations: BlankLineLocations, uniqueValue: (u: UnionType) => T, f: (firstUnion: UnionType, value: T) => void): void;
    protected forEachNamedType: (blankLocations: BlankLineLocations, objectFunc: ((c: ClassType, className: Name) => void) | ((o: ObjectType, objectName: Name) => void), enumFunc: (e: EnumType, enumName: Name) => void, unionFunc: (u: UnionType, unionName: Name) => void) => void;
    protected sourcelikeToString: (src: Sourcelike) => string;
    protected readonly commentLineStart: string;
    protected emitCommentLines(lines: string[], lineStart?: string, beforeLine?: string, afterLine?: string, firstLineStart?: string): void;
    protected emitDescription(description: string[] | undefined): void;
    protected emitDescriptionBlock(lines: string[]): void;
    protected emitPropertyTable(c: ClassType, makePropertyRow: (name: Name, jsonName: string, p: ClassProperty) => Sourcelike[]): void;
    private processGraph();
    protected emitSource(givenOutputFilename: string): void;
    protected makeHandlebarsContextForUnionMember(t: Type, name: Name): StringMap;
    protected makeHandlebarsContextForType(t: Type): StringMap;
    protected makeHandlebarsContext(): StringMap;
    protected registerHandlebarsHelpers(context: StringMap): void;
    protected forEachType<TResult>(process: (t: Type) => TResult): Set<TResult>;
}
