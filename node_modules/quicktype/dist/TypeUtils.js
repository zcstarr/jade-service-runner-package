"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Support_1 = require("./Support");
var TypeAttributes_1 = require("./TypeAttributes");
var Type_1 = require("./Type");
var StringTypes_1 = require("./StringTypes");
function assertIsObject(t) {
    if (t instanceof Type_1.ObjectType) {
        return t;
    }
    return Support_1.panic("Supposed object type is not an object type");
}
exports.assertIsObject = assertIsObject;
function assertIsClass(t) {
    if (!(t instanceof Type_1.ClassType)) {
        return Support_1.panic("Supposed class type is not a class type");
    }
    return t;
}
exports.assertIsClass = assertIsClass;
function setOperationMembersRecursively(oneOrMany, combinationKind) {
    var setOperations = Array.isArray(oneOrMany) ? oneOrMany : [oneOrMany];
    var kind = setOperations[0].kind;
    var includeAny = kind !== "intersection";
    var processedSetOperations = immutable_1.Set();
    var members = immutable_1.OrderedSet();
    var attributes = TypeAttributes_1.emptyTypeAttributes;
    function process(t) {
        if (t.kind === kind) {
            var so = t;
            if (processedSetOperations.has(so))
                return;
            processedSetOperations = processedSetOperations.add(so);
            if (combinationKind !== undefined) {
                attributes = TypeAttributes_1.combineTypeAttributes(combinationKind, attributes, t.getAttributes());
            }
            so.members.forEach(process);
        }
        else if (includeAny || t.kind !== "any") {
            members = members.add(t);
        }
        else {
            if (combinationKind !== undefined) {
                attributes = TypeAttributes_1.combineTypeAttributes(combinationKind, attributes, t.getAttributes());
            }
        }
    }
    for (var _i = 0, setOperations_1 = setOperations; _i < setOperations_1.length; _i++) {
        var so = setOperations_1[_i];
        process(so);
    }
    return [members, attributes];
}
exports.setOperationMembersRecursively = setOperationMembersRecursively;
function makeGroupsToFlatten(setOperations, include) {
    var typeGroups = immutable_1.Map();
    setOperations.forEach(function (u) {
        var members = setOperationMembersRecursively(u, undefined)[0].toSet();
        if (include !== undefined) {
            if (!include(members))
                return;
        }
        var maybeSet = typeGroups.get(members);
        if (maybeSet === undefined) {
            maybeSet = immutable_1.OrderedSet();
            if (members.size === 1) {
                maybeSet = maybeSet.add(Support_1.defined(members.first()));
            }
        }
        maybeSet = maybeSet.add(u);
        typeGroups = typeGroups.set(members, maybeSet);
    });
    return typeGroups
        .valueSeq()
        .toArray()
        .map(function (ts) { return ts.toArray(); });
}
exports.makeGroupsToFlatten = makeGroupsToFlatten;
function combineTypeAttributesOfTypes(combinationKind, types) {
    if (!Array.isArray(types)) {
        types = types.valueSeq().toArray();
    }
    return TypeAttributes_1.combineTypeAttributes(combinationKind, types.map(function (t) { return t.getAttributes(); }));
}
exports.combineTypeAttributesOfTypes = combineTypeAttributesOfTypes;
// FIXME: We shouldn't have to sort here.  This is just because we're not getting
// back the right order from JSON Schema, due to the changes the intersection types
// introduced.
function removeNullFromUnion(t, sortBy) {
    if (sortBy === void 0) { sortBy = false; }
    function sort(s) {
        if (sortBy === false)
            return s;
        if (sortBy === true)
            return s.sortBy(function (m) { return m.kind; });
        return s.sortBy(sortBy);
    }
    var nullType = t.findMember("null");
    if (nullType === undefined) {
        return [null, sort(t.members)];
    }
    return [nullType, sort(t.members.filterNot(function (m) { return m.kind === "null"; }))];
}
exports.removeNullFromUnion = removeNullFromUnion;
function removeNullFromType(t) {
    if (t.kind === "null") {
        return [t, immutable_1.OrderedSet()];
    }
    if (!(t instanceof Type_1.UnionType)) {
        return [null, immutable_1.OrderedSet([t])];
    }
    return removeNullFromUnion(t);
}
exports.removeNullFromType = removeNullFromType;
function nullableFromUnion(t) {
    var _a = removeNullFromUnion(t), hasNull = _a[0], nonNulls = _a[1];
    if (hasNull === null)
        return null;
    if (nonNulls.size !== 1)
        return null;
    return Support_1.defined(nonNulls.first());
}
exports.nullableFromUnion = nullableFromUnion;
function nonNullTypeCases(t) {
    return removeNullFromType(t)[1];
}
exports.nonNullTypeCases = nonNullTypeCases;
function getNullAsOptional(cp) {
    var _a = removeNullFromType(cp.type), maybeNull = _a[0], nonNulls = _a[1];
    if (cp.isOptional) {
        return [true, nonNulls];
    }
    return [maybeNull !== null, nonNulls];
}
exports.getNullAsOptional = getNullAsOptional;
// FIXME: Give this an appropriate name, considering that we don't distinguish
// between named and non-named types anymore.
function isNamedType(t) {
    return ["class", "union", "enum", "object"].indexOf(t.kind) >= 0;
}
exports.isNamedType = isNamedType;
function separateNamedTypes(types) {
    var objects = types.filter(function (t) { return t.kind === "object" || t.kind === "class"; }).toOrderedSet();
    var enums = types.filter(function (t) { return t instanceof Type_1.EnumType; }).toOrderedSet();
    var unions = types.filter(function (t) { return t instanceof Type_1.UnionType; }).toOrderedSet();
    return { objects: objects, enums: enums, unions: unions };
}
exports.separateNamedTypes = separateNamedTypes;
function orderedSetUnion(sets) {
    if (sets.length === 0)
        return immutable_1.OrderedSet();
    if (sets.length === 1)
        return sets[0];
    return (_a = sets[0]).union.apply(_a, sets.slice(1));
    var _a;
}
function directlyReachableTypes(t, setForType) {
    var set = setForType(t);
    if (set)
        return set;
    return orderedSetUnion(t
        .getNonAttributeChildren()
        .toArray()
        .map(function (c) { return directlyReachableTypes(c, setForType); }));
}
function directlyReachableSingleNamedType(type) {
    var definedTypes = directlyReachableTypes(type, function (t) {
        if ((!(t instanceof Type_1.UnionType) && isNamedType(t)) ||
            (t instanceof Type_1.UnionType && nullableFromUnion(t) === null)) {
            return immutable_1.OrderedSet([t]);
        }
        return null;
    });
    Support_1.assert(definedTypes.size <= 1, "Cannot have more than one defined type per top-level");
    return definedTypes.first();
}
exports.directlyReachableSingleNamedType = directlyReachableSingleNamedType;
function stringTypesForType(t) {
    Support_1.assert(t.kind === "string", "Only strings can have string types");
    var stringTypes = StringTypes_1.stringTypesTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    if (stringTypes === undefined) {
        return Support_1.panic("All strings must have a string type attribute");
    }
    return stringTypes;
}
exports.stringTypesForType = stringTypesForType;
function matchTypeExhaustive(t, noneType, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, objectType, enumType, unionType, dateType, timeType, dateTimeType) {
    if (t.isPrimitive()) {
        var f = {
            none: noneType,
            any: anyType,
            null: nullType,
            bool: boolType,
            integer: integerType,
            double: doubleType,
            string: stringType,
            date: dateType,
            time: timeType,
            "date-time": dateTimeType
        }[t.kind];
        if (f !== undefined)
            return f(t);
        return Support_1.assertNever(f);
    }
    else if (t instanceof Type_1.ArrayType)
        return arrayType(t);
    else if (t instanceof Type_1.ClassType)
        return classType(t);
    else if (t instanceof Type_1.MapType)
        return mapType(t);
    else if (t instanceof Type_1.ObjectType)
        return objectType(t);
    else if (t instanceof Type_1.EnumType)
        return enumType(t);
    else if (t instanceof Type_1.UnionType)
        return unionType(t);
    return Support_1.panic("Unknown type " + t.kind);
}
exports.matchTypeExhaustive = matchTypeExhaustive;
function matchType(type, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, enumType, unionType, stringTypeMatchers) {
    function typeNotSupported(t) {
        return Support_1.panic("Unsupported type " + t.kind + " in non-exhaustive match");
    }
    if (stringTypeMatchers === undefined) {
        stringTypeMatchers = {};
    }
    /* tslint:disable:strict-boolean-expressions */
    return matchTypeExhaustive(type, typeNotSupported, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, typeNotSupported, enumType, unionType, stringTypeMatchers.dateType || typeNotSupported, stringTypeMatchers.timeType || typeNotSupported, stringTypeMatchers.dateTimeType || typeNotSupported);
    /* tslint:enable */
}
exports.matchType = matchType;
function matchCompoundType(t, arrayType, classType, mapType, objectType, unionType) {
    function ignore(_) {
        return;
    }
    return matchTypeExhaustive(t, ignore, ignore, ignore, ignore, ignore, ignore, ignore, arrayType, classType, mapType, objectType, ignore, unionType, ignore, ignore, ignore);
}
exports.matchCompoundType = matchCompoundType;
