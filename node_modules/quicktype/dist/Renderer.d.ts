import { Map, Collection, OrderedSet, OrderedMap } from "immutable";
import { TypeGraph } from "./TypeGraph";
import { Name, Namespace } from "./Naming";
import { Source, Sourcelike } from "./Source";
import { AnnotationData } from "./Annotation";
import { StringMap } from "./Support";
import { TargetLanguage } from "./TargetLanguage";
export declare type RenderResult = {
    sources: OrderedMap<string, Source>;
    names: Map<Name, string>;
};
export declare type BlankLineLocations = "none" | "interposing" | "leading" | "leading-and-interposing";
export declare abstract class Renderer {
    protected readonly targetLanguage: TargetLanguage;
    protected readonly typeGraph: TypeGraph;
    protected readonly leadingComments: string[] | undefined;
    private _names;
    private _finishedFiles;
    private _lastNewline?;
    private _emitted;
    private _currentEmitTarget;
    private _needBlankLine;
    private _preventBlankLine;
    constructor(targetLanguage: TargetLanguage, typeGraph: TypeGraph, leadingComments: string[] | undefined);
    private startEmit();
    private pushItem(item);
    private emitNewline;
    private emitItem;
    protected ensureBlankLine(): void;
    protected preventBlankLine(): void;
    emitLine(...lineParts: Sourcelike[]): void;
    emitMultiline(linesString: string): void;
    emitAnnotated(annotation: AnnotationData, emitter: () => void): void;
    emitIssue(message: string, emitter: () => void): void;
    protected emitTable: (tableArray: Sourcelike[][]) => void;
    private changeIndent(offset);
    forEach<K, V>(iterable: Collection<K, V>, interposedBlankLines: boolean, leadingBlankLine: boolean, emitter: (v: V, k: K) => void): void;
    forEachWithBlankLines<K, V>(iterable: Collection<K, V>, blankLineLocations: BlankLineLocations, emitter: (v: V, k: K) => void): void;
    indent(fn: () => void): void;
    protected abstract setUpNaming(): OrderedSet<Namespace>;
    protected abstract emitSource(givenOutputFilename: string): void;
    protected abstract makeHandlebarsContext(): StringMap;
    private assignNames();
    protected finishFile(filename: string): void;
    render(givenOutputFilename: string): RenderResult;
    protected registerHandlebarsHelpers(_context: StringMap): void;
    processHandlebarsTemplate(template: string): string;
    readonly names: Map<Name, string>;
}
