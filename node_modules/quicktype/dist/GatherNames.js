"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var pluralize = require("pluralize");
var Type_1 = require("./Type");
var TypeUtils_1 = require("./TypeUtils");
var TypeNames_1 = require("./TypeNames");
var Support_1 = require("./Support");
var Transformers_1 = require("./Transformers");
// `gatherNames` infers names from given names and property names.
//
// 1. Propagate type and property names down to children.  Let's say
//    we start with JSON like this, and we name the top-level `TopLevel`:
//
//    {
//      "foos": [ [ { "bar": 123 } ] ]
//    }
//
//    We use a work-list algorithm to first add the name `TopLevel` to
//    the outermost class type.  Then we propagate the property name
//    `foos` to the outer array, which in turn propagates its singular
//    `foo` to the inner array type.  That tries to singularize `foo`,
//    but it's already singular, so `foo` is added as a name for the
//    inner class.  We also then add `bar` to the name of the integer
//    type.
//
// 2. Add "ancestor" alternatives and some "direct" alternatives.
//    Direct alternatives are those that don't contain any ancestor
//    names, whereas ancestor alternatives do. What we do here is add
//    names of the form `TopLevel_foo` and `TopLevel_foo_class` as
//    ancestor alternatives to the inner class, and `foo_element` as
//    a direct alternative, the latter because it's an element in an
//    array.
//
// 3. Add more direct alternatives to the type names.  The reason we're
//    doing this separately from step 2 is because step 2 only requires
//    iterating over the types, wheras this step iterates over
//    ancestor/descendant relationships.  In this case we would add
//    `TopLevel_class`, and `foo_class` to the outer and inner classes,
//    respectively.  We do similar stuff for all the other types.
//
// 4. For each type, set its inferred names to what we gathered in
//    step 1, and its alternatives to a union of its direct and ancestor
//    alternatives, gathered in steps 2 and 3.
function gatherNames(graph, debugPrint) {
    function setNames(t, tn) {
        graph.attributeStore.set(TypeNames_1.namesTypeAttributeKind, t, tn);
    }
    graph.allTypesUnordered().forEach(function (t) {
        if (t.hasNames) {
            setNames(t, t.getNames().clearInferred());
        }
    });
    var queue = immutable_1.OrderedSet();
    // null means there are too many
    var namesForType = immutable_1.Map();
    function addNames(t, names) {
        // Always use the type's given names if it has some
        if (t.hasNames) {
            var originalNames = t.getNames();
            if (!originalNames.areInferred) {
                names = originalNames.names;
            }
        }
        var oldNames = namesForType.get(t);
        if (oldNames === null)
            return;
        var newNames;
        if (oldNames === undefined) {
            newNames = names;
        }
        else if (names === null) {
            newNames = null;
        }
        else {
            newNames = oldNames.union(names);
        }
        if (newNames !== null && newNames.size >= TypeNames_1.tooManyNamesThreshold) {
            newNames = null;
        }
        namesForType = namesForType.set(t, newNames);
        var transformation = Transformers_1.transformationForType(t);
        if (transformation !== undefined) {
            addNames(transformation.targetType, names);
        }
        if (oldNames !== undefined && newNames !== null) {
            if (oldNames.size === newNames.size) {
                return;
            }
        }
        else if (oldNames === newNames) {
            return;
        }
        queue = queue.add(t);
    }
    graph.topLevels.forEach(function (t, name) {
        addNames(t, immutable_1.OrderedSet([name]));
    });
    var _loop_1 = function () {
        var t = Support_1.defined(queue.first());
        queue = queue.rest();
        var names = Support_1.defined(namesForType.get(t));
        if (t instanceof Type_1.ObjectType) {
            var properties = t.getProperties().sortBy(function (_, n) { return n; });
            properties.forEach(function (property, propertyName) {
                addNames(property.type, immutable_1.OrderedSet([propertyName]));
            });
            var values = t.getAdditionalProperties();
            if (values !== undefined) {
                addNames(values, names === null ? null : names.map(pluralize.singular));
            }
        }
        else {
            TypeUtils_1.matchCompoundType(t, function (arrayType) {
                addNames(arrayType.items, names === null ? null : names.map(pluralize.singular));
            }, function (_classType) { return Support_1.panic("We handled this above"); }, function (_mapType) { return Support_1.panic("We handled this above"); }, function (_objectType) { return Support_1.panic("We handled this above"); }, function (unionType) {
                var members = unionType.members.sortBy(function (member) { return member.kind; });
                members.forEach(function (memberType) {
                    addNames(memberType, names);
                });
            });
        }
    };
    while (!queue.isEmpty()) {
        _loop_1();
    }
    if (debugPrint) {
        graph.allTypesUnordered().forEach(function (t) {
            var names = namesForType.get(t);
            if (names === undefined)
                return;
            var index = t.typeRef.index;
            console.log(index + ": " + (names === null ? "*** too many ***" : names.join(" ")));
        });
    }
    // null means there are too many
    var directAlternativesForType = immutable_1.Map();
    var ancestorAlternativesForType = immutable_1.Map();
    var pairsProcessed = immutable_1.Map();
    function addAlternatives(existing, alternatives) {
        if (alternatives.length === 0) {
            return existing;
        }
        if (existing === undefined) {
            existing = immutable_1.OrderedSet();
        }
        existing = existing.union(immutable_1.OrderedSet(alternatives));
        if (existing.size < TypeNames_1.tooManyNamesThreshold) {
            return existing;
        }
        return null;
    }
    function processType(ancestor, t, alternativeSuffix) {
        var names = Support_1.defined(namesForType.get(t));
        var processedEntry = pairsProcessed.get(ancestor);
        if (processedEntry === undefined)
            processedEntry = immutable_1.Set();
        if (processedEntry.has(t))
            return;
        processedEntry = processedEntry.add(t);
        pairsProcessed = pairsProcessed.set(ancestor, processedEntry);
        var transformation = Transformers_1.transformationForType(t);
        if (transformation !== undefined) {
            processType(ancestor, transformation.targetType, alternativeSuffix);
        }
        var ancestorAlternatives = ancestorAlternativesForType.get(t);
        var directAlternatives = directAlternativesForType.get(t);
        if (names === null) {
            ancestorAlternatives = null;
            directAlternatives = null;
        }
        else {
            if (ancestor !== undefined && ancestorAlternatives !== null) {
                var ancestorNames_1 = namesForType.get(ancestor);
                if (ancestorNames_1 === null) {
                    ancestorAlternatives = null;
                }
                else if (ancestorNames_1 !== undefined) {
                    var alternatives_1 = [];
                    names.forEach(function (name) {
                        alternatives_1.push.apply(alternatives_1, ancestorNames_1.map(function (an) { return an + "_" + name; }).toArray());
                        // FIXME: add alternatives with the suffix here, too?
                        alternatives_1.push.apply(alternatives_1, ancestorNames_1.map(function (an) { return an + "_" + name + "_" + t.kind; }).toArray());
                        // FIXME: add alternatives with the suffix here, too?
                    });
                    ancestorAlternatives = addAlternatives(ancestorAlternatives, alternatives_1);
                }
            }
            if (alternativeSuffix !== undefined && directAlternatives !== null) {
                var alternatives_2 = [];
                names.forEach(function (name) {
                    // FIXME: we should only add these for names we couldn't singularize
                    alternatives_2.push(name + "_" + alternativeSuffix);
                });
                directAlternatives = addAlternatives(directAlternatives, alternatives_2);
            }
        }
        if (ancestorAlternatives !== undefined) {
            ancestorAlternativesForType = ancestorAlternativesForType.set(t, ancestorAlternatives);
        }
        if (directAlternatives !== undefined) {
            directAlternativesForType = directAlternativesForType.set(t, directAlternatives);
        }
        if (t instanceof Type_1.ObjectType) {
            var properties = t.getProperties().sortBy(function (_, n) { return n; });
            properties.forEach(function (property) { return processType(t, property.type, undefined); });
            var values = t.getAdditionalProperties();
            if (values !== undefined) {
                processType(properties.isEmpty() ? ancestor : t, values, "value");
            }
        }
        else {
            TypeUtils_1.matchCompoundType(t, function (arrayType) {
                processType(ancestor, arrayType.items, "element");
            }, function (_classType) { return Support_1.panic("We handled this above"); }, function (_mapType) { return Support_1.panic("We handled this above"); }, function (_objectType) { return Support_1.panic("We handled this above"); }, function (unionType) {
                var members = unionType.members.sortBy(function (member) { return member.kind; });
                var unionHasGivenName = unionType.hasNames && !unionType.getNames().areInferred;
                var unionIsAncestor = unionHasGivenName || TypeUtils_1.nullableFromUnion(unionType) === null;
                var ancestorForMembers = unionIsAncestor ? unionType : ancestor;
                members.forEach(function (memberType) { return processType(ancestorForMembers, memberType, undefined); });
            });
        }
    }
    graph.topLevels.forEach(function (t) {
        processType(undefined, t, undefined);
    });
    graph.allTypesUnordered().forEach(function (t) {
        var names = namesForType.get(t);
        if (names === undefined)
            return;
        if (names === null) {
            directAlternativesForType = directAlternativesForType.set(t, null);
            return;
        }
        var alternatives = directAlternativesForType.get(t);
        if (alternatives === null)
            return;
        if (alternatives === undefined) {
            alternatives = immutable_1.OrderedSet();
        }
        alternatives = alternatives.union(names.map(function (name) { return name + "_" + t.kind; }));
        directAlternativesForType = directAlternativesForType.set(t, alternatives);
    });
    graph.allTypesUnordered().forEach(function (t) {
        var names = namesForType.get(t);
        if (names === undefined)
            return;
        var typeNames;
        if (names === null) {
            typeNames = new TypeNames_1.TooManyTypeNames(true);
        }
        else {
            var ancestorAlternatives = ancestorAlternativesForType.get(t);
            var directAlternatives = directAlternativesForType.get(t);
            var alternatives = void 0;
            if (ancestorAlternatives === null && directAlternatives === null) {
                alternatives = undefined;
            }
            else {
                if (immutable_1.isCollection(directAlternatives)) {
                    alternatives = directAlternatives;
                }
                else {
                    alternatives = immutable_1.OrderedSet();
                }
                if (immutable_1.isCollection(ancestorAlternatives)) {
                    alternatives = alternatives.union(ancestorAlternatives);
                }
            }
            typeNames = TypeNames_1.TypeNames.make(names, alternatives, true);
        }
        setNames(t, t.hasNames ? t.getNames().add(typeNames) : typeNames);
    });
}
exports.gatherNames = gatherNames;
