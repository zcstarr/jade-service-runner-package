"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Support_1 = require("../Support");
var DateTime_1 = require("../DateTime");
var Combo = require("stream-json/Combo");
var Source = require("stream-json/Source");
var Tag;
(function (Tag) {
    Tag[Tag["Null"] = 0] = "Null";
    Tag[Tag["False"] = 1] = "False";
    Tag[Tag["True"] = 2] = "True";
    Tag[Tag["Integer"] = 3] = "Integer";
    Tag[Tag["Double"] = 4] = "Double";
    Tag[Tag["InternedString"] = 5] = "InternedString";
    Tag[Tag["UninternedString"] = 6] = "UninternedString";
    Tag[Tag["Object"] = 7] = "Object";
    Tag[Tag["Array"] = 8] = "Array";
    Tag[Tag["Date"] = 9] = "Date";
    Tag[Tag["Time"] = 10] = "Time";
    Tag[Tag["DateTime"] = 11] = "DateTime";
})(Tag = exports.Tag || (exports.Tag = {}));
var TAG_BITS = 4;
var TAG_MASK = (1 << TAG_BITS) - 1;
function makeValue(t, index) {
    return t | (index << TAG_BITS);
}
function getIndex(v, tag) {
    Support_1.assert(valueTag(v) === tag, "Trying to get index for value with invalid tag");
    return v >> TAG_BITS;
}
function valueTag(v) {
    return v & TAG_MASK;
}
exports.valueTag = valueTag;
var CompressedJSON = /** @class */ (function () {
    function CompressedJSON(_makeDate, _makeTime, _makeDateTime) {
        var _this = this;
        this._makeDate = _makeDate;
        this._makeTime = _makeTime;
        this._makeDateTime = _makeDateTime;
        this._contextStack = [];
        this._strings = [];
        this._stringValues = {};
        this._objects = [];
        this._arrays = [];
        this.getStringForValue = function (v) {
            return _this._strings[getIndex(v, Tag.InternedString)];
        };
        this.getObjectForValue = function (v) {
            return _this._objects[getIndex(v, Tag.Object)];
        };
        this.getArrayForValue = function (v) {
            return _this._arrays[getIndex(v, Tag.Array)];
        };
        this.internString = function (s) {
            if (Object.prototype.hasOwnProperty.call(_this._stringValues, s)) {
                return _this._stringValues[s];
            }
            var value = makeValue(Tag.InternedString, _this._strings.length);
            _this._strings.push(s);
            _this._stringValues[s] = value;
            Support_1.assert(typeof value === "number", "Interned string value is not a number: " + value);
            return value;
        };
        this.internObject = function (obj) {
            var index = _this._objects.length;
            _this._objects.push(obj);
            return makeValue(Tag.Object, index);
        };
        this.internArray = function (arr) {
            var index = _this._arrays.length;
            _this._arrays.push(arr);
            return makeValue(Tag.Array, index);
        };
        this.commitValue = function (value) {
            Support_1.assert(typeof value === "number", "CompressedJSON value is not a number: " + value);
            if (_this._ctx === undefined) {
                Support_1.assert(_this._rootValue === undefined, "Committing value but nowhere to commit to - root value still there.");
                _this._rootValue = value;
            }
            else if (_this._ctx.currentObject !== undefined) {
                if (_this._ctx.currentKey === undefined || _this._ctx.currentString !== undefined) {
                    return Support_1.panic("Must have key and can't have string when committing");
                }
                _this._ctx.currentObject.push(_this.internString(_this._ctx.currentKey), value);
                _this._ctx.currentKey = undefined;
            }
            else if (_this._ctx.currentArray !== undefined) {
                _this._ctx.currentArray.push(value);
            }
            else {
                return Support_1.panic("Committing value but nowhere to commit to");
            }
        };
        this.finish = function () {
            var value = _this._rootValue;
            if (value === undefined) {
                return Support_1.panic("Finished without root document");
            }
            Support_1.assert(_this._ctx === undefined && _this._contextStack.length === 0, "Finished with contexts present");
            _this._rootValue = undefined;
            return value;
        };
        this.pushContext = function () {
            if (_this._ctx !== undefined) {
                _this._contextStack.push(_this._ctx);
            }
            _this._ctx = {
                currentObject: undefined,
                currentArray: undefined,
                currentKey: undefined,
                currentString: undefined,
                currentNumberIsDouble: undefined
            };
        };
        this.popContext = function () {
            Support_1.assert(_this._ctx !== undefined, "Popping context when there isn't one");
            _this._ctx = _this._contextStack.pop();
        };
        this.handleStartObject = function () {
            _this.pushContext();
            Support_1.defined(_this._ctx).currentObject = [];
        };
        this.handleEndObject = function () {
            var obj = Support_1.defined(_this._ctx).currentObject;
            if (obj === undefined) {
                return Support_1.panic("Object ended but not started");
            }
            _this.popContext();
            _this.commitValue(_this.internObject(obj));
        };
        this.handleStartArray = function () {
            _this.pushContext();
            Support_1.defined(_this._ctx).currentArray = [];
        };
        this.handleEndArray = function () {
            var arr = Support_1.defined(_this._ctx).currentArray;
            if (arr === undefined) {
                return Support_1.panic("Array ended but not started");
            }
            _this.popContext();
            _this.commitValue(_this.internArray(arr));
        };
        this.handleStartKey = function () {
            Support_1.defined(_this._ctx).currentString = "";
        };
        this.handleEndKey = function () {
            var ctx = Support_1.defined(_this._ctx);
            var str = ctx.currentString;
            if (str === undefined) {
                return Support_1.panic("Key ended but no string");
            }
            ctx.currentKey = str;
            ctx.currentString = undefined;
        };
        this.handleStartString = function () {
            _this.pushContext();
            Support_1.defined(_this._ctx).currentString = "";
        };
        this.handleStringChunk = function (s) {
            var ctx = Support_1.defined(_this._ctx);
            if (ctx.currentString === undefined) {
                return Support_1.panic("String chunk but no string");
            }
            ctx.currentString += s;
        };
        this.handleEndString = function () {
            var str = Support_1.defined(_this._ctx).currentString;
            if (str === undefined) {
                return Support_1.panic("String ended but not started");
            }
            _this.popContext();
            var value = undefined;
            if (str.length <= 64) {
                if (str.length > 0 && "0123456789".indexOf(str[0]) >= 0) {
                    if (_this._makeDate && DateTime_1.isDate(str)) {
                        value = makeValue(Tag.Date, 0);
                    }
                    else if (_this._makeTime && DateTime_1.isTime(str)) {
                        value = makeValue(Tag.Time, 0);
                    }
                    else if (_this._makeDateTime && DateTime_1.isDateTime(str)) {
                        value = makeValue(Tag.DateTime, 0);
                    }
                }
                if (value === undefined) {
                    value = _this.internString(str);
                }
            }
            else {
                value = makeValue(Tag.UninternedString, 0);
            }
            _this.commitValue(value);
        };
        this.handleStartNumber = function () {
            _this.pushContext();
            Support_1.defined(_this._ctx).currentNumberIsDouble = false;
        };
        this.handleNumberChunk = function (s) {
            if (s.includes(".") || s.includes("e") || s.includes("E")) {
                Support_1.defined(_this._ctx).currentNumberIsDouble = true;
            }
        };
        this.handleEndNumber = function () {
            var isDouble = Support_1.defined(_this._ctx).currentNumberIsDouble;
            if (isDouble === undefined) {
                return Support_1.panic("Number ended but not started");
            }
            var numberTag = isDouble ? Tag.Double : Tag.Integer;
            _this.popContext();
            _this.commitValue(makeValue(numberTag, 0));
        };
        this.handleNullValue = function () {
            _this.commitValue(makeValue(Tag.Null, 0));
        };
        this.handleTrueValue = function () {
            _this.commitValue(makeValue(Tag.True, 0));
        };
        this.handleFalseValue = function () {
            _this.commitValue(makeValue(Tag.False, 0));
        };
        this.equals = function (other) {
            return _this === other;
        };
        this.hashCode = function () {
            var hashAccumulator = Support_1.hashCodeInit;
            for (var _i = 0, _a = _this._strings; _i < _a.length; _i++) {
                var s = _a[_i];
                hashAccumulator = Support_1.addHashCode(hashAccumulator, immutable_1.hash(s));
            }
            for (var _b = 0, _c = Object.getOwnPropertyNames(_this._stringValues).sort(); _b < _c.length; _b++) {
                var s = _c[_b];
                hashAccumulator = Support_1.addHashCode(hashAccumulator, immutable_1.hash(s));
                hashAccumulator = Support_1.addHashCode(hashAccumulator, _this._stringValues[s]);
            }
            for (var _d = 0, _e = _this._objects; _d < _e.length; _d++) {
                var o = _e[_d];
                for (var _f = 0, o_1 = o; _f < o_1.length; _f++) {
                    var v = o_1[_f];
                    hashAccumulator = Support_1.addHashCode(hashAccumulator, v);
                }
            }
            for (var _g = 0, _h = _this._arrays; _g < _h.length; _g++) {
                var o = _h[_g];
                for (var _j = 0, o_2 = o; _j < o_2.length; _j++) {
                    var v = o_2[_j];
                    hashAccumulator = Support_1.addHashCode(hashAccumulator, v);
                }
            }
            return hashAccumulator;
        };
    }
    CompressedJSON.prototype.readFromStream = function (readStream) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var combo, jsonSource, promise;
            return __generator(this, function (_a) {
                combo = new Combo();
                jsonSource = new Source([combo]);
                jsonSource.on("startObject", this.handleStartObject);
                jsonSource.on("endObject", this.handleEndObject);
                jsonSource.on("startArray", this.handleStartArray);
                jsonSource.on("endArray", this.handleEndArray);
                jsonSource.on("startKey", this.handleStartKey);
                jsonSource.on("endKey", this.handleEndKey);
                jsonSource.on("startString", this.handleStartString);
                jsonSource.on("stringChunk", this.handleStringChunk);
                jsonSource.on("endString", this.handleEndString);
                jsonSource.on("startNumber", this.handleStartNumber);
                jsonSource.on("numberChunk", this.handleNumberChunk);
                jsonSource.on("endNumber", this.handleEndNumber);
                jsonSource.on("nullValue", this.handleNullValue);
                jsonSource.on("trueValue", this.handleTrueValue);
                jsonSource.on("falseValue", this.handleFalseValue);
                promise = new Promise(function (resolve, reject) {
                    jsonSource.on("end", function () {
                        resolve(_this.finish());
                    });
                    combo.on("error", function (err) {
                        reject(err);
                    });
                });
                readStream.setEncoding("utf8");
                readStream.pipe(jsonSource.input);
                readStream.resume();
                return [2 /*return*/, promise];
            });
        });
    };
    return CompressedJSON;
}());
exports.CompressedJSON = CompressedJSON;
