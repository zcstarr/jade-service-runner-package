"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var CompressedJSON_1 = require("./CompressedJSON");
var Support_1 = require("../Support");
var UnionBuilder_1 = require("../UnionBuilder");
var DateTime_1 = require("../DateTime");
var Type_1 = require("../Type");
var TypeAttributes_1 = require("../TypeAttributes");
var StringTypes_1 = require("../StringTypes");
function forEachArrayInNestedValueArray(va, f) {
    if (va.length === 0) {
        return;
    }
    if (Array.isArray(va[0])) {
        for (var _i = 0, va_1 = va; _i < va_1.length; _i++) {
            var x = va_1[_i];
            forEachArrayInNestedValueArray(x, f);
        }
    }
    else {
        f(va);
    }
}
function forEachValueInNestedValueArray(va, f) {
    forEachArrayInNestedValueArray(va, function (a) { return a.forEach(f); });
}
var InferenceUnionBuilder = /** @class */ (function (_super) {
    __extends(InferenceUnionBuilder, _super);
    function InferenceUnionBuilder(typeBuilder, _typeInference, _cjson, _fixed) {
        var _this = _super.call(this, typeBuilder) || this;
        _this._typeInference = _typeInference;
        _this._cjson = _cjson;
        _this._fixed = _fixed;
        return _this;
    }
    InferenceUnionBuilder.prototype.makeObject = function (objects, typeAttributes, forwardingRef) {
        return this._typeInference.inferClassType(this._cjson, typeAttributes, objects, this._fixed, forwardingRef);
    };
    InferenceUnionBuilder.prototype.makeArray = function (arrays, _typeAttributes, forwardingRef) {
        return this.typeBuilder.getArrayType(this._typeInference.inferType(this._cjson, immutable_1.Map(), arrays, this._fixed, forwardingRef));
    };
    return InferenceUnionBuilder;
}(UnionBuilder_1.UnionBuilder));
function canBeEnumCase(s) {
    if (s.length === 0)
        return true; // FIXME: Do we really want this?
    return !DateTime_1.isDate(s) && !DateTime_1.isTime(s) && !DateTime_1.isDateTime(s);
}
var TypeInference = /** @class */ (function () {
    function TypeInference(_typeBuilder, _inferEnums, _inferDates) {
        this._typeBuilder = _typeBuilder;
        this._inferEnums = _inferEnums;
        this._inferDates = _inferDates;
    }
    TypeInference.prototype.inferType = function (cjson, typeAttributes, valueArray, fixed, forwardingRef) {
        var _this = this;
        var accumulator = new UnionBuilder_1.UnionAccumulator(true);
        forEachValueInNestedValueArray(valueArray, function (value) {
            var t = CompressedJSON_1.valueTag(value);
            switch (t) {
                case CompressedJSON_1.Tag.Null:
                    accumulator.addNull(TypeAttributes_1.emptyTypeAttributes);
                    break;
                case CompressedJSON_1.Tag.False:
                case CompressedJSON_1.Tag.True:
                    accumulator.addBool(TypeAttributes_1.emptyTypeAttributes);
                    break;
                case CompressedJSON_1.Tag.Integer:
                    accumulator.addInteger(TypeAttributes_1.emptyTypeAttributes);
                    break;
                case CompressedJSON_1.Tag.Double:
                    accumulator.addDouble(TypeAttributes_1.emptyTypeAttributes);
                    break;
                case CompressedJSON_1.Tag.InternedString:
                    if (_this._inferEnums) {
                        var s = cjson.getStringForValue(value);
                        if (canBeEnumCase(s)) {
                            accumulator.addStringCase(s, 1, TypeAttributes_1.emptyTypeAttributes);
                        }
                        else {
                            accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
                        }
                    }
                    else {
                        accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
                    }
                    break;
                case CompressedJSON_1.Tag.UninternedString:
                    accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
                    break;
                case CompressedJSON_1.Tag.Object:
                    accumulator.addObject(cjson.getObjectForValue(value), TypeAttributes_1.emptyTypeAttributes);
                    break;
                case CompressedJSON_1.Tag.Array:
                    accumulator.addArray(cjson.getArrayForValue(value), TypeAttributes_1.emptyTypeAttributes);
                    break;
                case CompressedJSON_1.Tag.Date:
                    accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes, _this._inferDates ? StringTypes_1.StringTypes.date : StringTypes_1.StringTypes.unrestricted);
                    break;
                case CompressedJSON_1.Tag.Time:
                    accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes, _this._inferDates ? StringTypes_1.StringTypes.time : StringTypes_1.StringTypes.unrestricted);
                    break;
                case CompressedJSON_1.Tag.DateTime:
                    accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes, _this._inferDates ? StringTypes_1.StringTypes.dateTime : StringTypes_1.StringTypes.unrestricted);
                    break;
                default:
                    return Support_1.assertNever(t);
            }
        });
        var unionBuilder = new InferenceUnionBuilder(this._typeBuilder, this, cjson, fixed);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
    };
    TypeInference.prototype.inferClassType = function (cjson, typeAttributes, objects, fixed, forwardingRef) {
        var propertyNames = [];
        var propertyValues = {};
        forEachArrayInNestedValueArray(objects, function (arr) {
            for (var i = 0; i < arr.length; i += 2) {
                var key = cjson.getStringForValue(arr[i]);
                var value = arr[i + 1];
                if (!Object.prototype.hasOwnProperty.call(propertyValues, key)) {
                    propertyNames.push(key);
                    propertyValues[key] = [];
                }
                propertyValues[key].push(value);
            }
        });
        var properties = [];
        for (var _i = 0, propertyNames_1 = propertyNames; _i < propertyNames_1.length; _i++) {
            var key = propertyNames_1[_i];
            var values = propertyValues[key];
            var t = this.inferType(cjson, immutable_1.Map(), values, false);
            var isOptional = values.length < objects.length;
            properties.push([key, new Type_1.ClassProperty(t, isOptional)]);
        }
        var propertyMap = immutable_1.OrderedMap(properties);
        if (fixed) {
            return this._typeBuilder.getUniqueClassType(typeAttributes, true, propertyMap, forwardingRef);
        }
        else {
            return this._typeBuilder.getClassType(typeAttributes, propertyMap, forwardingRef);
        }
    };
    return TypeInference;
}());
exports.TypeInference = TypeInference;
