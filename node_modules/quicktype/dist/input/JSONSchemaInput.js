"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var pluralize = require("pluralize");
var URI = require("urijs");
var lodash = require("lodash");
var Type_1 = require("../Type");
var Support_1 = require("../Support");
var TypeNames_1 = require("../TypeNames");
var TypeNames_2 = require("../TypeNames");
var TypeAttributes_1 = require("../TypeAttributes");
var AccessorNames_1 = require("../AccessorNames");
var Messages_1 = require("../Messages");
var StringTypes_1 = require("../StringTypes");
var PathElementKind;
(function (PathElementKind) {
    PathElementKind[PathElementKind["Root"] = 0] = "Root";
    PathElementKind[PathElementKind["KeyOrIndex"] = 1] = "KeyOrIndex";
    PathElementKind[PathElementKind["Type"] = 2] = "Type";
    PathElementKind[PathElementKind["Object"] = 3] = "Object";
})(PathElementKind = exports.PathElementKind || (exports.PathElementKind = {}));
function keyOrIndex(pe) {
    if (pe.kind !== PathElementKind.KeyOrIndex)
        return undefined;
    return pe.key;
}
function pathElementEquals(a, b) {
    if (a.kind !== b.kind)
        return false;
    switch (a.kind) {
        case PathElementKind.Type:
            return a.index === b.index;
        case PathElementKind.KeyOrIndex:
            return a.key === b.key;
        default:
            return true;
    }
}
function withRef(refOrLoc, props) {
    var ref = typeof refOrLoc === "function" ? refOrLoc() : refOrLoc instanceof Ref ? refOrLoc : refOrLoc.canonicalRef;
    return Object.assign({ ref: ref }, props === undefined ? {} : props);
}
function checkJSONSchemaObject(x, refOrLoc) {
    if (Array.isArray(x)) {
        return Messages_1.messageError("SchemaArrayIsInvalidSchema", withRef(refOrLoc));
    }
    if (x === null) {
        return Messages_1.messageError("SchemaNullIsInvalidSchema", withRef(refOrLoc));
    }
    if (typeof x !== "object") {
        return Messages_1.messageError("SchemaInvalidJSONSchemaType", withRef(refOrLoc, { type: typeof x }));
    }
    return x;
}
exports.checkJSONSchemaObject = checkJSONSchemaObject;
function checkJSONSchema(x, refOrLoc) {
    if (typeof x === "boolean")
        return x;
    return checkJSONSchemaObject(x, refOrLoc);
}
exports.checkJSONSchema = checkJSONSchema;
var numberRegexp = new RegExp("^[0-9]+$");
var Ref = /** @class */ (function () {
    function Ref(addressURI, path) {
        this.path = path;
        if (addressURI !== undefined) {
            Support_1.assert(addressURI.fragment() === "", "Ref URI with fragment is not allowed: " + addressURI.toString());
            this.addressURI = addressURI.clone().normalize();
        }
        else {
            this.addressURI = undefined;
        }
    }
    Ref.root = function (address) {
        var uri = new URI(address);
        return new Ref(uri, immutable_1.List());
    };
    Ref.parsePath = function (path) {
        var elements = [];
        if (path.startsWith("/")) {
            elements.push({ kind: PathElementKind.Root });
            path = path.substr(1);
        }
        if (path !== "") {
            var parts = path.split("/");
            for (var i = 0; i < parts.length; i++) {
                elements.push({ kind: PathElementKind.KeyOrIndex, key: parts[i] });
            }
        }
        return immutable_1.List(elements);
    };
    Ref.parseURI = function (uri, destroyURI) {
        if (destroyURI === void 0) { destroyURI = false; }
        if (!destroyURI) {
            uri = uri.clone();
        }
        var path = uri.fragment();
        uri.fragment("");
        if ((uri.host() !== "" || uri.filename() !== "") && path === "") {
            path = "/";
        }
        var elements = Ref.parsePath(path);
        return new Ref(uri, elements);
    };
    Ref.parse = function (ref) {
        return Ref.parseURI(new URI(ref), true);
    };
    Object.defineProperty(Ref.prototype, "hasAddress", {
        get: function () {
            return this.addressURI !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Ref.prototype, "address", {
        get: function () {
            return Support_1.defined(this.addressURI).toString();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Ref.prototype, "isRoot", {
        get: function () {
            return this.path.size === 1 && Support_1.defined(this.path.first()).kind === PathElementKind.Root;
        },
        enumerable: true,
        configurable: true
    });
    Ref.prototype.pushElement = function (pe) {
        return new Ref(this.addressURI, this.path.push(pe));
    };
    Ref.prototype.push = function () {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        var ref = this;
        for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
            var key = keys_1[_a];
            ref = ref.pushElement({ kind: PathElementKind.KeyOrIndex, key: key });
        }
        return ref;
    };
    Ref.prototype.pushObject = function () {
        return this.pushElement({ kind: PathElementKind.Object });
    };
    Ref.prototype.pushType = function (index) {
        return this.pushElement({ kind: PathElementKind.Type, index: index });
    };
    Ref.prototype.resolveAgainst = function (base) {
        var addressURI = this.addressURI;
        if (base !== undefined && base.addressURI !== undefined) {
            addressURI = addressURI === undefined ? base.addressURI : addressURI.absoluteTo(base.addressURI);
        }
        return new Ref(addressURI, this.path);
    };
    Object.defineProperty(Ref.prototype, "name", {
        get: function () {
            var path = this.path;
            for (;;) {
                var e = path.last();
                if (e === undefined || e.kind === PathElementKind.Root) {
                    var name = this.addressURI !== undefined ? this.addressURI.filename() : "";
                    var suffix = this.addressURI !== undefined ? this.addressURI.suffix() : "";
                    if (name.length > suffix.length + 1) {
                        name = name.substr(0, name.length - suffix.length - 1);
                    }
                    if (name === "") {
                        return "Something";
                    }
                    return name;
                }
                switch (e.kind) {
                    case PathElementKind.KeyOrIndex:
                        if (numberRegexp.test(e.key)) {
                            return e.key;
                        }
                        break;
                    case PathElementKind.Type:
                    case PathElementKind.Object:
                        return Support_1.panic("We shouldn't try to get the name of Type or Object refs");
                    default:
                        return Support_1.assertNever(e);
                }
                path = path.pop();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Ref.prototype, "definitionName", {
        get: function () {
            var pe = this.path.get(-2);
            if (pe === undefined)
                return undefined;
            if (keyOrIndex(pe) === "definitions")
                return keyOrIndex(Support_1.defined(this.path.last()));
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Ref.prototype.toString = function () {
        function elementToString(e) {
            switch (e.kind) {
                case PathElementKind.Root:
                    return "";
                case PathElementKind.Type:
                    return "type/" + e.index.toString();
                case PathElementKind.Object:
                    return "object";
                case PathElementKind.KeyOrIndex:
                    return e.key;
                default:
                    return Support_1.assertNever(e);
            }
        }
        var address = this.addressURI === undefined ? "" : this.addressURI.toString();
        return address + "#" + this.path.map(elementToString).join("/");
    };
    Ref.prototype.lookup = function (local, path, root) {
        var _this = this;
        var refMaker = function () { return new Ref(_this.addressURI, path); };
        var first = path.first();
        if (first === undefined) {
            return checkJSONSchema(local, refMaker);
        }
        var rest = path.rest();
        switch (first.kind) {
            case PathElementKind.Root:
                return this.lookup(root, rest, root);
            case PathElementKind.KeyOrIndex:
                var key = first.key;
                if (Array.isArray(local)) {
                    if (!/^\d+$/.test(key)) {
                        return Messages_1.messageError("SchemaCannotIndexArrayWithNonNumber", withRef(refMaker, { actual: key }));
                    }
                    var index = parseInt(first.key, 10);
                    if (index >= local.length) {
                        return Messages_1.messageError("SchemaIndexNotInArray", withRef(refMaker, { index: index }));
                    }
                    return this.lookup(local[index], rest, root);
                }
                else {
                    if (!lodash.has(local, [key])) {
                        return Messages_1.messageError("SchemaKeyNotInObject", withRef(refMaker, { key: key }));
                    }
                    return this.lookup(checkJSONSchemaObject(local, refMaker)[first.key], rest, root);
                }
            case PathElementKind.Type:
                return Support_1.panic('Cannot look up path that indexes "type"');
            case PathElementKind.Object:
                return Support_1.panic('Cannot look up path that indexes "object"');
            default:
                return Support_1.assertNever(first);
        }
    };
    Ref.prototype.lookupRef = function (root) {
        return this.lookup(root, this.path, root);
    };
    Ref.prototype.equals = function (other) {
        if (!(other instanceof Ref))
            return false;
        if (this.addressURI !== undefined && other.addressURI !== undefined) {
            if (!this.addressURI.equals(other.addressURI))
                return false;
        }
        else {
            if ((this.addressURI === undefined) !== (other.addressURI === undefined))
                return false;
        }
        if (this.path.size !== other.path.size)
            return false;
        return this.path.zipWith(pathElementEquals, other.path).every(function (x) { return x; });
    };
    Ref.prototype.hashCode = function () {
        var acc = immutable_1.hash(Support_1.mapOptional(function (u) { return u.toString(); }, this.addressURI));
        this.path.forEach(function (pe) {
            acc = Support_1.addHashCode(acc, pe.kind);
            switch (pe.kind) {
                case PathElementKind.Type:
                    acc = Support_1.addHashCode(acc, pe.index);
                    break;
                case PathElementKind.KeyOrIndex:
                    acc = Support_1.addHashCode(acc, immutable_1.hash(pe.key));
                    break;
                default:
                    break;
            }
        });
        return acc;
    };
    return Ref;
}());
exports.Ref = Ref;
var Location = /** @class */ (function () {
    function Location(canonicalRef, virtualRef) {
        this.canonicalRef = canonicalRef;
        this.virtualRef = virtualRef !== undefined ? virtualRef : canonicalRef;
    }
    Location.prototype.updateWithID = function (id) {
        if (typeof id !== "string")
            return this;
        // FIXME: This is incorrect.  If the parsed ref doesn't have an address, the
        // current virtual one's must be used.  The canonizer must do this, too.
        return new Location(this.canonicalRef, Ref.parse(id).resolveAgainst(this.virtualRef));
    };
    Location.prototype.push = function () {
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        return new Location((_a = this.canonicalRef).push.apply(_a, keys), (_b = this.virtualRef).push.apply(_b, keys));
        var _a, _b;
    };
    Location.prototype.pushObject = function () {
        return new Location(this.canonicalRef.pushObject(), this.virtualRef.pushObject());
    };
    Location.prototype.pushType = function (index) {
        return new Location(this.canonicalRef.pushType(index), this.virtualRef.pushType(index));
    };
    Location.prototype.toString = function () {
        return this.virtualRef.toString() + " (" + this.canonicalRef.toString() + ")";
    };
    return Location;
}());
var Canonizer = /** @class */ (function () {
    function Canonizer() {
        this._map = immutable_1.Map();
        this._schemaAddressesAdded = immutable_1.Set();
    }
    Canonizer.prototype.addID = function (mapped, loc) {
        var ref = Ref.parse(mapped).resolveAgainst(loc.virtualRef);
        Messages_1.messageAssert(ref.hasAddress, "SchemaIDMustHaveAddress", withRef(loc, { id: mapped }));
        this._map = this._map.set(ref, loc.canonicalRef);
    };
    Canonizer.prototype.addIDs = function (schema, loc) {
        if (schema === null)
            return;
        if (Array.isArray(schema)) {
            for (var i = 0; i < schema.length; i++) {
                this.addIDs(schema[i], loc.push(i.toString()));
            }
            return;
        }
        if (typeof schema !== "object") {
            return;
        }
        var maybeID = schema["$id"];
        if (typeof maybeID === "string") {
            this.addID(maybeID, loc);
            loc = loc.updateWithID(maybeID);
        }
        for (var _i = 0, _a = Object.getOwnPropertyNames(schema); _i < _a.length; _i++) {
            var property = _a[_i];
            this.addIDs(schema[property], loc.push(property));
        }
    };
    Canonizer.prototype.addSchema = function (schema, address) {
        if (this._schemaAddressesAdded.has(address))
            return;
        this.addIDs(schema, new Location(Ref.root(address)));
        this._schemaAddressesAdded = this._schemaAddressesAdded.add(address);
    };
    // Returns: Canonical ref, full virtual ref
    Canonizer.prototype.canonize = function (virtualBase, ref) {
        var fullVirtual = ref.resolveAgainst(virtualBase);
        var virtual = fullVirtual;
        var relative = immutable_1.List();
        for (;;) {
            var maybeCanonical = this._map.get(virtual);
            if (maybeCanonical !== undefined) {
                return [new Ref(maybeCanonical.addressURI, maybeCanonical.path.concat(relative)), fullVirtual];
            }
            var last = virtual.path.last();
            if (last === undefined) {
                // We've exhausted our options - it's not a mapped ref.
                return [fullVirtual, fullVirtual];
            }
            if (last.kind !== PathElementKind.Root) {
                relative = relative.unshift(last);
            }
            virtual = new Ref(virtual.addressURI, virtual.path.pop());
        }
    };
    return Canonizer;
}());
function makeAttributes(schema, loc, attributes) {
    var maybeDescription = schema.description;
    if (typeof maybeDescription === "string") {
        attributes = TypeAttributes_1.descriptionTypeAttributeKind.combineInAttributes(attributes, immutable_1.OrderedSet([maybeDescription]));
    }
    return TypeNames_2.modifyTypeNames(attributes, function (maybeTypeNames) {
        var typeNames = Support_1.defined(maybeTypeNames);
        if (!typeNames.areInferred) {
            return typeNames;
        }
        var title = schema.title;
        if (typeof title !== "string") {
            title = loc.canonicalRef.definitionName;
        }
        if (typeof title === "string") {
            return TypeNames_1.TypeNames.make(immutable_1.OrderedSet([title]), immutable_1.OrderedSet(), schema.$ref !== undefined);
        }
        else {
            return typeNames.makeInferred();
        }
    });
}
function isAccessorEntry(x) {
    if (typeof x === "string") {
        return true;
    }
    return Support_1.isStringMap(x, function (v) { return typeof v === "string"; });
}
function makeAccessorEntry(ae) {
    if (typeof ae === "string")
        return ae;
    return immutable_1.Map(ae);
}
function makeAccessorNames(x) {
    // FIXME: Do proper error reporting
    var stringMap = Support_1.checkStringMap(x, isAccessorEntry);
    return immutable_1.Map(stringMap).map(makeAccessorEntry);
}
function makeNonUnionAccessorAttributes(schema) {
    var maybeAccessors = schema["qt-accessors"];
    if (maybeAccessors === undefined)
        return undefined;
    return AccessorNames_1.accessorNamesTypeAttributeKind.makeAttributes(makeAccessorNames(maybeAccessors));
}
function checkTypeList(typeOrTypes, loc) {
    var set;
    if (typeof typeOrTypes === "string") {
        set = immutable_1.OrderedSet([typeOrTypes]);
    }
    else if (Array.isArray(typeOrTypes)) {
        var arr = [];
        for (var _i = 0, typeOrTypes_1 = typeOrTypes; _i < typeOrTypes_1.length; _i++) {
            var t = typeOrTypes_1[_i];
            if (typeof t !== "string") {
                return Messages_1.messageError("SchemaTypeElementMustBeString", withRef(loc, { element: t }));
            }
            arr.push(t);
        }
        set = immutable_1.OrderedSet(arr);
    }
    else {
        return Messages_1.messageError("SchemaTypeMustBeStringOrStringArray", withRef(loc, { actual: typeOrTypes }));
    }
    Messages_1.messageAssert(!set.isEmpty(), "SchemaNoTypeSpecified", withRef(loc));
    var validTypes = ["null", "boolean", "object", "array", "number", "string", "integer"];
    var maybeInvalid = set.find(function (s) { return validTypes.indexOf(s) < 0; });
    if (maybeInvalid !== undefined) {
        return Messages_1.messageError("SchemaInvalidType", withRef(loc, { type: maybeInvalid }));
    }
    return set;
}
function checkRequiredArray(arr, loc) {
    if (!Array.isArray(arr)) {
        return Messages_1.messageError("SchemaRequiredMustBeStringOrStringArray", withRef(loc, { actual: arr }));
    }
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var e = arr_1[_i];
        if (typeof e !== "string") {
            return Messages_1.messageError("SchemaRequiredElementMustBeString", withRef(loc, { element: e }));
        }
    }
    return arr;
}
function getFromStore(store, address, ref) {
    return __awaiter(this, void 0, void 0, function () {
        var error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, store.get(address)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    error_1 = _a.sent();
                    if (ref === undefined) {
                        return [2 /*return*/, Messages_1.messageError("SchemaFetchErrorTopLevel", { address: address, error: error_1 })];
                    }
                    else {
                        return [2 /*return*/, Messages_1.messageError("SchemaFetchError", { address: address, ref: ref, error: error_1 })];
                    }
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function addTypesInSchema(typeBuilder, store, references) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        function resolveVirtualRef(base, virtualRef) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, canonical, fullVirtual, schema;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _a = canonizer.canonize(Support_1.mapOptional(function (b) { return b.virtualRef; }, base), virtualRef), canonical = _a[0], fullVirtual = _a[1];
                            Support_1.assert(canonical.hasAddress, "Canonical ref can't be resolved without an address");
                            return [4 /*yield*/, getFromStore(store, canonical.address, Support_1.mapOptional(function (l) { return l.canonicalRef; }, base))];
                        case 1:
                            schema = _b.sent();
                            canonizer.addSchema(schema, canonical.address);
                            return [2 /*return*/, [canonical.lookupRef(schema), new Location(canonical, fullVirtual)]];
                    }
                });
            });
        }
        function setTypeForLocation(loc, t) {
            return __awaiter(this, void 0, void 0, function () {
                var maybeRef;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, typeForCanonicalRef.get(loc.canonicalRef)];
                        case 1:
                            maybeRef = _a.sent();
                            if (maybeRef !== undefined) {
                                Support_1.assert(maybeRef === t, "Trying to set path again to different type");
                            }
                            typeForCanonicalRef = typeForCanonicalRef.set(loc.canonicalRef, t);
                            return [2 /*return*/];
                    }
                });
            });
        }
        function makeObject(loc, attributes, properties, requiredArray, additionalProperties) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                var required, propertiesMap, propertyDescriptions, props, additionalPropertiesType, additionalLoc, additionalRequired, t_1, additionalProps;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            required = immutable_1.OrderedSet(requiredArray);
                            propertiesMap = immutable_1.OrderedMap(properties).sortBy(function (_, k) { return k.toLowerCase(); });
                            propertyDescriptions = propertiesMap
                                .map(function (propSchema) {
                                if (typeof propSchema === "object") {
                                    var desc = propSchema.description;
                                    if (typeof desc === "string") {
                                        return immutable_1.OrderedSet([desc]);
                                    }
                                }
                                return undefined;
                            })
                                .filter(function (v) { return v !== undefined; });
                            if (!propertyDescriptions.isEmpty()) {
                                attributes = TypeAttributes_1.propertyDescriptionsTypeAttributeKind.combineInAttributes(attributes, propertyDescriptions);
                            }
                            return [4 /*yield*/, Support_1.mapSync(propertiesMap, function (propSchema, propName) { return __awaiter(_this, void 0, void 0, function () {
                                    var propLoc, t, isOptional;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                propLoc = loc.push("properties", propName);
                                                return [4 /*yield*/, toType(checkJSONSchema(propSchema, propLoc.canonicalRef), propLoc, TypeNames_2.makeNamesTypeAttributes(pluralize.singular(propName), true))];
                                            case 1:
                                                t = _a.sent();
                                                isOptional = !required.has(propName);
                                                return [2 /*return*/, new Type_1.ClassProperty(t, isOptional)];
                                        }
                                    });
                                }); })];
                        case 1:
                            props = (_a.sent()).toOrderedMap();
                            if (!(additionalProperties === undefined || additionalProperties === true)) return [3 /*break*/, 2];
                            additionalPropertiesType = typeBuilder.getPrimitiveType("any");
                            return [3 /*break*/, 5];
                        case 2:
                            if (!(additionalProperties === false)) return [3 /*break*/, 3];
                            additionalPropertiesType = undefined;
                            return [3 /*break*/, 5];
                        case 3:
                            additionalLoc = loc.push("additionalProperties");
                            return [4 /*yield*/, toType(checkJSONSchema(additionalProperties, additionalLoc.canonicalRef), additionalLoc, TypeNames_2.singularizeTypeNames(attributes))];
                        case 4:
                            additionalPropertiesType = _a.sent();
                            _a.label = 5;
                        case 5:
                            additionalRequired = required.subtract(props.keySeq());
                            if (!additionalRequired.isEmpty()) {
                                t_1 = additionalPropertiesType;
                                if (t_1 === undefined) {
                                    return [2 /*return*/, Messages_1.messageError("SchemaAdditionalTypesForbidRequired", withRef(loc))];
                                }
                                additionalProps = additionalRequired.toOrderedMap().map(function (_name) { return new Type_1.ClassProperty(t_1, false); });
                                props = props.merge(additionalProps);
                            }
                            return [2 /*return*/, typeBuilder.getUniqueObjectType(attributes, props, additionalPropertiesType)];
                    }
                });
            });
        }
        function convertToType(schema, loc, typeAttributes) {
            return __awaiter(this, void 0, void 0, function () {
                function makeStringType() {
                    switch (schema.format) {
                        case "date":
                            return typeBuilder.getPrimitiveType("date", inferredAttributes);
                        case "time":
                            return typeBuilder.getPrimitiveType("time", inferredAttributes);
                        case "date-time":
                            return typeBuilder.getPrimitiveType("date-time", inferredAttributes);
                        default:
                            break;
                    }
                    return typeBuilder.getStringType(inferredAttributes, StringTypes_1.StringTypes.unrestricted);
                }
                function makeArrayType() {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var singularAttributes, items, itemType, itemsLoc_1, itemTypes, itemsLoc;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    singularAttributes = TypeNames_2.singularizeTypeNames(typeAttributes);
                                    items = schema.items;
                                    if (!Array.isArray(items)) return [3 /*break*/, 2];
                                    itemsLoc_1 = loc.push("items");
                                    return [4 /*yield*/, Support_1.mapSync(items, function (item, i) { return __awaiter(_this, void 0, void 0, function () {
                                            var itemLoc;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        itemLoc = itemsLoc_1.push(i.toString());
                                                        return [4 /*yield*/, toType(checkJSONSchema(item, itemLoc.canonicalRef), itemLoc, singularAttributes)];
                                                    case 1: return [2 /*return*/, _a.sent()];
                                                }
                                            });
                                        }); })];
                                case 1:
                                    itemTypes = _a.sent();
                                    itemType = typeBuilder.getUnionType(TypeAttributes_1.emptyTypeAttributes, immutable_1.OrderedSet(itemTypes));
                                    return [3 /*break*/, 5];
                                case 2:
                                    if (!(typeof items === "object")) return [3 /*break*/, 4];
                                    itemsLoc = loc.push("items");
                                    return [4 /*yield*/, toType(checkJSONSchema(items, itemsLoc.canonicalRef), itemsLoc, singularAttributes)];
                                case 3:
                                    itemType = _a.sent();
                                    return [3 /*break*/, 5];
                                case 4:
                                    if (items !== undefined) {
                                        return [2 /*return*/, Messages_1.messageError("SchemaArrayItemsMustBeStringOrArray", withRef(loc, { actual: items }))];
                                    }
                                    else {
                                        itemType = typeBuilder.getPrimitiveType("any");
                                    }
                                    _a.label = 5;
                                case 5:
                                    typeBuilder.addAttributes(itemType, singularAttributes);
                                    return [2 /*return*/, typeBuilder.getArrayType(itemType)];
                            }
                        });
                    });
                }
                function makeObjectType() {
                    return __awaiter(this, void 0, void 0, function () {
                        var required, properties, additionalProperties;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (schema.required === undefined) {
                                        required = [];
                                    }
                                    else {
                                        required = checkRequiredArray(schema.required, loc);
                                    }
                                    if (schema.properties === undefined) {
                                        properties = {};
                                    }
                                    else {
                                        properties = checkJSONSchemaObject(schema.properties, loc.canonicalRef);
                                    }
                                    additionalProperties = schema.additionalProperties;
                                    return [4 /*yield*/, makeObject(loc, inferredAttributes, properties, required, additionalProperties)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                }
                function makeTypesFromCases(cases, kind) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var kindLoc;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    kindLoc = loc.push(kind);
                                    if (!Array.isArray(cases)) {
                                        return [2 /*return*/, Messages_1.messageError("SchemaSetOperationCasesIsNotArray", withRef(kindLoc, { operation: kind, cases: cases }))];
                                    }
                                    return [4 /*yield*/, Support_1.mapSync(cases, function (t, index) { return __awaiter(_this, void 0, void 0, function () {
                                            var caseLoc;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        caseLoc = kindLoc.push(index.toString());
                                                        return [4 /*yield*/, toType(checkJSONSchema(t, caseLoc.canonicalRef), caseLoc, TypeAttributes_1.makeTypeAttributesInferred(typeAttributes))];
                                                    case 1: return [2 /*return*/, _a.sent()];
                                                }
                                            });
                                        }); })];
                                case 1: 
                                // FIXME: This cast shouldn't be necessary, but TypeScript forces our hand.
                                return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                }
                function convertOneOrAnyOf(cases, kind) {
                    return __awaiter(this, void 0, void 0, function () {
                        var maybeAccessors, unionType, typeRefs, identifierAttribute, accessors, i;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    maybeAccessors = schema["qt-accessors"];
                                    unionType = typeBuilder.getUniqueUnionType(TypeAttributes_1.makeTypeAttributesInferred(typeAttributes), undefined);
                                    return [4 /*yield*/, makeTypesFromCases(cases, kind)];
                                case 1:
                                    typeRefs = _a.sent();
                                    if (maybeAccessors !== undefined) {
                                        identifierAttribute = AccessorNames_1.makeUnionIdentifierAttribute();
                                        typeBuilder.addAttributes(unionType, identifierAttribute);
                                        accessors = Support_1.checkArray(maybeAccessors, isAccessorEntry);
                                        Messages_1.messageAssert(typeRefs.length === accessors.length, "SchemaWrongAccessorEntryArrayLength", withRef(function () { return loc.canonicalRef.push(kind); }, { operation: kind }));
                                        for (i = 0; i < typeRefs.length; i++) {
                                            typeBuilder.addAttributes(typeRefs[i], AccessorNames_1.makeUnionMemberNamesAttribute(identifierAttribute, makeAccessorEntry(accessors[i])));
                                        }
                                    }
                                    typeBuilder.setSetOperationMembers(unionType, immutable_1.OrderedSet(typeRefs));
                                    return [2 /*return*/, unionType];
                            }
                        });
                    });
                }
                function includePrimitiveType(name) {
                    if (typeSet !== undefined && !typeSet.has(name)) {
                        return false;
                    }
                    if (enumArray !== undefined) {
                        var predicate = void 0;
                        switch (name) {
                            case "null":
                                predicate = function (x) { return x === null; };
                                break;
                            case "integer":
                                predicate = function (x) { return typeof x === "number" && x === Math.floor(x); };
                                break;
                            default:
                                predicate = function (x) { return typeof x === name; };
                                break;
                        }
                        return enumArray.find(predicate) !== undefined;
                    }
                    return true;
                }
                var inferredAttributes, enumArray, typeSet, includeObject, includeArray, needStringEnum, needUnion, intersectionType, types, unionTypes, _i, _a, _b, name, kind, cases, _c, _d, _e, _f, virtualRef, _g, target, newLoc_1, attributes, _h, _j, _k, _l, _m, _o, _p, maybeAttributes, _q, _r;
                return __generator(this, function (_s) {
                    switch (_s.label) {
                        case 0:
                            typeAttributes = makeAttributes(schema, loc, typeAttributes);
                            inferredAttributes = TypeAttributes_1.makeTypeAttributesInferred(typeAttributes);
                            enumArray = Array.isArray(schema.enum) ? schema.enum : undefined;
                            typeSet = Support_1.mapOptional(function (t) { return checkTypeList(t, loc); }, schema.type);
                            includeObject = enumArray === undefined && (typeSet === undefined || typeSet.has("object"));
                            includeArray = enumArray === undefined && (typeSet === undefined || typeSet.has("array"));
                            needStringEnum = includePrimitiveType("string") &&
                                enumArray !== undefined &&
                                enumArray.find(function (x) { return typeof x === "string"; }) !== undefined;
                            needUnion = typeSet !== undefined ||
                                schema.properties !== undefined ||
                                schema.additionalProperties !== undefined ||
                                schema.items !== undefined ||
                                schema.required !== undefined ||
                                enumArray !== undefined;
                            intersectionType = typeBuilder.getUniqueIntersectionType(typeAttributes, undefined);
                            return [4 /*yield*/, setTypeForLocation(loc, intersectionType)];
                        case 1:
                            _s.sent();
                            types = [];
                            if (!needUnion) return [3 /*break*/, 6];
                            unionTypes = [];
                            for (_i = 0, _a = [
                                ["null", "null"],
                                ["number", "double"],
                                ["integer", "integer"],
                                ["boolean", "bool"]
                            ]; _i < _a.length; _i++) {
                                _b = _a[_i], name = _b[0], kind = _b[1];
                                if (!includePrimitiveType(name))
                                    continue;
                                unionTypes.push(typeBuilder.getPrimitiveType(kind));
                            }
                            if (needStringEnum) {
                                cases = enumArray.filter(function (x) { return typeof x === "string"; });
                                unionTypes.push(typeBuilder.getStringType(inferredAttributes, StringTypes_1.StringTypes.fromCases(cases)));
                            }
                            else if (includePrimitiveType("string")) {
                                unionTypes.push(makeStringType());
                            }
                            if (!includeArray) return [3 /*break*/, 3];
                            _d = (_c = unionTypes).push;
                            return [4 /*yield*/, makeArrayType()];
                        case 2:
                            _d.apply(_c, [_s.sent()]);
                            _s.label = 3;
                        case 3:
                            if (!includeObject) return [3 /*break*/, 5];
                            _f = (_e = unionTypes).push;
                            return [4 /*yield*/, makeObjectType()];
                        case 4:
                            _f.apply(_e, [_s.sent()]);
                            _s.label = 5;
                        case 5:
                            types.push(typeBuilder.getUniqueUnionType(inferredAttributes, immutable_1.OrderedSet(unionTypes)));
                            _s.label = 6;
                        case 6:
                            if (!(schema.$ref !== undefined)) return [3 /*break*/, 9];
                            if (typeof schema.$ref !== "string") {
                                return [2 /*return*/, Messages_1.messageError("SchemaRefMustBeString", withRef(loc, { actual: typeof schema.$ref }))];
                            }
                            virtualRef = Ref.parse(schema.$ref);
                            return [4 /*yield*/, resolveVirtualRef(loc, virtualRef)];
                        case 7:
                            _g = _s.sent(), target = _g[0], newLoc_1 = _g[1];
                            attributes = TypeNames_2.modifyTypeNames(typeAttributes, function (tn) {
                                if (!Support_1.defined(tn).areInferred)
                                    return tn;
                                return TypeNames_1.TypeNames.make(immutable_1.OrderedSet([newLoc_1.canonicalRef.name]), immutable_1.OrderedSet(), true);
                            });
                            _j = (_h = types).push;
                            return [4 /*yield*/, toType(target, newLoc_1, attributes)];
                        case 8:
                            _j.apply(_h, [_s.sent()]);
                            _s.label = 9;
                        case 9:
                            if (!(schema.allOf !== undefined)) return [3 /*break*/, 11];
                            _l = (_k = types.push).apply;
                            _m = [types];
                            return [4 /*yield*/, makeTypesFromCases(schema.allOf, "allOf")];
                        case 10:
                            _l.apply(_k, _m.concat([(_s.sent())]));
                            _s.label = 11;
                        case 11:
                            if (!(schema.oneOf !== undefined)) return [3 /*break*/, 13];
                            _p = (_o = types).push;
                            return [4 /*yield*/, convertOneOrAnyOf(schema.oneOf, "oneOf")];
                        case 12:
                            _p.apply(_o, [_s.sent()]);
                            return [3 /*break*/, 14];
                        case 13:
                            maybeAttributes = makeNonUnionAccessorAttributes(schema);
                            if (maybeAttributes !== undefined) {
                                typeBuilder.addAttributes(intersectionType, maybeAttributes);
                            }
                            _s.label = 14;
                        case 14:
                            if (!(schema.anyOf !== undefined)) return [3 /*break*/, 16];
                            _r = (_q = types).push;
                            return [4 /*yield*/, convertOneOrAnyOf(schema.anyOf, "anyOf")];
                        case 15:
                            _r.apply(_q, [_s.sent()]);
                            _s.label = 16;
                        case 16:
                            typeBuilder.setSetOperationMembers(intersectionType, immutable_1.OrderedSet(types));
                            return [2 /*return*/, intersectionType];
                    }
                });
            });
        }
        function toType(schema, loc, typeAttributes) {
            return __awaiter(this, void 0, void 0, function () {
                var maybeType, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            maybeType = typeForCanonicalRef.get(loc.canonicalRef);
                            if (maybeType !== undefined) {
                                return [2 /*return*/, maybeType];
                            }
                            if (!(typeof schema === "boolean")) return [3 /*break*/, 1];
                            // FIXME: Empty union.  We'd have to check that it's supported everywhere,
                            // in particular in union flattening.
                            Messages_1.messageAssert(schema === true, "SchemaFalseNotSupported", withRef(loc));
                            result = typeBuilder.getPrimitiveType("any");
                            return [3 /*break*/, 3];
                        case 1:
                            loc = loc.updateWithID(schema["$id"]);
                            return [4 /*yield*/, convertToType(schema, loc, typeAttributes)];
                        case 2:
                            result = _a.sent();
                            _a.label = 3;
                        case 3: return [4 /*yield*/, setTypeForLocation(loc, result)];
                        case 4:
                            _a.sent();
                            return [2 /*return*/, result];
                    }
                });
            });
        }
        var canonizer, typeForCanonicalRef;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    canonizer = new Canonizer();
                    typeForCanonicalRef = immutable_1.Map();
                    return [4 /*yield*/, Support_1.forEachSync(references, function (topLevelRef, topLevelName) { return __awaiter(_this, void 0, void 0, function () {
                            var _a, target, loc, t;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, resolveVirtualRef(undefined, topLevelRef)];
                                    case 1:
                                        _a = _b.sent(), target = _a[0], loc = _a[1];
                                        return [4 /*yield*/, toType(target, loc, TypeNames_2.makeNamesTypeAttributes(topLevelName, false))];
                                    case 2:
                                        t = _b.sent();
                                        typeBuilder.addTopLevel(topLevelName, t);
                                        return [2 /*return*/];
                                }
                            });
                        }); })];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.addTypesInSchema = addTypesInSchema;
function nameFromURI(uri) {
    // FIXME: Try `title` first.
    var fragment = uri.fragment();
    if (fragment !== "") {
        var components = fragment.split("/");
        var len = components.length;
        if (components[len - 1] !== "") {
            return components[len - 1];
        }
        if (len > 1 && components[len - 2] !== "") {
            return components[len - 2];
        }
    }
    var filename = uri.filename();
    if (filename !== "") {
        return filename;
    }
    return Messages_1.messageError("DriverCannotInferNameForSchema", { uri: uri.toString() });
}
function refsInSchemaForURI(store, uri, defaultName) {
    return __awaiter(this, void 0, void 0, function () {
        var fragment, propertiesAreTypes, ref, rootSchema, schema, name, maybeName;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fragment = uri.fragment();
                    propertiesAreTypes = fragment.endsWith("/");
                    if (propertiesAreTypes) {
                        uri = uri.clone().fragment(fragment.substr(0, fragment.length - 1));
                    }
                    ref = Ref.parseURI(uri);
                    if (ref.isRoot) {
                        propertiesAreTypes = false;
                    }
                    return [4 /*yield*/, getFromStore(store, ref.address, undefined)];
                case 1:
                    rootSchema = _a.sent();
                    schema = ref.lookupRef(rootSchema);
                    if (propertiesAreTypes) {
                        if (typeof schema !== "object") {
                            return [2 /*return*/, Messages_1.messageError("SchemaCannotGetTypesFromBoolean", { ref: ref.toString() })];
                        }
                        return [2 /*return*/, immutable_1.Map(schema).map(function (_, name) { return ref.push(name); })];
                    }
                    else {
                        name = void 0;
                        if (typeof schema === "object" && typeof schema.title === "string") {
                            name = schema.title;
                        }
                        else {
                            maybeName = nameFromURI(uri);
                            name = maybeName !== undefined ? maybeName : defaultName;
                        }
                        return [2 /*return*/, [name, ref]];
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.refsInSchemaForURI = refsInSchemaForURI;
