"use strict";
/* tslint:disable:strict-boolean-expressions */
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Type_1 = require("./Type");
var TypeUtils_1 = require("./TypeUtils");
var GraphQLSchema_1 = require("./GraphQLSchema");
var Support_1 = require("./Support");
var graphql = require("graphql/language");
var TypeNames_1 = require("./TypeNames");
var TypeAttributes_1 = require("./TypeAttributes");
var Messages_1 = require("./Messages");
var StringTypes_1 = require("./StringTypes");
function getField(t, name) {
    if (!t.fields)
        return Support_1.panic("Required field " + name + " in type " + t.name + " which doesn't have fields.");
    for (var _i = 0, _a = t.fields; _i < _a.length; _i++) {
        var f = _a[_i];
        if (f.name === name) {
            return f;
        }
    }
    return Support_1.panic("Required field " + name + " not defined on type " + t.name + ".");
}
function makeNames(name, fieldName, containingTypeName) {
    var alternatives = [];
    if (fieldName)
        alternatives.push(fieldName);
    if (containingTypeName)
        alternatives.push(containingTypeName + "_" + name);
    if (fieldName && containingTypeName)
        alternatives.push(containingTypeName + "_" + fieldName);
    return TypeNames_1.namesTypeAttributeKind.makeAttributes(TypeNames_1.TypeNames.make(immutable_1.OrderedSet([name]), immutable_1.OrderedSet(alternatives), false));
}
function makeNullable(builder, tref, name, fieldName, containingTypeName) {
    var typeNames = makeNames(name, fieldName, containingTypeName);
    var t = tref.deref();
    if (!(t instanceof Type_1.UnionType)) {
        return builder.getUnionType(typeNames, immutable_1.OrderedSet([tref, builder.getPrimitiveType("null")]));
    }
    var _a = TypeUtils_1.removeNullFromUnion(t), maybeNull = _a[0], nonNulls = _a[1];
    if (maybeNull)
        return tref;
    return builder.getUnionType(typeNames, nonNulls.map(function (nn) { return nn.typeRef; }).add(builder.getPrimitiveType("null")));
}
function removeNull(builder, tref) {
    var t = tref.deref();
    if (!(t instanceof Type_1.UnionType)) {
        return tref;
    }
    var nonNulls = TypeUtils_1.removeNullFromUnion(t)[1];
    var first = nonNulls.first();
    if (first) {
        if (nonNulls.size === 1)
            return first.typeRef;
        return builder.getUnionType(t.getAttributes(), nonNulls.map(function (nn) { return nn.typeRef; }));
    }
    return Support_1.panic("Trying to remove null results in empty union.");
}
function makeScalar(builder, ft) {
    switch (ft.name) {
        case "Boolean":
            return builder.getPrimitiveType("bool");
        case "Int":
            return builder.getPrimitiveType("integer");
        case "Float":
            return builder.getPrimitiveType("double");
        default:
            // FIXME: support ID specifically?
            return builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
    }
}
function hasOptionalDirectives(directives) {
    if (!directives)
        return false;
    for (var _i = 0, directives_1 = directives; _i < directives_1.length; _i++) {
        var d = directives_1[_i];
        var name = d.name.value;
        if (name === "include" || name === "skip")
            return true;
    }
    return false;
}
function expandSelectionSet(selectionSet, inType, optional) {
    return selectionSet.selections
        .reverse()
        .map(function (s) { return ({ selection: s, inType: inType, optional: optional || hasOptionalDirectives(s.directives) }); });
}
var GQLQuery = /** @class */ (function () {
    function GQLQuery(schema, queryString) {
        var _this = this;
        this.makeIRTypeFromFieldNode = function (builder, fieldNode, fieldType, containingTypeName) {
            var optional = hasOptionalDirectives(fieldNode.directives);
            var result;
            switch (fieldType.kind) {
                case GraphQLSchema_1.TypeKind.SCALAR:
                    result = makeScalar(builder, fieldType);
                    break;
                case GraphQLSchema_1.TypeKind.OBJECT:
                case GraphQLSchema_1.TypeKind.INTERFACE:
                case GraphQLSchema_1.TypeKind.UNION:
                    if (!fieldNode.selectionSet) {
                        return Support_1.panic("No selection set on object or interface");
                    }
                    return makeNullable(builder, _this.makeIRTypeFromSelectionSet(builder, fieldNode.selectionSet, fieldType, fieldNode.name.value, containingTypeName), fieldNode.name.value, null, containingTypeName);
                case GraphQLSchema_1.TypeKind.ENUM:
                    if (!fieldType.enumValues) {
                        return Support_1.panic("Enum type doesn't have values");
                    }
                    var values = fieldType.enumValues.map(function (ev) { return ev.name; });
                    var name = void 0;
                    var fieldName = void 0;
                    if (fieldType.name) {
                        name = fieldType.name;
                        fieldName = fieldNode.name.value;
                    }
                    else {
                        name = fieldNode.name.value;
                        fieldName = null;
                    }
                    result = builder.getEnumType(makeNames(name, fieldName, containingTypeName), immutable_1.OrderedSet(values));
                    break;
                case GraphQLSchema_1.TypeKind.INPUT_OBJECT:
                    return Support_1.panic("FIXME: Support input objects");
                case GraphQLSchema_1.TypeKind.LIST:
                    if (!fieldType.ofType) {
                        return Support_1.panic("No type for list.");
                    }
                    result = builder.getArrayType(_this.makeIRTypeFromFieldNode(builder, fieldNode, fieldType.ofType, containingTypeName));
                    break;
                case GraphQLSchema_1.TypeKind.NON_NULL:
                    if (!fieldType.ofType) {
                        return Support_1.panic("No type for non-null");
                    }
                    result = removeNull(builder, _this.makeIRTypeFromFieldNode(builder, fieldNode, fieldType.ofType, containingTypeName));
                    break;
                default:
                    return Support_1.assertNever(fieldType.kind);
            }
            if (optional) {
                result = makeNullable(builder, result, fieldNode.name.value, null, containingTypeName);
            }
            return result;
        };
        this.getFragment = function (name) {
            var fragment = _this._fragments[name];
            if (!fragment)
                return Support_1.panic("Fragment " + name + " is not defined.");
            return fragment;
        };
        this.makeIRTypeFromSelectionSet = function (builder, selectionSet, gqlType, containingFieldName, containingTypeName, overrideName) {
            if (gqlType.kind !== GraphQLSchema_1.TypeKind.OBJECT &&
                gqlType.kind !== GraphQLSchema_1.TypeKind.INTERFACE &&
                gqlType.kind !== GraphQLSchema_1.TypeKind.UNION) {
                return Support_1.panic("Type for selection set is not object, interface, or union.");
            }
            if (!gqlType.name) {
                return Support_1.panic("Object, interface, or union type doesn't have a name.");
            }
            var nameOrOverride = overrideName || gqlType.name;
            var properties = immutable_1.Map();
            var selections = expandSelectionSet(selectionSet, gqlType, false);
            for (;;) {
                var nextItem = selections.pop();
                if (!nextItem)
                    break;
                var selection = nextItem.selection, optional = nextItem.optional, inType = nextItem.inType;
                switch (selection.kind) {
                    case "Field":
                        var fieldName = selection.name.value;
                        var givenName = selection.alias ? selection.alias.value : fieldName;
                        var field = getField(inType, fieldName);
                        var fieldType = _this.makeIRTypeFromFieldNode(builder, selection, field.type, nameOrOverride);
                        properties = properties.set(givenName, new Type_1.ClassProperty(fieldType, optional));
                        break;
                    case "FragmentSpread": {
                        var fragment = _this.getFragment(selection.name.value);
                        var fragmentType = _this._schema.types[fragment.typeCondition.name.value];
                        var fragmentOptional = optional || fragmentType.name !== inType.name;
                        var expanded = expandSelectionSet(fragment.selectionSet, fragmentType, fragmentOptional);
                        selections = selections.concat(expanded);
                        break;
                    }
                    case "InlineFragment": {
                        // FIXME: support type conditions with discriminated unions
                        var fragmentType = selection.typeCondition
                            ? _this._schema.types[selection.typeCondition.name.value]
                            : inType;
                        var fragmentOptional = optional || fragmentType.name !== inType.name || hasOptionalDirectives(selection.directives);
                        var expanded = expandSelectionSet(selection.selectionSet, fragmentType, fragmentOptional);
                        selections = selections.concat(expanded);
                        break;
                    }
                    default:
                        Support_1.assertNever(selection);
                }
            }
            return builder.getClassType(makeNames(nameOrOverride, containingFieldName, containingTypeName), properties);
        };
        this._schema = schema;
        this._fragments = {};
        var queryDocument = graphql.parse(queryString);
        var queries = [];
        for (var _i = 0, _a = queryDocument.definitions; _i < _a.length; _i++) {
            var def = _a[_i];
            if (def.kind === "OperationDefinition") {
                if (def.operation !== "query")
                    continue;
                queries.push(def);
            }
            else if (def.kind === "FragmentDefinition") {
                this._fragments[def.name.value] = def;
            }
        }
        Messages_1.messageAssert(queries.length >= 1, "GraphQLNoQueriesDefined", {});
        this.queries = immutable_1.List(queries);
    }
    GQLQuery.prototype.makeType = function (builder, query, queryName) {
        return this.makeIRTypeFromSelectionSet(builder, query.selectionSet, this._schema.queryType, null, queryName, "data");
    };
    return GQLQuery;
}());
var GQLSchemaFromJSON = /** @class */ (function () {
    function GQLSchemaFromJSON(json) {
        var _this = this;
        this.types = {};
        this.addTypeFields = function (target, source) {
            if (source.fields) {
                target.fields = source.fields.map(function (f) {
                    return {
                        name: f.name,
                        description: f.description,
                        type: _this.makeType(f.type),
                        args: f.args.map(_this.makeInputValue)
                    };
                });
                // console.log(`${target.name} has ${target.fields.length} fields`);
            }
            if (source.interfaces) {
                target.interfaces = source.interfaces.map(_this.makeType);
                // console.log(`${target.name} has ${target.interfaces.length} interfaces`);
            }
            if (source.possibleTypes) {
                target.possibleTypes = source.possibleTypes.map(_this.makeType);
                // console.log(`${target.name} has ${target.possibleTypes.length} possibleTypes`);
            }
            if (source.inputFields) {
                target.inputFields = source.inputFields.map(_this.makeInputValue);
                // console.log(`${target.name} has ${target.inputFields.length} inputFields`);
            }
            if (source.enumValues) {
                target.enumValues = source.enumValues.map(function (ev) {
                    return { name: ev.name, description: ev.description };
                });
                // console.log(`${target.name} has ${target.enumValues.length} enumValues`);
            }
        };
        this.makeInputValue = function (iv) {
            return {
                name: iv.name,
                description: iv.description,
                type: _this.makeType(iv.type),
                defaultValue: iv.defaultValue
            };
        };
        this.makeType = function (t) {
            if (t.name) {
                var namedType = _this.types[t.name];
                if (!namedType)
                    return Support_1.panic("Type " + t.name + " not found");
                return namedType;
            }
            if (!t.ofType)
                return Support_1.panic("Type of kind " + t.kind + " has neither name nor ofType");
            var type = {
                kind: t.kind,
                description: t.description,
                ofType: _this.makeType(t.ofType)
            };
            _this.addTypeFields(type, t);
            return type;
        };
        var schema = json.data;
        if (schema.__schema.queryType.name === null) {
            return Support_1.panic("Query type doesn't have a name.");
        }
        for (var _i = 0, _a = schema.__schema.types; _i < _a.length; _i++) {
            var t = _a[_i];
            if (!t.name)
                return Support_1.panic("No top-level type name given");
            this.types[t.name] = { kind: t.kind, name: t.name, description: t.description };
        }
        for (var _b = 0, _c = schema.__schema.types; _b < _c.length; _b++) {
            var t = _c[_b];
            if (!t.name)
                return Support_1.panic("This cannot happen");
            var type = this.types[t.name];
            this.addTypeFields(type, t);
        }
        var queryType = this.types[schema.__schema.queryType.name];
        if (queryType === undefined) {
            return Support_1.panic("Query type not found.");
        }
        // console.log(`query type ${queryType.name} is ${queryType.kind}`);
        this.queryType = queryType;
    }
    return GQLSchemaFromJSON;
}());
function makeGraphQLQueryTypes(topLevelName, builder, json, queryString) {
    var schema = new GQLSchemaFromJSON(json);
    var query = new GQLQuery(schema, queryString);
    var types = immutable_1.Map();
    query.queries.forEach(function (odn) {
        var queryName = odn.name ? odn.name.value : topLevelName;
        if (types.has(queryName)) {
            return Support_1.panic("Duplicate query name " + queryName);
        }
        var dataType = query.makeType(builder, odn, queryName);
        var errorType = builder.getClassType(TypeNames_1.namesTypeAttributeKind.makeAttributes(TypeNames_1.TypeNames.make(immutable_1.OrderedSet(["error"]), immutable_1.OrderedSet(["graphQLError"]), false)), immutable_1.OrderedMap({
            message: new Type_1.ClassProperty(builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted), false)
        }));
        var errorArray = builder.getArrayType(errorType);
        builder.addAttributes(errorArray, TypeNames_1.namesTypeAttributeKind.makeAttributes(TypeNames_1.TypeNames.make(immutable_1.OrderedSet(["errors"]), immutable_1.OrderedSet(["graphQLErrors"]), false)));
        var t = builder.getClassType(TypeNames_1.makeNamesTypeAttributes(queryName, false), immutable_1.OrderedMap({
            data: new Type_1.ClassProperty(dataType, false),
            errors: new Type_1.ClassProperty(errorArray, true)
        }));
        types = types.set(queryName, t);
    });
    return types;
}
exports.makeGraphQLQueryTypes = makeGraphQLQueryTypes;
