"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var Support_1 = require("./Support");
var Acronyms_1 = require("./Acronyms");
var _ = require("lodash");
var Messages_1 = require("./Messages");
var unicode = require("unicode-properties");
function computeAsciiMap(mapper) {
    var charStringMap = [];
    var charNoEscapeMap = [];
    for (var i = 0; i < 128; i++) {
        var noEscape = 0;
        var result = mapper(i);
        if (result === String.fromCharCode(i)) {
            noEscape = 1;
        }
        charStringMap.push(result);
        charNoEscapeMap.push(noEscape);
    }
    return { charStringMap: charStringMap, charNoEscapeMap: charNoEscapeMap };
}
function precomputedCodePointPredicate(p) {
    var asciiResults = [];
    for (var cp = 0; cp < 128; cp++) {
        asciiResults.push(p(cp));
    }
    return function (cp) {
        return cp < 128 ? asciiResults[cp] : p(cp);
    };
}
// FIXME: This is a copy of code in src/Data/String/Util.js
function utf16ConcatMap(mapper) {
    var _a = computeAsciiMap(mapper), charStringMap = _a.charStringMap, charNoEscapeMap = _a.charNoEscapeMap;
    return function stringConcatMap_inner(s) {
        var cs = null;
        var start = 0;
        var i = 0;
        while (i < s.length) {
            var cc = s.charCodeAt(i);
            if (charNoEscapeMap[cc] !== 1) {
                if (cs === null)
                    cs = [];
                cs.push(s.substring(start, i));
                var str = charStringMap[cc];
                if (str === undefined) {
                    cs.push(mapper(s.charCodeAt(i)));
                }
                else {
                    cs.push(str);
                }
                start = i + 1;
            }
            i++;
        }
        if (cs === null)
            return s;
        cs.push(s.substring(start, i));
        return cs.join("");
    };
}
exports.utf16ConcatMap = utf16ConcatMap;
function isHighSurrogate(cc) {
    return cc >= 0xd800 && cc <= 0xdbff;
}
function isLowSurrogate(cc) {
    return cc >= 0xdc00 && cc <= 0xdfff;
}
function utf32ConcatMap(mapper) {
    var _a = computeAsciiMap(mapper), charStringMap = _a.charStringMap, charNoEscapeMap = _a.charNoEscapeMap;
    return function stringConcatMap_inner(s) {
        var cs = null;
        var start = 0;
        var i = 0;
        while (i < s.length) {
            var cc = s.charCodeAt(i);
            if (charNoEscapeMap[cc] !== 1) {
                if (cs === null)
                    cs = [];
                cs.push(s.substring(start, i));
                if (isHighSurrogate(cc)) {
                    var highSurrogate = cc;
                    i++;
                    var lowSurrogate = s.charCodeAt(i);
                    Messages_1.messageAssert(isLowSurrogate(lowSurrogate), "MiscUnicodeHighSurrogateWithoutLowSurrogate", {});
                    var highBits = highSurrogate - 0xd800;
                    var lowBits = lowSurrogate - 0xdc00;
                    cc = 0x10000 + lowBits + (highBits << 10);
                }
                var str = charStringMap[cc];
                if (str === undefined) {
                    cs.push(mapper(cc));
                }
                else {
                    cs.push(str);
                }
                start = i + 1;
            }
            i++;
        }
        if (cs === null)
            return s;
        cs.push(s.substring(start, i));
        return cs.join("");
    };
}
exports.utf32ConcatMap = utf32ConcatMap;
function utf16LegalizeCharacters(isLegal) {
    return utf16ConcatMap(function (u) { return (isLegal(u) ? String.fromCharCode(u) : ""); });
}
exports.utf16LegalizeCharacters = utf16LegalizeCharacters;
function legalizeCharacters(isLegal) {
    return utf32ConcatMap(function (u) { return (u <= 0xffff && isLegal(u) ? String.fromCharCode(u) : ""); });
}
exports.legalizeCharacters = legalizeCharacters;
function intToHex(i, width) {
    var str = i.toString(16);
    if (str.length >= width)
        return str;
    return _.repeat("0", width - str.length) + str;
}
exports.intToHex = intToHex;
function standardUnicodeHexEscape(codePoint) {
    if (codePoint <= 0xffff) {
        return "\\u" + intToHex(codePoint, 4);
    }
    else {
        return "\\U" + intToHex(codePoint, 8);
    }
}
exports.standardUnicodeHexEscape = standardUnicodeHexEscape;
function escapeNonPrintableMapper(printablePredicate, escaper) {
    function mapper(u) {
        switch (u) {
            case 0x5c:
                return "\\\\";
            case 0x22:
                return '\\"';
            case 0x0a:
                return "\\n";
            case 0x09:
                return "\\t";
            default:
                if (printablePredicate(u)) {
                    return String.fromCharCode(u);
                }
                return escaper(u);
        }
    }
    return mapper;
}
exports.escapeNonPrintableMapper = escapeNonPrintableMapper;
exports.utf16StringEscape = utf16ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
exports.stringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
function isPrintable(codePoint) {
    if (codePoint > 0xffff)
        return false;
    var category = unicode.getCategory(codePoint);
    return ([
        "Mc",
        "No",
        "Sk",
        "Me",
        "Nd",
        "Po",
        "Lt",
        "Pc",
        "Sm",
        "Zs",
        "Lu",
        "Pd",
        "So",
        "Pe",
        "Pf",
        "Ps",
        "Sc",
        "Ll",
        "Lm",
        "Pi",
        "Nl",
        "Mn",
        "Lo"
    ].indexOf(category) >= 0);
}
exports.isPrintable = isPrintable;
function isAscii(codePoint) {
    return codePoint < 128;
}
exports.isAscii = isAscii;
function isLetter(codePoint) {
    var category = unicode.getCategory(codePoint);
    // FIXME: Include Letter, modifier (Lm)?
    return ["Lu", "Ll", "Lt", "Lo"].indexOf(category) >= 0;
}
exports.isLetter = isLetter;
function isDigit(codePoint) {
    var category = unicode.getCategory(codePoint);
    return ["Nd"].indexOf(category) >= 0;
}
exports.isDigit = isDigit;
function isNumeric(codePoint) {
    var category = unicode.getCategory(codePoint);
    return ["No", "Nd", "Nl"].indexOf(category) >= 0;
}
exports.isNumeric = isNumeric;
function isLetterOrDigit(codePoint) {
    return isLetter(codePoint) || isDigit(codePoint);
}
exports.isLetterOrDigit = isLetterOrDigit;
function isLetterOrUnderscore(codePoint) {
    return isLetter(codePoint) || codePoint === 0x5f;
}
exports.isLetterOrUnderscore = isLetterOrUnderscore;
function isLetterOrUnderscoreOrDigit(codePoint) {
    return isLetterOrUnderscore(codePoint) || isDigit(codePoint);
}
exports.isLetterOrUnderscoreOrDigit = isLetterOrUnderscoreOrDigit;
function isWordCharacter(codePoint) {
    return isLetter(codePoint) || isDigit(codePoint);
}
exports.isWordCharacter = isWordCharacter;
function modifyFirstChar(f, s) {
    if (s === "")
        return s;
    return f(s[0]) + s.slice(1);
}
function capitalize(str) {
    return modifyFirstChar(function (c) { return c.toUpperCase(); }, str);
}
exports.capitalize = capitalize;
function decapitalize(str) {
    return modifyFirstChar(function (c) { return c.toLowerCase(); }, str);
}
exports.decapitalize = decapitalize;
var wordSeparatorRegex = /[-_. ]+/;
function pascalCase(str) {
    var words = str.split(wordSeparatorRegex).map(capitalize);
    return words.join("");
}
exports.pascalCase = pascalCase;
function camelCase(str) {
    return decapitalize(pascalCase(str));
}
exports.camelCase = camelCase;
function startWithLetter(isAllowedStart, // FIXME: technically, this operates on UTF16 units
upper, str) {
    var modify = upper ? capitalize : decapitalize;
    if (str === "")
        return modify("empty");
    if (isAllowedStart(str.charCodeAt(0)))
        return modify(str);
    return modify("the" + str);
}
exports.startWithLetter = startWithLetter;
var knownAcronyms = immutable_1.Set(Acronyms_1.acronyms);
var fastIsWordCharacter = precomputedCodePointPredicate(isWordCharacter);
var fastIsNonWordCharacter = precomputedCodePointPredicate(function (cp) { return !isWordCharacter(cp); });
var fastIsLowerCase = precomputedCodePointPredicate(function (cp) { return unicode.isLowerCase(cp); });
var fastIsUpperCase = precomputedCodePointPredicate(function (cp) { return unicode.isUpperCase(cp); });
var fastNonLetter = precomputedCodePointPredicate(function (cp) { return !unicode.isLowerCase(cp) && !unicode.isUpperCase(cp); });
var fastIsDigit = precomputedCodePointPredicate(isDigit);
function splitIntoWords(s) {
    // [start, end, allUpper]
    var intervals = [];
    var intervalStart = undefined;
    var len = s.length;
    var i = 0;
    var lastLowerCaseIndex = undefined;
    function atEnd() {
        return i >= len;
    }
    function currentCodePoint() {
        return Support_1.defined(s.codePointAt(i));
    }
    function skipWhile(p) {
        while (!atEnd()) {
            var cp = currentCodePoint();
            if (!p(cp))
                break;
            if (fastIsLowerCase(cp))
                lastLowerCaseIndex = i;
            i++;
        }
    }
    function skipNonWord() {
        skipWhile(fastIsNonWordCharacter);
    }
    function skipLowerCase() {
        skipWhile(fastIsLowerCase);
    }
    function skipUpperCase() {
        skipWhile(fastIsUpperCase);
    }
    function skipNonLetter() {
        skipWhile(fastNonLetter);
    }
    function skipDigits() {
        skipWhile(fastIsDigit);
    }
    function startInterval() {
        Support_1.assert(intervalStart === undefined, "Interval started before last one was committed");
        intervalStart = i;
    }
    function commitInterval() {
        if (intervalStart === undefined) {
            return Support_1.panic("Tried to commit interval without starting one");
        }
        Support_1.assert(i > intervalStart, "Interval must be non-empty");
        // FIXME: This is a hack to avoid splitting up surrogates.  We shouldn't
        // look at surrogates individually in the first place.  When we
        // encounter a high surrogate we have to combine it with the low
        // surrogate and then do the logic on the code point.  Right now we're
        // only operating on UTF16 char codes, which is wrong.
        if (!atEnd() && isLowSurrogate(currentCodePoint())) {
            i += 1;
        }
        var allUpper = lastLowerCaseIndex === undefined || lastLowerCaseIndex < intervalStart;
        intervals.push([intervalStart, i, allUpper]);
        intervalStart = undefined;
    }
    function intervalLength() {
        if (intervalStart === undefined) {
            return Support_1.panic("Tried to get interval length without starting one");
        }
        return i - intervalStart;
    }
    for (;;) {
        skipNonWord();
        if (atEnd())
            break;
        startInterval();
        if (fastIsLowerCase(currentCodePoint())) {
            skipLowerCase();
            skipDigits();
            commitInterval();
        }
        else if (fastIsUpperCase(currentCodePoint())) {
            skipUpperCase();
            if (atEnd()) {
                commitInterval();
            }
            else if (intervalLength() === 1) {
                skipLowerCase();
                skipDigits();
                commitInterval();
            }
            else if (isDigit(currentCodePoint())) {
                skipDigits();
                commitInterval();
            }
            else {
                if (fastIsWordCharacter(currentCodePoint())) {
                    i -= 1;
                }
                commitInterval();
            }
        }
        else {
            skipNonLetter();
            commitInterval();
        }
    }
    var words = [];
    for (var _i = 0, intervals_1 = intervals; _i < intervals_1.length; _i++) {
        var _a = intervals_1[_i], start = _a[0], end = _a[1], allUpper = _a[2];
        var word = s.slice(start, end);
        var isAcronym = (lastLowerCaseIndex !== undefined && allUpper) || knownAcronyms.has(word.toLowerCase());
        words.push({ word: word, isAcronym: isAcronym });
    }
    return words;
}
exports.splitIntoWords = splitIntoWords;
function firstUpperWordStyle(s) {
    Support_1.assert(s.length > 0, "Cannot style an empty string");
    return s[0].toUpperCase() + s.slice(1).toLowerCase();
}
exports.firstUpperWordStyle = firstUpperWordStyle;
function allUpperWordStyle(s) {
    return s.toUpperCase();
}
exports.allUpperWordStyle = allUpperWordStyle;
function allLowerWordStyle(s) {
    return s.toLowerCase();
}
exports.allLowerWordStyle = allLowerWordStyle;
function styleWord(style, word) {
    Support_1.assert(word.length > 0, "Tried to style an empty word");
    var result = style(word);
    Support_1.assert(result.length > 0, "Word style must not make word empty");
    return result;
}
function combineWords(words, removeInvalidCharacters, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, isStartCharacter) {
    var legalizedWords = [];
    for (var _i = 0, words_1 = words; _i < words_1.length; _i++) {
        var w = words_1[_i];
        var word = removeInvalidCharacters(w.word);
        if (word.length === 0)
            continue;
        legalizedWords.push({ word: word, isAcronym: w.isAcronym });
    }
    if (legalizedWords.length === 0) {
        var validEmpty = removeInvalidCharacters("empty");
        Support_1.assert(validEmpty.length > 0, 'Word "empty" is invalid in target language');
        legalizedWords.push({ word: validEmpty, isAcronym: false });
    }
    var styledWords = [];
    var first = legalizedWords[0];
    var firstStyle = first.isAcronym ? firstWordAcronymStyle : firstWordStyle;
    var styledFirstWord = styleWord(firstStyle, first.word);
    var restWords;
    if (!isStartCharacter(Support_1.defined(styledFirstWord.codePointAt(0)))) {
        var validThe = removeInvalidCharacters("the");
        Support_1.assert(validThe.length > 0, 'Word "the" is invalid in the target language');
        var styledThe = styleWord(firstWordStyle, validThe);
        Support_1.assert(isStartCharacter(Support_1.defined(styledThe.codePointAt(0))), 'The first character of styling "the" is not a start character');
        styledWords.push(styledThe);
        restWords = legalizedWords;
    }
    else {
        styledWords.push(styledFirstWord);
        restWords = legalizedWords.slice(1);
    }
    for (var _a = 0, restWords_1 = restWords; _a < restWords_1.length; _a++) {
        var w = restWords_1[_a];
        var style = w.isAcronym ? restAcronymStyle : restWordStyle;
        styledWords.push(styleWord(style, w.word));
    }
    return styledWords.join(separator);
}
exports.combineWords = combineWords;
function addPrefixIfNecessary(prefix, name) {
    // Take care not to doubly-prefix type names
    return name.startsWith(prefix) ? name : prefix + name;
}
exports.addPrefixIfNecessary = addPrefixIfNecessary;
