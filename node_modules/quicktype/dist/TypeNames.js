"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_1 = require("immutable");
var pluralize = require("pluralize");
var chance_1 = require("chance");
var Support_1 = require("./Support");
var TypeAttributes_1 = require("./TypeAttributes");
var Strings_1 = require("./Strings");
var chance;
var usedRandomNames;
function initTypeNames() {
    chance = new chance_1.Chance(31415);
    usedRandomNames = immutable_1.Set();
}
exports.initTypeNames = initTypeNames;
initTypeNames();
function makeRandomName() {
    for (;;) {
        var name = chance.city() + " " + chance.animal();
        if (usedRandomNames.has(name))
            continue;
        usedRandomNames = usedRandomNames.add(name);
        return name;
    }
}
// FIXME: In the case of overlapping prefixes and suffixes we will
// produce a name that includes the overlap twice.  For example, for
// the names "aaa" and "aaaa" we have the common prefix "aaa" and the
// common suffix "aaa", so we will produce the combined name "aaaaaa".
function combineNames(names) {
    var originalFirst = names.first();
    if (originalFirst === undefined) {
        return Support_1.panic("Named type has no names");
    }
    if (names.count() === 1) {
        return originalFirst;
    }
    var namesSet = names
        .map(function (s) {
        return Strings_1.splitIntoWords(s)
            .map(function (w) { return w.word.toLowerCase(); })
            .join("_");
    })
        .toSet();
    var first = Support_1.defined(namesSet.first());
    if (namesSet.size === 1) {
        return first;
    }
    var prefixLength = first.length;
    var suffixLength = first.length;
    namesSet.rest().forEach(function (n) {
        prefixLength = Math.min(prefixLength, n.length);
        for (var i = 0; i < prefixLength; i++) {
            if (first[i] !== n[i]) {
                prefixLength = i;
                break;
            }
        }
        suffixLength = Math.min(suffixLength, n.length);
        for (var i = 0; i < suffixLength; i++) {
            if (first[first.length - i - 1] !== n[n.length - i - 1]) {
                suffixLength = i;
                break;
            }
        }
    });
    var prefix = prefixLength > 2 ? first.substr(0, prefixLength) : "";
    var suffix = suffixLength > 2 ? first.substr(first.length - suffixLength) : "";
    var combined = prefix + suffix;
    if (combined.length > 2) {
        return combined;
    }
    return first;
}
exports.tooManyNamesThreshold = 20;
var TypeNames = /** @class */ (function () {
    function TypeNames() {
    }
    TypeNames.make = function (names, alternativeNames, areInferred) {
        if (names.size >= exports.tooManyNamesThreshold) {
            return new TooManyTypeNames(areInferred);
        }
        if (alternativeNames === undefined || alternativeNames.size > exports.tooManyNamesThreshold) {
            alternativeNames = undefined;
        }
        return new RegularTypeNames(names, alternativeNames, areInferred);
    };
    return TypeNames;
}());
exports.TypeNames = TypeNames;
var RegularTypeNames = /** @class */ (function (_super) {
    __extends(RegularTypeNames, _super);
    function RegularTypeNames(names, _alternativeNames, areInferred) {
        var _this = _super.call(this) || this;
        _this.names = names;
        _this._alternativeNames = _alternativeNames;
        _this.areInferred = areInferred;
        return _this;
    }
    RegularTypeNames.prototype.add = function (names) {
        if (!(names instanceof RegularTypeNames)) {
            Support_1.assert(names instanceof TooManyTypeNames, "Unknown TypeNames instance");
            if (this.areInferred === names.areInferred || !names.areInferred) {
                return names;
            }
            return this;
        }
        var newNames = this.names;
        var newAreInferred = this.areInferred;
        if (this.areInferred && !names.areInferred) {
            newNames = names.names;
            newAreInferred = false;
        }
        else if (this.areInferred === names.areInferred) {
            newNames = this.names.union(names.names);
        }
        var newAlternativeNames = this._alternativeNames === undefined || names._alternativeNames === undefined
            ? undefined
            : this._alternativeNames.union(names._alternativeNames);
        return TypeNames.make(newNames, newAlternativeNames, newAreInferred);
    };
    RegularTypeNames.prototype.clearInferred = function () {
        var newNames = this.areInferred ? immutable_1.OrderedSet() : this.names;
        return TypeNames.make(newNames, immutable_1.OrderedSet(), this.areInferred);
    };
    Object.defineProperty(RegularTypeNames.prototype, "combinedName", {
        get: function () {
            return combineNames(this.names);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RegularTypeNames.prototype, "proposedNames", {
        get: function () {
            var set = immutable_1.OrderedSet([this.combinedName]);
            if (this._alternativeNames === undefined) {
                return set;
            }
            return set.union(this._alternativeNames);
        },
        enumerable: true,
        configurable: true
    });
    RegularTypeNames.prototype.makeInferred = function () {
        if (this.areInferred)
            return this;
        return TypeNames.make(this.names, this._alternativeNames, true);
    };
    RegularTypeNames.prototype.singularize = function () {
        return TypeNames.make(this.names.map(pluralize.singular), Support_1.mapOptional(function (an) { return an.map(pluralize.singular); }, this._alternativeNames), true);
    };
    RegularTypeNames.prototype.toString = function () {
        var inferred = this.areInferred ? "inferred" : "given";
        var names = inferred + " " + this.names.join(",");
        if (this._alternativeNames === undefined) {
            return names;
        }
        return names + " (" + this._alternativeNames.join(",") + ")";
    };
    return RegularTypeNames;
}(TypeNames));
exports.RegularTypeNames = RegularTypeNames;
var TooManyTypeNames = /** @class */ (function (_super) {
    __extends(TooManyTypeNames, _super);
    function TooManyTypeNames(areInferred) {
        var _this = _super.call(this) || this;
        _this.areInferred = areInferred;
        _this.names = immutable_1.OrderedSet([makeRandomName()]);
        return _this;
    }
    Object.defineProperty(TooManyTypeNames.prototype, "combinedName", {
        get: function () {
            return Support_1.defined(this.names.first());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooManyTypeNames.prototype, "proposedNames", {
        get: function () {
            return this.names;
        },
        enumerable: true,
        configurable: true
    });
    TooManyTypeNames.prototype.add = function (_names) {
        return this;
    };
    TooManyTypeNames.prototype.clearInferred = function () {
        if (!this.areInferred) {
            return this;
        }
        return TypeNames.make(immutable_1.OrderedSet(), immutable_1.OrderedSet(), true);
    };
    TooManyTypeNames.prototype.makeInferred = function () {
        return this;
    };
    TooManyTypeNames.prototype.singularize = function () {
        return this;
    };
    TooManyTypeNames.prototype.toString = function () {
        return "too many " + this.combinedName;
    };
    return TooManyTypeNames;
}(TypeNames));
exports.TooManyTypeNames = TooManyTypeNames;
function typeNamesUnion(c) {
    var names = TypeNames.make(immutable_1.OrderedSet(), immutable_1.OrderedSet(), true);
    c.forEach(function (n) {
        names = names.add(n);
    });
    return names;
}
exports.typeNamesUnion = typeNamesUnion;
var DescriptionTypeAttributeKind = /** @class */ (function (_super) {
    __extends(DescriptionTypeAttributeKind, _super);
    function DescriptionTypeAttributeKind() {
        return _super.call(this, "names") || this;
    }
    DescriptionTypeAttributeKind.prototype.combine = function (a, b) {
        return a.add(b);
    };
    DescriptionTypeAttributeKind.prototype.makeInferred = function (tn) {
        return tn.makeInferred();
    };
    DescriptionTypeAttributeKind.prototype.stringify = function (tn) {
        return tn.toString();
    };
    return DescriptionTypeAttributeKind;
}(TypeAttributes_1.TypeAttributeKind));
exports.namesTypeAttributeKind = new DescriptionTypeAttributeKind();
function modifyTypeNames(attributes, modifier) {
    return exports.namesTypeAttributeKind.modifyInAttributes(attributes, modifier);
}
exports.modifyTypeNames = modifyTypeNames;
function singularizeTypeNames(attributes) {
    return modifyTypeNames(attributes, function (maybeNames) {
        if (maybeNames === undefined)
            return undefined;
        return maybeNames.singularize();
    });
}
exports.singularizeTypeNames = singularizeTypeNames;
function makeNamesTypeAttributes(nameOrNames, areNamesInferred) {
    var typeNames;
    if (typeof nameOrNames === "string") {
        typeNames = TypeNames.make(immutable_1.OrderedSet([nameOrNames]), immutable_1.OrderedSet(), Support_1.defined(areNamesInferred));
    }
    else {
        typeNames = nameOrNames;
    }
    return exports.namesTypeAttributeKind.makeAttributes(typeNames);
}
exports.makeNamesTypeAttributes = makeNamesTypeAttributes;
