
// Code generated by @open-rpc/client-generator DO NOT EDIT.
import * as jayson from "jayson/promise";
import ajv from "ajv";
import _ from "lodash";
import { OpenRPC, MethodObject, ContentDescriptorObject } from "@open-rpc/meta-schema";
import { MethodCallValidator } from "@open-rpc/schema-utils-js";

export type TServiceName = string;
export type TVersion = string;
export type TInstallSuccess = boolean;
export type TInstalledServices = string[];
export type TRunningServices = Array<{
  type?: Array<string | string | string>;
  [k: string]: any;
}>;
export interface IServiceConfig {
  type?: Array<string | string | string>;
  host?: string;
  port?: number;
  name?: string;
  environment?: string;
  [k: string]: any;
}

export default class ServiceRunner {
  public rpc: jayson.Client;
  private validator: MethodCallValidator;
  private openrpcDocument: OpenRPC;

  constructor(options: any) {
    this.openrpcDocument = {"info": {"title": "something", "version": "44"}, "methods": [{"name": "installService", "params": [{"name": "serviceName", "schema": {"type": "string"}}, {"name": "version", "schema": {"type": "string"}}], "result": {"name": "installSuccess", "schema": {"type": "boolean"}}}, {"name": "listInstalledServices", "params": [], "result": {"name": "installedServices", "schema": {"type": "array", "items": {"type": "string"}}}}, {"name": "listRunningServices", "params": [], "result": {"name": "runningServices", "schema": {"type": "array", "items": {"type": "object", "properties": {"type": {"type": "array", "items": {"anyOf": [{"type": "string", "pattern": "^http$"}, {"type": "string", "pattern": "^https$"}, {"type": "string", "pattern": "^ws$"}]}}}, "host": {"type": "string"}, "port": {"type": "integer"}, "name": {"type": "string"}, "environment": {"type": "string"}}}}}, {"name": "startService", "params": [], "result": {"name": "serviceConfig", "schema": {"type": "object", "properties": {"type": {"type": "array", "items": {"anyOf": [{"type": "string", "pattern": "^http$"}, {"type": "string", "pattern": "^https$"}, {"type": "string", "pattern": "^ws$"}]}}, "host": {"type": "string"}, "port": {"type": "integer"}, "name": {"type": "string"}, "environment": {"type": "string"}}}}}], "openrpc": "1.0.0-rc0"};

    if (options.transport === undefined || options.transport.type === undefined) {
      throw new Error("Invalid constructor params");
    }
    this.rpc = (jayson.Client as any)[options.transport.type](options.transport);
    this.validator = new MethodCallValidator(this.openrpcDocument);
  }

  /**
   *
   */
  public installService(serviceName: TServiceName, version: TVersion): Promise<TInstallSuccess> {
    return this.request("installService", Array.from(arguments));
  }

  /**
   *
   */
  public listInstalledServices(): Promise<TInstalledServices> {
    return this.request("listInstalledServices", Array.from(arguments));
  }

  /**
   *
   */
  public listRunningServices(): Promise<TRunningServices> {
    return this.request("listRunningServices", Array.from(arguments));
  }

  /**
   *
   */
  public startService(): Promise<IServiceConfig> {
    return this.request("startService", Array.from(arguments));
  }

  private request(methodName: string, params: any[]): Promise<any> {
    const methodObject = _.find(this.openrpcDocument.methods, ({name}) => name === methodName) as MethodObject;
    const openRpcMethodValidationErrors = this.validator.validate(methodName, params);
    if (openRpcMethodValidationErrors.length > 0) {
      return Promise.reject(openRpcMethodValidationErrors);
    }

    let rpcParams;
    if (methodObject.paramStructure && methodObject.paramStructure === "by-name") {
      rpcParams = _.zipObject(params, _.map(methodObject.params, "name"));
    } else {
      rpcParams = Array.from(arguments);
    }
    const result: any = this.rpc.request(methodName, rpcParams);
    return result.then((r: any) => r.result);
  }

}
